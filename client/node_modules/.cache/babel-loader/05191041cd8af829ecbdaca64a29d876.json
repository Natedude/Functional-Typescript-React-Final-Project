{"ast":null,"code":"import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\n\nexport class Noise extends Source {\n  constructor() {\n    super(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n    this.name = \"Noise\";\n    /**\n     * Private reference to the source\n     */\n\n    this._source = null;\n    const options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n    this._playbackRate = options.playbackRate;\n    this.type = options.type;\n    this._fadeIn = options.fadeIn;\n    this._fadeOut = options.fadeOut;\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      fadeIn: 0,\n      fadeOut: 0,\n      playbackRate: 1,\n      type: \"white\"\n    });\n  }\n  /**\n   * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n   * @example\n   * const noise = new Tone.Noise().toDestination().start();\n   * noise.type = \"brown\";\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\n    if (this._type !== type) {\n      this._type = type; // if it's playing, stop and restart it\n\n      if (this.state === \"started\") {\n        const now = this.now();\n\n        this._stop(now);\n\n        this._start(now);\n      }\n    }\n  }\n  /**\n   * The playback rate of the noise. Affects\n   * the \"frequency\" of the noise.\n   */\n\n\n  get playbackRate() {\n    return this._playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._playbackRate = rate;\n\n    if (this._source) {\n      this._source.playbackRate.value = rate;\n    }\n  }\n  /**\n   * internal start method\n   */\n\n\n  _start(time) {\n    const buffer = _noiseBuffers[this._type];\n    this._source = new ToneBufferSource({\n      url: buffer,\n      context: this.context,\n      fadeIn: this._fadeIn,\n      fadeOut: this._fadeOut,\n      loop: true,\n      onended: () => this.onstop(this),\n      playbackRate: this._playbackRate\n    }).connect(this.output);\n\n    this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n  }\n  /**\n   * internal stop method\n   */\n\n\n  _stop(time) {\n    if (this._source) {\n      this._source.stop(this.toSeconds(time));\n\n      this._source = null;\n    }\n  }\n  /**\n   * The fadeIn time of the amplitude envelope.\n   */\n\n\n  get fadeIn() {\n    return this._fadeIn;\n  }\n\n  set fadeIn(time) {\n    this._fadeIn = time;\n\n    if (this._source) {\n      this._source.fadeIn = this._fadeIn;\n    }\n  }\n  /**\n   * The fadeOut time of the amplitude envelope.\n   */\n\n\n  get fadeOut() {\n    return this._fadeOut;\n  }\n\n  set fadeOut(time) {\n    this._fadeOut = time;\n\n    if (this._source) {\n      this._source.fadeOut = this._fadeOut;\n    }\n  }\n\n  _restart(time) {\n    // TODO could be optimized by cancelling the buffer source 'stop'\n    this._stop(time);\n\n    this._start(time);\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (this._source) {\n      this._source.disconnect();\n    }\n\n    return this;\n  }\n\n} //--------------------\n// THE NOISE BUFFERS\n//--------------------\n// Noise buffer stats\n\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n/**\n * Cache the noise buffers\n */\n\nconst _noiseCache = {\n  brown: null,\n  pink: null,\n  white: null\n};\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\n\nconst _noiseBuffers = {\n  get brown() {\n    if (!_noiseCache.brown) {\n      const buffer = [];\n\n      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        const channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        let lastOut = 0.0;\n\n        for (let i = 0; i < BUFFER_LENGTH; i++) {\n          const white = Math.random() * 2 - 1;\n          channel[i] = (lastOut + 0.02 * white) / 1.02;\n          lastOut = channel[i];\n          channel[i] *= 3.5; // (roughly) compensate for gain\n        }\n      }\n\n      _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.brown;\n  },\n\n  get pink() {\n    if (!_noiseCache.pink) {\n      const buffer = [];\n\n      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        const channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        let b0, b1, b2, b3, b4, b5, b6;\n        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\n        for (let i = 0; i < BUFFER_LENGTH; i++) {\n          const white = Math.random() * 2 - 1;\n          b0 = 0.99886 * b0 + white * 0.0555179;\n          b1 = 0.99332 * b1 + white * 0.0750759;\n          b2 = 0.96900 * b2 + white * 0.1538520;\n          b3 = 0.86650 * b3 + white * 0.3104856;\n          b4 = 0.55000 * b4 + white * 0.5329522;\n          b5 = -0.7616 * b5 - white * 0.0168980;\n          channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n          channel[i] *= 0.11; // (roughly) compensate for gain\n\n          b6 = white * 0.115926;\n        }\n      }\n\n      _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.pink;\n  },\n\n  get white() {\n    if (!_noiseCache.white) {\n      const buffer = [];\n\n      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        const channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n\n        for (let i = 0; i < BUFFER_LENGTH; i++) {\n          channel[i] = Math.random() * 2 - 1;\n        }\n      }\n\n      _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.white;\n  }\n\n};","map":{"version":3,"sources":["../../../Tone/source/Noise.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\nexport class Noise extends Source {\n    constructor() {\n        super(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n        this.name = \"Noise\";\n        /**\n         * Private reference to the source\n         */\n        this._source = null;\n        const options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n        this._playbackRate = options.playbackRate;\n        this.type = options.type;\n        this._fadeIn = options.fadeIn;\n        this._fadeOut = options.fadeOut;\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            fadeIn: 0,\n            fadeOut: 0,\n            playbackRate: 1,\n            type: \"white\",\n        });\n    }\n    /**\n     * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n     * @example\n     * const noise = new Tone.Noise().toDestination().start();\n     * noise.type = \"brown\";\n     */\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n        if (this._type !== type) {\n            this._type = type;\n            // if it's playing, stop and restart it\n            if (this.state === \"started\") {\n                const now = this.now();\n                this._stop(now);\n                this._start(now);\n            }\n        }\n    }\n    /**\n     * The playback rate of the noise. Affects\n     * the \"frequency\" of the noise.\n     */\n    get playbackRate() {\n        return this._playbackRate;\n    }\n    set playbackRate(rate) {\n        this._playbackRate = rate;\n        if (this._source) {\n            this._source.playbackRate.value = rate;\n        }\n    }\n    /**\n     * internal start method\n     */\n    _start(time) {\n        const buffer = _noiseBuffers[this._type];\n        this._source = new ToneBufferSource({\n            url: buffer,\n            context: this.context,\n            fadeIn: this._fadeIn,\n            fadeOut: this._fadeOut,\n            loop: true,\n            onended: () => this.onstop(this),\n            playbackRate: this._playbackRate,\n        }).connect(this.output);\n        this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n    }\n    /**\n     * internal stop method\n     */\n    _stop(time) {\n        if (this._source) {\n            this._source.stop(this.toSeconds(time));\n            this._source = null;\n        }\n    }\n    /**\n     * The fadeIn time of the amplitude envelope.\n     */\n    get fadeIn() {\n        return this._fadeIn;\n    }\n    set fadeIn(time) {\n        this._fadeIn = time;\n        if (this._source) {\n            this._source.fadeIn = this._fadeIn;\n        }\n    }\n    /**\n     * The fadeOut time of the amplitude envelope.\n     */\n    get fadeOut() {\n        return this._fadeOut;\n    }\n    set fadeOut(time) {\n        this._fadeOut = time;\n        if (this._source) {\n            this._source.fadeOut = this._fadeOut;\n        }\n    }\n    _restart(time) {\n        // TODO could be optimized by cancelling the buffer source 'stop'\n        this._stop(time);\n        this._start(time);\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        if (this._source) {\n            this._source.disconnect();\n        }\n        return this;\n    }\n}\n//--------------------\n// THE NOISE BUFFERS\n//--------------------\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n/**\n * Cache the noise buffers\n */\nconst _noiseCache = {\n    brown: null,\n    pink: null,\n    white: null,\n};\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n    get brown() {\n        if (!_noiseCache.brown) {\n            const buffer = [];\n            for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n                const channel = new Float32Array(BUFFER_LENGTH);\n                buffer[channelNum] = channel;\n                let lastOut = 0.0;\n                for (let i = 0; i < BUFFER_LENGTH; i++) {\n                    const white = Math.random() * 2 - 1;\n                    channel[i] = (lastOut + (0.02 * white)) / 1.02;\n                    lastOut = channel[i];\n                    channel[i] *= 3.5; // (roughly) compensate for gain\n                }\n            }\n            _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n        }\n        return _noiseCache.brown;\n    },\n    get pink() {\n        if (!_noiseCache.pink) {\n            const buffer = [];\n            for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n                const channel = new Float32Array(BUFFER_LENGTH);\n                buffer[channelNum] = channel;\n                let b0, b1, b2, b3, b4, b5, b6;\n                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n                for (let i = 0; i < BUFFER_LENGTH; i++) {\n                    const white = Math.random() * 2 - 1;\n                    b0 = 0.99886 * b0 + white * 0.0555179;\n                    b1 = 0.99332 * b1 + white * 0.0750759;\n                    b2 = 0.96900 * b2 + white * 0.1538520;\n                    b3 = 0.86650 * b3 + white * 0.3104856;\n                    b4 = 0.55000 * b4 + white * 0.5329522;\n                    b5 = -0.7616 * b5 - white * 0.0168980;\n                    channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n                    channel[i] *= 0.11; // (roughly) compensate for gain\n                    b6 = white * 0.115926;\n                }\n            }\n            _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n        }\n        return _noiseCache.pink;\n    },\n    get white() {\n        if (!_noiseCache.white) {\n            const buffer = [];\n            for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n                const channel = new Float32Array(BUFFER_LENGTH);\n                buffer[channelNum] = channel;\n                for (let i = 0; i < BUFFER_LENGTH; i++) {\n                    channel[i] = Math.random() * 2 - 1;\n                }\n            }\n            _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n        }\n        return _noiseCache.white;\n    },\n};\n//# sourceMappingURL=Noise.js.map"]},"metadata":{},"sourceType":"module"}