{"ast":null,"code":"import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator } from \"./Oscillator\";\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @example\n * return Tone.Offline(() => {\n * \tconst lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * }, 0.5, 1);\n * @category Source\n */\n\nexport class LFO extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n    this.name = \"LFO\";\n    /**\n     * The value that the LFO outputs when it's stopped\n     */\n\n    this._stoppedValue = 0;\n    /**\n     * A private placeholder for the units\n     */\n\n    this._units = \"number\";\n    /**\n     * If the input value is converted using the [[units]]\n     */\n\n    this.convert = true;\n    /**\n     * Private methods borrowed from Param\n     */\n    // @ts-ignore\n\n    this._fromType = Param.prototype._fromType; // @ts-ignore\n\n    this._toType = Param.prototype._toType; // @ts-ignore\n\n    this._is = Param.prototype._is; // @ts-ignore\n\n    this._clampValue = Param.prototype._clampValue;\n    const options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]);\n    this._oscillator = new Oscillator(options);\n    this.frequency = this._oscillator.frequency;\n    this._amplitudeGain = new Gain({\n      context: this.context,\n      gain: options.amplitude,\n      units: \"normalRange\"\n    });\n    this.amplitude = this._amplitudeGain.gain;\n    this._stoppedSignal = new Signal({\n      context: this.context,\n      units: \"audioRange\",\n      value: 0\n    });\n    this._zeros = new Zero({\n      context: this.context\n    });\n    this._a2g = new AudioToGain({\n      context: this.context\n    });\n    this._scaler = this.output = new Scale({\n      context: this.context,\n      max: options.max,\n      min: options.min\n    });\n    this.units = options.units;\n    this.min = options.min;\n    this.max = options.max; // connect it up\n\n    this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);\n\n    this._zeros.connect(this._a2g);\n\n    this._stoppedSignal.connect(this._a2g);\n\n    readOnly(this, [\"amplitude\", \"frequency\"]);\n    this.phase = options.phase;\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      amplitude: 1,\n      frequency: \"4n\",\n      max: 1,\n      min: 0,\n      type: \"sine\",\n      units: \"number\"\n    });\n  }\n  /**\n   * Start the LFO.\n   * @param time The time the LFO will start\n   */\n\n\n  start(time) {\n    time = this.toSeconds(time);\n\n    this._stoppedSignal.setValueAtTime(0, time);\n\n    this._oscillator.start(time);\n\n    return this;\n  }\n  /**\n   * Stop the LFO.\n   * @param  time The time the LFO will stop\n   */\n\n\n  stop(time) {\n    time = this.toSeconds(time);\n\n    this._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\n    this._oscillator.stop(time);\n\n    return this;\n  }\n  /**\n   * Sync the start/stop/pause to the transport\n   * and the frequency to the bpm of the transport\n   * @example\n   * const lfo = new Tone.LFO(\"8n\");\n   * lfo.sync().start(0);\n   * // the rate of the LFO will always be an eighth note, even as the tempo changes\n   */\n\n\n  sync() {\n    this._oscillator.sync();\n\n    this._oscillator.syncFrequency();\n\n    return this;\n  }\n  /**\n   * unsync the LFO from transport control\n   */\n\n\n  unsync() {\n    this._oscillator.unsync();\n\n    this._oscillator.unsyncFrequency();\n\n    return this;\n  }\n  /**\n   * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform\n   */\n\n\n  _setStoppedValue() {\n    this._stoppedValue = this._oscillator.getInitialValue();\n    this._stoppedSignal.value = this._stoppedValue;\n  }\n  /**\n   * The minimum output of the LFO.\n   */\n\n\n  get min() {\n    return this._toType(this._scaler.min);\n  }\n\n  set min(min) {\n    min = this._fromType(min);\n    this._scaler.min = min;\n  }\n  /**\n   * The maximum output of the LFO.\n   */\n\n\n  get max() {\n    return this._toType(this._scaler.max);\n  }\n\n  set max(max) {\n    max = this._fromType(max);\n    this._scaler.max = max;\n  }\n  /**\n   * The type of the oscillator: See [[Oscillator.type]]\n   */\n\n\n  get type() {\n    return this._oscillator.type;\n  }\n\n  set type(type) {\n    this._oscillator.type = type;\n\n    this._setStoppedValue();\n  }\n  /**\n   * The oscillator's partials array: See [[Oscillator.partials]]\n   */\n\n\n  get partials() {\n    return this._oscillator.partials;\n  }\n\n  set partials(partials) {\n    this._oscillator.partials = partials;\n\n    this._setStoppedValue();\n  }\n  /**\n   * The phase of the LFO.\n   */\n\n\n  get phase() {\n    return this._oscillator.phase;\n  }\n\n  set phase(phase) {\n    this._oscillator.phase = phase;\n\n    this._setStoppedValue();\n  }\n  /**\n   * The output units of the LFO.\n   */\n\n\n  get units() {\n    return this._units;\n  }\n\n  set units(val) {\n    const currentMin = this.min;\n    const currentMax = this.max; // convert the min and the max\n\n    this._units = val;\n    this.min = currentMin;\n    this.max = currentMax;\n  }\n  /**\n   * Returns the playback state of the source, either \"started\" or \"stopped\".\n   */\n\n\n  get state() {\n    return this._oscillator.state;\n  }\n  /**\n   * @param node the destination to connect to\n   * @param outputNum the optional output number\n   * @param inputNum the input number\n   */\n\n\n  connect(node, outputNum, inputNum) {\n    if (node instanceof Param || node instanceof Signal) {\n      this.convert = node.convert;\n      this.units = node.units;\n    }\n\n    connectSignal(this, node, outputNum, inputNum);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._oscillator.dispose();\n\n    this._stoppedSignal.dispose();\n\n    this._zeros.dispose();\n\n    this._scaler.dispose();\n\n    this._a2g.dispose();\n\n    this._amplitudeGain.dispose();\n\n    this.amplitude.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/source/oscillator/LFO.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator } from \"./Oscillator\";\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @example\n * return Tone.Offline(() => {\n * \tconst lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * }, 0.5, 1);\n * @category Source\n */\nexport class LFO extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n        this.name = \"LFO\";\n        /**\n         * The value that the LFO outputs when it's stopped\n         */\n        this._stoppedValue = 0;\n        /**\n         * A private placeholder for the units\n         */\n        this._units = \"number\";\n        /**\n         * If the input value is converted using the [[units]]\n         */\n        this.convert = true;\n        /**\n         * Private methods borrowed from Param\n         */\n        // @ts-ignore\n        this._fromType = Param.prototype._fromType;\n        // @ts-ignore\n        this._toType = Param.prototype._toType;\n        // @ts-ignore\n        this._is = Param.prototype._is;\n        // @ts-ignore\n        this._clampValue = Param.prototype._clampValue;\n        const options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]);\n        this._oscillator = new Oscillator(options);\n        this.frequency = this._oscillator.frequency;\n        this._amplitudeGain = new Gain({\n            context: this.context,\n            gain: options.amplitude,\n            units: \"normalRange\",\n        });\n        this.amplitude = this._amplitudeGain.gain;\n        this._stoppedSignal = new Signal({\n            context: this.context,\n            units: \"audioRange\",\n            value: 0,\n        });\n        this._zeros = new Zero({ context: this.context });\n        this._a2g = new AudioToGain({ context: this.context });\n        this._scaler = this.output = new Scale({\n            context: this.context,\n            max: options.max,\n            min: options.min,\n        });\n        this.units = options.units;\n        this.min = options.min;\n        this.max = options.max;\n        // connect it up\n        this._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);\n        this._zeros.connect(this._a2g);\n        this._stoppedSignal.connect(this._a2g);\n        readOnly(this, [\"amplitude\", \"frequency\"]);\n        this.phase = options.phase;\n    }\n    static getDefaults() {\n        return Object.assign(Oscillator.getDefaults(), {\n            amplitude: 1,\n            frequency: \"4n\",\n            max: 1,\n            min: 0,\n            type: \"sine\",\n            units: \"number\",\n        });\n    }\n    /**\n     * Start the LFO.\n     * @param time The time the LFO will start\n     */\n    start(time) {\n        time = this.toSeconds(time);\n        this._stoppedSignal.setValueAtTime(0, time);\n        this._oscillator.start(time);\n        return this;\n    }\n    /**\n     * Stop the LFO.\n     * @param  time The time the LFO will stop\n     */\n    stop(time) {\n        time = this.toSeconds(time);\n        this._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n        this._oscillator.stop(time);\n        return this;\n    }\n    /**\n     * Sync the start/stop/pause to the transport\n     * and the frequency to the bpm of the transport\n     * @example\n     * const lfo = new Tone.LFO(\"8n\");\n     * lfo.sync().start(0);\n     * // the rate of the LFO will always be an eighth note, even as the tempo changes\n     */\n    sync() {\n        this._oscillator.sync();\n        this._oscillator.syncFrequency();\n        return this;\n    }\n    /**\n     * unsync the LFO from transport control\n     */\n    unsync() {\n        this._oscillator.unsync();\n        this._oscillator.unsyncFrequency();\n        return this;\n    }\n    /**\n     * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform\n     */\n    _setStoppedValue() {\n        this._stoppedValue = this._oscillator.getInitialValue();\n        this._stoppedSignal.value = this._stoppedValue;\n    }\n    /**\n     * The minimum output of the LFO.\n     */\n    get min() {\n        return this._toType(this._scaler.min);\n    }\n    set min(min) {\n        min = this._fromType(min);\n        this._scaler.min = min;\n    }\n    /**\n     * The maximum output of the LFO.\n     */\n    get max() {\n        return this._toType(this._scaler.max);\n    }\n    set max(max) {\n        max = this._fromType(max);\n        this._scaler.max = max;\n    }\n    /**\n     * The type of the oscillator: See [[Oscillator.type]]\n     */\n    get type() {\n        return this._oscillator.type;\n    }\n    set type(type) {\n        this._oscillator.type = type;\n        this._setStoppedValue();\n    }\n    /**\n     * The oscillator's partials array: See [[Oscillator.partials]]\n     */\n    get partials() {\n        return this._oscillator.partials;\n    }\n    set partials(partials) {\n        this._oscillator.partials = partials;\n        this._setStoppedValue();\n    }\n    /**\n     * The phase of the LFO.\n     */\n    get phase() {\n        return this._oscillator.phase;\n    }\n    set phase(phase) {\n        this._oscillator.phase = phase;\n        this._setStoppedValue();\n    }\n    /**\n     * The output units of the LFO.\n     */\n    get units() {\n        return this._units;\n    }\n    set units(val) {\n        const currentMin = this.min;\n        const currentMax = this.max;\n        // convert the min and the max\n        this._units = val;\n        this.min = currentMin;\n        this.max = currentMax;\n    }\n    /**\n     * Returns the playback state of the source, either \"started\" or \"stopped\".\n     */\n    get state() {\n        return this._oscillator.state;\n    }\n    /**\n     * @param node the destination to connect to\n     * @param outputNum the optional output number\n     * @param inputNum the input number\n     */\n    connect(node, outputNum, inputNum) {\n        if (node instanceof Param || node instanceof Signal) {\n            this.convert = node.convert;\n            this.units = node.units;\n        }\n        connectSignal(this, node, outputNum, inputNum);\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._oscillator.dispose();\n        this._stoppedSignal.dispose();\n        this._zeros.dispose();\n        this._scaler.dispose();\n        this._a2g.dispose();\n        this._amplitudeGain.dispose();\n        this.amplitude.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=LFO.js.map"]},"metadata":{},"sourceType":"module"}