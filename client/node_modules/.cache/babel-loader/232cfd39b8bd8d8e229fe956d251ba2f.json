{"ast":null,"code":"import { Loop } from \"./Loop\";\nimport { PatternGenerator } from \"./PatternGenerator\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns.\n * @example\n * const pattern = new Tone.Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n * @category Event\n */\n\nexport class Pattern extends Loop {\n  constructor() {\n    super(optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]));\n    this.name = \"Pattern\";\n    const options = optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]);\n    this.callback = options.callback;\n    this._values = options.values;\n    this._pattern = PatternGenerator(options.values, options.pattern);\n    this._type = options.pattern;\n  }\n\n  static getDefaults() {\n    return Object.assign(Loop.getDefaults(), {\n      pattern: \"up\",\n      values: [],\n      callback: noOp\n    });\n  }\n  /**\n   * Internal function called when the notes should be called\n   */\n\n\n  _tick(time) {\n    const value = this._pattern.next();\n\n    this._value = value.value;\n    this.callback(time, this._value);\n  }\n  /**\n   * The array of events.\n   */\n\n\n  get values() {\n    return this._values;\n  }\n\n  set values(val) {\n    this._values = val; // reset the pattern\n\n    this.pattern = this._type;\n  }\n  /**\n   * The current value of the pattern.\n   */\n\n\n  get value() {\n    return this._value;\n  }\n  /**\n   * The pattern type. See Tone.CtrlPattern for the full list of patterns.\n   */\n\n\n  get pattern() {\n    return this._type;\n  }\n\n  set pattern(pattern) {\n    this._type = pattern;\n    this._pattern = PatternGenerator(this._values, this._type);\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/event/Pattern.ts"],"names":[],"mappings":"AAAA,SAAS,IAAT,QAAkC,QAAlC;AACA,SAAS,gBAAT,QAA8C,oBAA9C;AAEA,SAAS,oBAAT,QAAqC,uBAArC;AAEA,SAAS,IAAT,QAAqB,wBAArB;AAQA;;;;;;;;AAQG;;AACH,OAAM,MAAO,OAAP,SAAkC,IAAlC,CAAiE;AAwCtE,EAAA,WAAA,GAAA;AAEC,UAAM,oBAAoB,CAAC,OAAO,CAAC,WAAR,EAAD,EAAwB,SAAxB,EAAmC,CAAC,UAAD,EAAa,QAAb,EAAuB,SAAvB,CAAnC,CAA1B;AAxCQ,SAAA,IAAA,GAAe,SAAf;AAyCR,UAAM,OAAO,GAAG,oBAAoB,CAAC,OAAO,CAAC,WAAR,EAAD,EAAwB,SAAxB,EAAmC,CAAC,UAAD,EAAa,QAAb,EAAuB,SAAvB,CAAnC,CAApC;AAEA,SAAK,QAAL,GAAgB,OAAO,CAAC,QAAxB;AACA,SAAK,OAAL,GAAe,OAAO,CAAC,MAAvB;AACA,SAAK,QAAL,GAAgB,gBAAgB,CAAC,OAAO,CAAC,MAAT,EAAiB,OAAO,CAAC,OAAzB,CAAhC;AACA,SAAK,KAAL,GAAa,OAAO,CAAC,OAArB;AACA;;AAEiB,SAAX,WAAW,GAAA;AACjB,WAAO,MAAM,CAAC,MAAP,CAAc,IAAI,CAAC,WAAL,EAAd,EAAkC;AACxC,MAAA,OAAO,EAAE,IAD+B;AAExC,MAAA,MAAM,EAAE,EAFgC;AAGxC,MAAA,QAAQ,EAAE;AAH8B,KAAlC,CAAP;AAKA;AAED;;AAEG;;;AACO,EAAA,KAAK,CAAC,IAAD,EAAc;AAC5B,UAAM,KAAK,GAAG,KAAK,QAAL,CAAc,IAAd,EAAd;;AACA,SAAK,MAAL,GAAc,KAAK,CAAC,KAApB;AACA,SAAK,QAAL,CAAc,IAAd,EAAoB,KAAK,MAAzB;AACA;AAED;;AAEG;;;AACO,MAAN,MAAM,GAAA;AACT,WAAO,KAAK,OAAZ;AACA;;AACS,MAAN,MAAM,CAAC,GAAD,EAAI;AACb,SAAK,OAAL,GAAe,GAAf,CADa,CAEb;;AACA,SAAK,OAAL,GAAe,KAAK,KAApB;AACA;AAED;;AAEG;;;AACM,MAAL,KAAK,GAAA;AACR,WAAO,KAAK,MAAZ;AACA;AAED;;AAEG;;;AACQ,MAAP,OAAO,GAAA;AACV,WAAO,KAAK,KAAZ;AACA;;AACU,MAAP,OAAO,CAAC,OAAD,EAAQ;AAClB,SAAK,KAAL,GAAa,OAAb;AACA,SAAK,QAAL,GAAgB,gBAAgB,CAAC,KAAK,OAAN,EAAe,KAAK,KAApB,CAAhC;AACA;;AAhGqE","sourceRoot":"","sourcesContent":["import { Loop } from \"./Loop\";\nimport { PatternGenerator } from \"./PatternGenerator\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns.\n * @example\n * const pattern = new Tone.Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n * @category Event\n */\nexport class Pattern extends Loop {\n    constructor() {\n        super(optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]));\n        this.name = \"Pattern\";\n        const options = optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]);\n        this.callback = options.callback;\n        this._values = options.values;\n        this._pattern = PatternGenerator(options.values, options.pattern);\n        this._type = options.pattern;\n    }\n    static getDefaults() {\n        return Object.assign(Loop.getDefaults(), {\n            pattern: \"up\",\n            values: [],\n            callback: noOp,\n        });\n    }\n    /**\n     * Internal function called when the notes should be called\n     */\n    _tick(time) {\n        const value = this._pattern.next();\n        this._value = value.value;\n        this.callback(time, this._value);\n    }\n    /**\n     * The array of events.\n     */\n    get values() {\n        return this._values;\n    }\n    set values(val) {\n        this._values = val;\n        // reset the pattern\n        this.pattern = this._type;\n    }\n    /**\n     * The current value of the pattern.\n     */\n    get value() {\n        return this._value;\n    }\n    /**\n     * The pattern type. See Tone.CtrlPattern for the full list of patterns.\n     */\n    get pattern() {\n        return this._type;\n    }\n    set pattern(pattern) {\n        this._type = pattern;\n        this._pattern = PatternGenerator(this._values, this._type);\n    }\n}\n//# sourceMappingURL=Pattern.js.map"]},"metadata":{},"sourceType":"module"}