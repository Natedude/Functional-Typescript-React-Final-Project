{"ast":null,"code":"import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n  // Ceil the length to the next full render quantum.\n  // Bug #17: Safari does not yet expose the length.\n  const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n  const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n  const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n  const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n  if (processorConstructor === undefined) {\n    throw new Error('Missing the processor constructor.');\n  }\n\n  const audioNodeConnections = getAudioNodeConnections(proxy);\n  const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n  const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n  const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n  const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs,\n    [name]: new Float32Array(128)\n  }), {});\n\n  for (let i = 0; i < length; i += 128) {\n    if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n      for (let j = 0; j < options.numberOfInputs; j += 1) {\n        for (let k = 0; k < options.channelCount; k += 1) {\n          copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n        }\n      }\n    }\n\n    if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n      processorConstructor.parameterDescriptors.forEach(({\n        name\n      }, index) => {\n        copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n      });\n    }\n\n    for (let j = 0; j < options.numberOfInputs; j += 1) {\n      for (let k = 0; k < outputChannelCount[j]; k += 1) {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (outputs[j][k].byteLength === 0) {\n          outputs[j][k] = new Float32Array(128);\n        }\n      }\n    }\n\n    try {\n      const potentiallyEmptyInputs = inputs.map((input, index) => {\n        if (audioNodeConnections.activeInputs[index].size === 0) {\n          return [];\n        }\n\n        return input;\n      });\n      const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n\n      if (processedBuffer !== null) {\n        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n          for (let k = 0; k < outputChannelCount[j]; k += 1) {\n            copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n          }\n\n          outputChannelSplitterNodeOutput += outputChannelCount[j];\n        }\n      }\n\n      if (!activeSourceFlag) {\n        break;\n      }\n    } catch (error) {\n      proxy.dispatchEvent(new ErrorEvent('processorerror', {\n        colno: error.colno,\n        filename: error.filename,\n        lineno: error.lineno,\n        message: error.message\n      }));\n      break;\n    }\n  }\n\n  return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (name, options, processorConstructor) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let processedBufferPromise = null;\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n      let nativeOutputNodes = null;\n      const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n      const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount); // Bug #61: Only Chrome, Edge, Firefox & Opera have an implementation of the AudioWorkletNode yet.\n\n      if (nativeAudioWorkletNodeConstructor === null) {\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n          channelCount: Math.max(1, numberOfOutputChannels),\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n\n        for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n          outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: outputChannelCount[i]\n          }));\n        }\n\n        const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n          channelCount: options.channelCount,\n          channelCountMode: options.channelCountMode,\n          channelInterpretation: options.channelInterpretation,\n          gain: 1\n        });\n        outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n      } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n\n      if (nativeOutputNodes !== null) {\n        if (processedBufferPromise === null) {\n          if (processorConstructor === undefined) {\n            throw new Error('Missing the processor constructor.');\n          }\n\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          } // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n\n\n          const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n          const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n          const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n          const renderBuffer = async () => {\n            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, // Ceil the length to the next full render quantum.\n            // Bug #17: Safari does not yet expose the length.\n            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n            const gainNodes = [];\n            const inputChannelSplitterNodes = [];\n\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n              }));\n              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n              }));\n            }\n\n            const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async audioParam => {\n              const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                offset: audioParam.value\n              });\n              await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n              return constantSourceNode;\n            }));\n            const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'speakers',\n              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n            });\n\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n              for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n              }\n            }\n\n            for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n              constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n              constantSourceNode.start(0);\n            }\n\n            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n            await Promise.all(gainNodes.map(gainNode => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n            return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n          };\n\n          processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\n        }\n\n        const processedBuffer = await processedBufferPromise;\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n          buffer: null,\n          channelCount: 2,\n          channelCountMode: 'max',\n          channelInterpretation: 'speakers',\n          loop: false,\n          loopEnd: 0,\n          loopStart: 0,\n          playbackRate: 1\n        });\n        const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n        if (processedBuffer !== null) {\n          audioBufferSourceNode.buffer = processedBuffer;\n          audioBufferSourceNode.start(0);\n        }\n\n        audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n          for (let j = 0; j < outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n\n          outputChannelSplitterNodeOutput += outputChannelCount[i];\n        }\n\n        return outputGainNode;\n      }\n\n      if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await renderAutomation(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm), trace);\n        }\n      } else {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await connectAudioParam(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm), trace);\n        }\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n      return nativeAudioWorkletNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","map":{"version":3,"sources":["../../../src/factories/audio-worklet-node-renderer-factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = numberOfOutputChannels === 0\n        ? null\n        : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', {\n                colno: error.colno,\n                filename: error.filename,\n                lineno: error.lineno,\n                message: error.message\n            }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n            // Bug #61: Only Chrome, Edge, Firefox & Opera have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: outputChannelCount[i]\n                    }));\n                }\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=audio-worklet-node-renderer-factory.js.map"]},"metadata":{},"sourceType":"module"}