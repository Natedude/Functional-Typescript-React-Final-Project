{"ast":null,"code":"import { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n/**\n * Return the absolute value of an incoming signal.\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst abs = new Tone.Abs().toDestination();\n * \tconst signal = new Tone.Signal(1);\n * \tsignal.rampTo(-1, 0.5);\n * \tsignal.connect(abs);\n * }, 0.5, 1);\n * @category Signal\n */\n\nexport class Abs extends SignalOperator {\n  constructor() {\n    super(...arguments);\n    this.name = \"Abs\";\n    /**\n     * The node which converts the audio ranges\n     */\n\n    this._abs = new WaveShaper({\n      context: this.context,\n      mapping: val => {\n        if (Math.abs(val) < 0.001) {\n          return 0;\n        } else {\n          return Math.abs(val);\n        }\n      }\n    });\n    /**\n     * The AudioRange input [-1, 1]\n     */\n\n    this.input = this._abs;\n    /**\n     * The output range [0, 1]\n     */\n\n    this.output = this._abs;\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._abs.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/signal/Abs.ts"],"names":[],"mappings":"AACA,SAAS,cAAT,QAA+B,kBAA/B;AACA,SAAS,UAAT,QAA2B,cAA3B;AAEA;;;;;;;;;;;AAWG;;AACH,OAAM,MAAO,GAAP,SAAmB,cAAnB,CAAuD;AAA7D,EAAA,WAAA,GAAA;;AAEU,SAAA,IAAA,GAAe,KAAf;AAET;;AAEG;;AACK,SAAA,IAAA,GAAO,IAAI,UAAJ,CAAe;AAC7B,MAAA,OAAO,EAAE,KAAK,OADe;AAE7B,MAAA,OAAO,EAAE,GAAG,IAAG;AACd,YAAI,IAAI,CAAC,GAAL,CAAS,GAAT,IAAgB,KAApB,EAA2B;AAC1B,iBAAO,CAAP;AACA,SAFD,MAEO;AACN,iBAAO,IAAI,CAAC,GAAL,CAAS,GAAT,CAAP;AACA;AACD;AAR4B,KAAf,CAAP;AAWR;;AAEG;;AACH,SAAA,KAAA,GAAQ,KAAK,IAAb;AAEA;;AAEG;;AACH,SAAA,MAAA,GAAS,KAAK,IAAd;AAUA;AARA;;AAEG;;;AACH,EAAA,OAAO,GAAA;AACN,UAAM,OAAN;;AACA,SAAK,IAAL,CAAU,OAAV;;AACA,WAAO,IAAP;AACA;;AAnC2D","sourceRoot":"","sourcesContent":["import { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n/**\n * Return the absolute value of an incoming signal.\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst abs = new Tone.Abs().toDestination();\n * \tconst signal = new Tone.Signal(1);\n * \tsignal.rampTo(-1, 0.5);\n * \tsignal.connect(abs);\n * }, 0.5, 1);\n * @category Signal\n */\nexport class Abs extends SignalOperator {\n    constructor() {\n        super(...arguments);\n        this.name = \"Abs\";\n        /**\n         * The node which converts the audio ranges\n         */\n        this._abs = new WaveShaper({\n            context: this.context,\n            mapping: val => {\n                if (Math.abs(val) < 0.001) {\n                    return 0;\n                }\n                else {\n                    return Math.abs(val);\n                }\n            },\n        });\n        /**\n         * The AudioRange input [-1, 1]\n         */\n        this.input = this._abs;\n        /**\n         * The output range [0, 1]\n         */\n        this.output = this._abs;\n    }\n    /**\n     * clean up\n     */\n    dispose() {\n        super.dispose();\n        this._abs.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Abs.js.map"]},"metadata":{},"sourceType":"module"}