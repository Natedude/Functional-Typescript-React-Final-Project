{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { getContext, setContext } from \"../Global\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of [[Context]] which can be used\n * to schedule events along the Transport.\n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * // render 2 seconds of the oscillator\n * Tone.Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Tone.Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Tone.Offline(({ transport }) => {\n * \tconst osc = new Tone.Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\n\nexport function Offline(callback, duration, channels = 2, sampleRate = getContext().sampleRate) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // set the OfflineAudioContext based on the current context\n    const originalContext = getContext();\n    const context = new OfflineContext(channels, duration, sampleRate);\n    setContext(context); // invoke the callback/scheduling\n\n    yield callback(context); // then render the audio\n\n    const bufferPromise = context.render(); // return the original AudioContext\n\n    setContext(originalContext); // await the rendering\n\n    const buffer = yield bufferPromise; // return the audio\n\n    return new ToneAudioBuffer(buffer);\n  });\n}","map":{"version":3,"sources":["../../../../Tone/core/context/Offline.ts"],"names":[],"mappings":";AAAA,SAAS,UAAT,EAAqB,UAArB,QAAuC,WAAvC;AAEA,SAAS,cAAT,QAA+B,kBAA/B;AACA,SAAS,eAAT,QAAgC,mBAAhC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCG;;AACH,OAAM,SAAgB,OAAhB,CACL,QADK,EAEL,QAFK,EAGL,QAAQ,GAAG,CAHN,EAIL,UAAA,GAAqB,UAAU,GAAG,UAJ7B,EAIuC;;AAE5C;AACA,UAAM,eAAe,GAAG,UAAU,EAAlC;AAEA,UAAM,OAAO,GAAG,IAAI,cAAJ,CAAmB,QAAnB,EAA6B,QAA7B,EAAuC,UAAvC,CAAhB;AACA,IAAA,UAAU,CAAC,OAAD,CAAV,C,CAEA;;AACA,UAAM,QAAQ,CAAC,OAAD,CAAd,C,CAEA;;AACA,UAAM,aAAa,GAAG,OAAO,CAAC,MAAR,EAAtB,C,CAEA;;AACA,IAAA,UAAU,CAAC,eAAD,CAAV,C,CAEA;;AACA,UAAM,MAAM,GAAG,MAAM,aAArB,C,CAEA;;AACA,WAAO,IAAI,eAAJ,CAAoB,MAApB,CAAP;AACA,G;AAAA","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { getContext, setContext } from \"../Global\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of [[Context]] which can be used\n * to schedule events along the Transport.\n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * // render 2 seconds of the oscillator\n * Tone.Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Tone.Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Tone.Offline(({ transport }) => {\n * \tconst osc = new Tone.Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\nexport function Offline(callback, duration, channels = 2, sampleRate = getContext().sampleRate) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // set the OfflineAudioContext based on the current context\n        const originalContext = getContext();\n        const context = new OfflineContext(channels, duration, sampleRate);\n        setContext(context);\n        // invoke the callback/scheduling\n        yield callback(context);\n        // then render the audio\n        const bufferPromise = context.render();\n        // return the original AudioContext\n        setContext(originalContext);\n        // await the rendering\n        const buffer = yield bufferPromise;\n        // return the audio\n        return new ToneAudioBuffer(buffer);\n    });\n}\n//# sourceMappingURL=Offline.js.map"]},"metadata":{},"sourceType":"module"}