{"ast":null,"code":"import { MidiClass } from \"../core/type/Midi\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"./Instrument\";\nimport { Synth } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\n\nexport class PolySynth extends Instrument {\n  constructor() {\n    super(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n    this.name = \"PolySynth\";\n    /**\n     * The voices which are not currently in use\n     */\n\n    this._availableVoices = [];\n    /**\n     * The currently active voices\n     */\n\n    this._activeVoices = [];\n    /**\n     * All of the allocated voices for this synth.\n     */\n\n    this._voices = [];\n    /**\n     * The GC timeout. Held so that it could be cancelled when the node is disposed.\n     */\n\n    this._gcTimeout = -1;\n    /**\n     * A moving average of the number of active voices\n     */\n\n    this._averageActiveVoices = 0;\n    const options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]); // check against the old API (pre 14.3.0)\n\n    assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n    const defaults = options.voice.getDefaults();\n    this.options = Object.assign(defaults, options.options);\n    this.voice = options.voice;\n    this.maxPolyphony = options.maxPolyphony; // create the first voice\n\n    this._dummyVoice = this._getNextAvailableVoice(); // remove it from the voices list\n\n    const index = this._voices.indexOf(this._dummyVoice);\n\n    this._voices.splice(index, 1); // kick off the GC interval\n\n\n    this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n  }\n\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      maxPolyphony: 32,\n      options: {},\n      voice: Synth\n    });\n  }\n  /**\n   * The number of active voices.\n   */\n\n\n  get activeVoices() {\n    return this._activeVoices.length;\n  }\n  /**\n   * Invoked when the source is done making sound, so that it can be\n   * readded to the pool of available voices\n   */\n\n\n  _makeVoiceAvailable(voice) {\n    this._availableVoices.push(voice); // remove the midi note from 'active voices'\n\n\n    const activeVoiceIndex = this._activeVoices.findIndex(e => e.voice === voice);\n\n    this._activeVoices.splice(activeVoiceIndex, 1);\n  }\n  /**\n   * Get an available voice from the pool of available voices.\n   * If one is not available and the maxPolyphony limit is reached,\n   * steal a voice, otherwise return null.\n   */\n\n\n  _getNextAvailableVoice() {\n    // if there are available voices, return the first one\n    if (this._availableVoices.length) {\n      return this._availableVoices.shift();\n    } else if (this._voices.length < this.maxPolyphony) {\n      // otherwise if there is still more maxPolyphony, make a new voice\n      const voice = new this.voice(Object.assign(this.options, {\n        context: this.context,\n        onsilence: this._makeVoiceAvailable.bind(this)\n      }));\n      voice.connect(this.output);\n\n      this._voices.push(voice);\n\n      return voice;\n    } else {\n      warn(\"Max polyphony exceeded. Note dropped.\");\n    }\n  }\n  /**\n   * Occasionally check if there are any allocated voices which can be cleaned up.\n   */\n\n\n  _collectGarbage() {\n    this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\n    if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n      // take off an available note\n      const firstAvail = this._availableVoices.shift();\n\n      const index = this._voices.indexOf(firstAvail);\n\n      this._voices.splice(index, 1);\n\n      if (!this.context.isOffline) {\n        firstAvail.dispose();\n      }\n    }\n  }\n  /**\n   * Internal method which triggers the attack\n   */\n\n\n  _triggerAttack(notes, time, velocity) {\n    notes.forEach(note => {\n      const midiNote = new MidiClass(this.context, note).toMidi();\n\n      const voice = this._getNextAvailableVoice();\n\n      if (voice) {\n        voice.triggerAttack(note, time, velocity);\n\n        this._activeVoices.push({\n          midi: midiNote,\n          voice,\n          released: false\n        });\n\n        this.log(\"triggerAttack\", note, time);\n      }\n    });\n  }\n  /**\n   * Internal method which triggers the release\n   */\n\n\n  _triggerRelease(notes, time) {\n    notes.forEach(note => {\n      const midiNote = new MidiClass(this.context, note).toMidi();\n\n      const event = this._activeVoices.find(({\n        midi,\n        released\n      }) => midi === midiNote && !released);\n\n      if (event) {\n        // trigger release on that note\n        event.voice.triggerRelease(time); // mark it as released\n\n        event.released = true;\n        this.log(\"triggerRelease\", note, time);\n      }\n    });\n  }\n  /**\n   * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n   * to wait for just-in-time scheduling\n   */\n\n\n  _scheduleEvent(type, notes, time, velocity) {\n    assert(!this.disposed, \"Synth was already disposed\"); // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\n    if (time <= this.now()) {\n      // do it immediately\n      if (type === \"attack\") {\n        this._triggerAttack(notes, time, velocity);\n      } else {\n        this._triggerRelease(notes, time);\n      }\n    } else {\n      // schedule it to start in the future\n      this.context.setTimeout(() => {\n        this._scheduleEvent(type, notes, time, velocity);\n      }, time - this.now());\n    }\n  }\n  /**\n   * Trigger the attack portion of the note\n   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n   * @param  time  The start time of the note.\n   * @param velocity The velocity of the note.\n   * @example\n   * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n   * // trigger a chord immediately with a velocity of 0.2\n   * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n   */\n\n\n  triggerAttack(notes, time, velocity) {\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    const computedTime = this.toSeconds(time);\n\n    this._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\n    return this;\n  }\n  /**\n   * Trigger the release of the note. Unlike monophonic instruments,\n   * a note (or array of notes) needs to be passed in as the first argument.\n   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n   * @param  time  When the release will be triggered.\n   * @example\n   * @example\n   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n   * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n   * // trigger the release of the given notes.\n   * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n   * poly.triggerRelease(\"F5\", \"+3\");\n   */\n\n\n  triggerRelease(notes, time) {\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    const computedTime = this.toSeconds(time);\n\n    this._scheduleEvent(\"release\", notes, computedTime);\n\n    return this;\n  }\n  /**\n   * Trigger the attack and release after the specified duration\n   * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n   * @param  duration the duration of the note\n   * @param  time  if no time is given, defaults to now\n   * @param  velocity the velocity of the attack (0-1)\n   * @example\n   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n   * // can pass in an array of durations as well\n   * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n   */\n\n\n  triggerAttackRelease(notes, duration, time, velocity) {\n    const computedTime = this.toSeconds(time);\n    this.triggerAttack(notes, computedTime, velocity);\n\n    if (isArray(duration)) {\n      assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n      notes = notes;\n\n      for (let i = 0; i < notes.length; i++) {\n        const d = duration[Math.min(i, duration.length - 1)];\n        const durationSeconds = this.toSeconds(d);\n        assert(durationSeconds > 0, \"The duration must be greater than 0\");\n        this.triggerRelease(notes[i], computedTime + durationSeconds);\n      }\n    } else {\n      const durationSeconds = this.toSeconds(duration);\n      assert(durationSeconds > 0, \"The duration must be greater than 0\");\n      this.triggerRelease(notes, computedTime + durationSeconds);\n    }\n\n    return this;\n  }\n\n  sync() {\n    if (this._syncState()) {\n      this._syncMethod(\"triggerAttack\", 1);\n\n      this._syncMethod(\"triggerRelease\", 1);\n    }\n\n    return this;\n  }\n  /**\n   * Set a member/attribute of the voices\n   * @example\n   * const poly = new Tone.PolySynth().toDestination();\n   * // set all of the voices using an options object for the synth type\n   * poly.set({\n   * \tenvelope: {\n   * \t\tattack: 0.25\n   * \t}\n   * });\n   * poly.triggerAttackRelease(\"Bb3\", 0.2);\n   */\n\n\n  set(options) {\n    // remove options which are controlled by the PolySynth\n    const sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]); // store all of the options\n\n    this.options = deepMerge(this.options, sanitizedOptions);\n\n    this._voices.forEach(voice => voice.set(sanitizedOptions));\n\n    this._dummyVoice.set(sanitizedOptions);\n\n    return this;\n  }\n\n  get() {\n    return this._dummyVoice.get();\n  }\n  /**\n   * Trigger the release portion of all the currently active voices immediately.\n   * Useful for silencing the synth.\n   */\n\n\n  releaseAll(time) {\n    const computedTime = this.toSeconds(time);\n\n    this._activeVoices.forEach(({\n      voice\n    }) => {\n      voice.triggerRelease(computedTime);\n    });\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._dummyVoice.dispose();\n\n    this._voices.forEach(v => v.dispose());\n\n    this._activeVoices = [];\n    this._availableVoices = [];\n    this.context.clearInterval(this._gcTimeout);\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/instrument/PolySynth.ts"],"names":[],"mappings":"AAAA,SAAS,SAAT,QAA0B,mBAA1B;AAEA,SAAS,SAAT,EAAoB,cAApB,EAAoC,oBAApC,QAAgE,uBAAhE;AAEA,SAAS,OAAT,EAAkB,QAAlB,QAAkC,wBAAlC;AACA,SAAS,UAAT,QAA8C,cAA9C;AAOA,SAAS,KAAT,QAAoC,SAApC;AACA,SAAS,MAAT,EAAiB,IAAjB,QAA6B,oBAA7B;AA4BA;;;;;;;;;;;;;;AAcG;;AACH,OAAM,MAAO,SAAP,SAAgE,UAAhE,CAA+F;AA0DpG,EAAA,WAAA,GAAA;AAEC,UAAM,oBAAoB,CAAC,SAAS,CAAC,WAAV,EAAD,EAA0B,SAA1B,EAAqC,CAAC,OAAD,EAAU,SAAV,CAArC,CAA1B;AA1DQ,SAAA,IAAA,GAAe,WAAf;AAET;;AAEG;;AACK,SAAA,gBAAA,GAA4B,EAA5B;AAER;;AAEG;;AACK,SAAA,aAAA,GAA4E,EAA5E;AAER;;AAEG;;AACK,SAAA,OAAA,GAAmB,EAAnB;AAsBR;;AAEG;;AACK,SAAA,UAAA,GAAa,CAAC,CAAd;AAER;;AAEG;;AACK,SAAA,oBAAA,GAAuB,CAAvB;AAcP,UAAM,OAAO,GAAG,oBAAoB,CAAC,SAAS,CAAC,WAAV,EAAD,EAA0B,SAA1B,EAAqC,CAAC,OAAD,EAAU,SAAV,CAArC,CAApC,CAHD,CAKC;;AACA,IAAA,MAAM,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAT,CAAV,EAA2B,kEAA3B,CAAN;AAEA,UAAM,QAAQ,GAAG,OAAO,CAAC,KAAR,CAAc,WAAd,EAAjB;AACA,SAAK,OAAL,GAAe,MAAM,CAAC,MAAP,CAAc,QAAd,EAAwB,OAAO,CAAC,OAAhC,CAAf;AACA,SAAK,KAAL,GAAa,OAAO,CAAC,KAArB;AACA,SAAK,YAAL,GAAoB,OAAO,CAAC,YAA5B,CAXD,CAaC;;AACA,SAAK,WAAL,GAAmB,KAAK,sBAAL,EAAnB,CAdD,CAeC;;AACA,UAAM,KAAK,GAAG,KAAK,OAAL,CAAa,OAAb,CAAqB,KAAK,WAA1B,CAAd;;AACA,SAAK,OAAL,CAAa,MAAb,CAAoB,KAApB,EAA2B,CAA3B,EAjBD,CAkBC;;;AACA,SAAK,UAAL,GAAkB,KAAK,OAAL,CAAa,WAAb,CAAyB,KAAK,eAAL,CAAqB,IAArB,CAA0B,IAA1B,CAAzB,EAA0D,CAA1D,CAAlB;AACA;;AAEiB,SAAX,WAAW,GAAA;AACjB,WAAO,MAAM,CAAC,MAAP,CAAc,UAAU,CAAC,WAAX,EAAd,EAAwC;AAC9C,MAAA,YAAY,EAAE,EADgC;AAE9C,MAAA,OAAO,EAAE,EAFqC;AAG9C,MAAA,KAAK,EAAE;AAHuC,KAAxC,CAAP;AAKA;AAED;;AAEG;;;AACa,MAAZ,YAAY,GAAA;AACf,WAAO,KAAK,aAAL,CAAmB,MAA1B;AACA;AAED;;;AAGG;;;AACK,EAAA,mBAAmB,CAAC,KAAD,EAAa;AACvC,SAAK,gBAAL,CAAsB,IAAtB,CAA2B,KAA3B,EADuC,CAEvC;;;AACA,UAAM,gBAAgB,GAAG,KAAK,aAAL,CAAmB,SAAnB,CAA8B,CAAD,IAAO,CAAC,CAAC,KAAF,KAAY,KAAhD,CAAzB;;AACA,SAAK,aAAL,CAAmB,MAAnB,CAA0B,gBAA1B,EAA4C,CAA5C;AACA;AAED;;;;AAIG;;;AACK,EAAA,sBAAsB,GAAA;AAC7B;AACA,QAAI,KAAK,gBAAL,CAAsB,MAA1B,EAAkC;AACjC,aAAO,KAAK,gBAAL,CAAsB,KAAtB,EAAP;AACA,KAFD,MAEO,IAAI,KAAK,OAAL,CAAa,MAAb,GAAsB,KAAK,YAA/B,EAA6C;AACnD;AACA,YAAM,KAAK,GAAG,IAAI,KAAK,KAAT,CAAe,MAAM,CAAC,MAAP,CAAc,KAAK,OAAnB,EAA4B;AACxD,QAAA,OAAO,EAAE,KAAK,OAD0C;AAExD,QAAA,SAAS,EAAE,KAAK,mBAAL,CAAyB,IAAzB,CAA8B,IAA9B;AAF6C,OAA5B,CAAf,CAAd;AAIA,MAAA,KAAK,CAAC,OAAN,CAAc,KAAK,MAAnB;;AACA,WAAK,OAAL,CAAa,IAAb,CAAkB,KAAlB;;AACA,aAAO,KAAP;AACA,KATM,MASA;AACN,MAAA,IAAI,CAAC,uCAAD,CAAJ;AACA;AACD;AAED;;AAEG;;;AACK,EAAA,eAAe,GAAA;AACtB,SAAK,oBAAL,GAA4B,IAAI,CAAC,GAAL,CAAS,KAAK,oBAAL,GAA4B,IAArC,EAA2C,KAAK,YAAhD,CAA5B;;AACA,QAAI,KAAK,gBAAL,CAAsB,MAAtB,IAAgC,KAAK,OAAL,CAAa,MAAb,GAAsB,IAAI,CAAC,IAAL,CAAU,KAAK,oBAAL,GAA4B,CAAtC,CAA1D,EAAoG;AACnG;AACA,YAAM,UAAU,GAAG,KAAK,gBAAL,CAAsB,KAAtB,EAAnB;;AACA,YAAM,KAAK,GAAG,KAAK,OAAL,CAAa,OAAb,CAAqB,UAArB,CAAd;;AACA,WAAK,OAAL,CAAa,MAAb,CAAoB,KAApB,EAA2B,CAA3B;;AACA,UAAI,CAAC,KAAK,OAAL,CAAa,SAAlB,EAA6B;AAC5B,QAAA,UAAU,CAAC,OAAX;AACA;AACD;AACD;AAED;;AAEG;;;AACK,EAAA,cAAc,CAAC,KAAD,EAAqB,IAArB,EAAoC,QAApC,EAA0D;AAC/E,IAAA,KAAK,CAAC,OAAN,CAAc,IAAI,IAAG;AACpB,YAAM,QAAQ,GAAG,IAAI,SAAJ,CAAc,KAAK,OAAnB,EAA4B,IAA5B,EAAkC,MAAlC,EAAjB;;AACA,YAAM,KAAK,GAAG,KAAK,sBAAL,EAAd;;AACA,UAAI,KAAJ,EAAW;AACV,QAAA,KAAK,CAAC,aAAN,CAAoB,IAApB,EAA0B,IAA1B,EAAgC,QAAhC;;AACA,aAAK,aAAL,CAAmB,IAAnB,CAAwB;AACvB,UAAA,IAAI,EAAE,QADiB;AACP,UAAA,KADO;AACA,UAAA,QAAQ,EAAE;AADV,SAAxB;;AAGA,aAAK,GAAL,CAAS,eAAT,EAA0B,IAA1B,EAAgC,IAAhC;AACA;AACD,KAVD;AAWA;AAED;;AAEG;;;AACK,EAAA,eAAe,CAAC,KAAD,EAAqB,IAArB,EAAkC;AACxD,IAAA,KAAK,CAAC,OAAN,CAAc,IAAI,IAAG;AACpB,YAAM,QAAQ,GAAG,IAAI,SAAJ,CAAc,KAAK,OAAnB,EAA4B,IAA5B,EAAkC,MAAlC,EAAjB;;AACA,YAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,IAAnB,CAAwB,CAAC;AAAE,QAAA,IAAF;AAAQ,QAAA;AAAR,OAAD,KAAwB,IAAI,KAAK,QAAT,IAAqB,CAAC,QAAtE,CAAd;;AACA,UAAI,KAAJ,EAAW;AACV;AACA,QAAA,KAAK,CAAC,KAAN,CAAY,cAAZ,CAA2B,IAA3B,EAFU,CAGV;;AACA,QAAA,KAAK,CAAC,QAAN,GAAiB,IAAjB;AACA,aAAK,GAAL,CAAS,gBAAT,EAA2B,IAA3B,EAAiC,IAAjC;AACA;AACD,KAVD;AAWA;AAED;;;AAGG;;;AACK,EAAA,cAAc,CAAC,IAAD,EAA6B,KAA7B,EAAiD,IAAjD,EAAgE,QAAhE,EAAsF;AAC3G,IAAA,MAAM,CAAC,CAAC,KAAK,QAAP,EAAiB,4BAAjB,CAAN,CAD2G,CAE3G;;AACA,QAAI,IAAI,IAAI,KAAK,GAAL,EAAZ,EAAwB;AACvB;AACA,UAAI,IAAI,KAAK,QAAb,EAAuB;AACtB,aAAK,cAAL,CAAoB,KAApB,EAA2B,IAA3B,EAAiC,QAAjC;AACA,OAFD,MAEO;AACN,aAAK,eAAL,CAAqB,KAArB,EAA4B,IAA5B;AACA;AACD,KAPD,MAOO;AACN;AACA,WAAK,OAAL,CAAa,UAAb,CAAwB,MAAK;AAC5B,aAAK,cAAL,CAAoB,IAApB,EAA0B,KAA1B,EAAiC,IAAjC,EAAuC,QAAvC;AACA,OAFD,EAEG,IAAI,GAAG,KAAK,GAAL,EAFV;AAGA;AACD;AAED;;;;;;;;;AASG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAiC,IAAjC,EAA8C,QAA9C,EAAoE;AAEhF,QAAI,CAAC,KAAK,CAAC,OAAN,CAAc,KAAd,CAAL,EAA2B;AAC1B,MAAA,KAAK,GAAG,CAAC,KAAD,CAAR;AACA;;AACD,UAAM,YAAY,GAAG,KAAK,SAAL,CAAe,IAAf,CAArB;;AACA,SAAK,cAAL,CAAoB,QAApB,EAA8B,KAA9B,EAAqC,YAArC,EAAmD,QAAnD;;AACA,WAAO,IAAP;AACA;AAED;;;;;;;;;;;;AAYG;;;AACH,EAAA,cAAc,CAAC,KAAD,EAAiC,IAAjC,EAA4C;AACzD,QAAI,CAAC,KAAK,CAAC,OAAN,CAAc,KAAd,CAAL,EAA2B;AAC1B,MAAA,KAAK,GAAG,CAAC,KAAD,CAAR;AACA;;AACD,UAAM,YAAY,GAAG,KAAK,SAAL,CAAe,IAAf,CAArB;;AACA,SAAK,cAAL,CAAoB,SAApB,EAA+B,KAA/B,EAAsC,YAAtC;;AACA,WAAO,IAAP;AACA;AAED;;;;;;;;;;AAUG;;;AACH,EAAA,oBAAoB,CACnB,KADmB,EAEnB,QAFmB,EAGnB,IAHmB,EAInB,QAJmB,EAIG;AAEtB,UAAM,YAAY,GAAG,KAAK,SAAL,CAAe,IAAf,CAArB;AACA,SAAK,aAAL,CAAmB,KAAnB,EAA0B,YAA1B,EAAwC,QAAxC;;AACA,QAAI,OAAO,CAAC,QAAD,CAAX,EAAuB;AACtB,MAAA,MAAM,CAAC,OAAO,CAAC,KAAD,CAAR,EAAiB,8DAAjB,CAAN;AACA,MAAA,KAAK,GAAG,KAAR;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACtC,cAAM,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,QAAQ,CAAC,MAAT,GAAkB,CAA9B,CAAD,CAAlB;AACA,cAAM,eAAe,GAAG,KAAK,SAAL,CAAe,CAAf,CAAxB;AACA,QAAA,MAAM,CAAC,eAAe,GAAG,CAAnB,EAAsB,qCAAtB,CAAN;AACA,aAAK,cAAL,CAAoB,KAAK,CAAC,CAAD,CAAzB,EAA8B,YAAY,GAAG,eAA7C;AACA;AACD,KATD,MASO;AACN,YAAM,eAAe,GAAG,KAAK,SAAL,CAAe,QAAf,CAAxB;AACA,MAAA,MAAM,CAAC,eAAe,GAAG,CAAnB,EAAsB,qCAAtB,CAAN;AACA,WAAK,cAAL,CAAoB,KAApB,EAA2B,YAAY,GAAG,eAA1C;AACA;;AACD,WAAO,IAAP;AACA;;AAED,EAAA,IAAI,GAAA;AACH,QAAI,KAAK,UAAL,EAAJ,EAAuB;AACtB,WAAK,WAAL,CAAiB,eAAjB,EAAkC,CAAlC;;AACA,WAAK,WAAL,CAAiB,gBAAjB,EAAmC,CAAnC;AACA;;AACD,WAAO,IAAP;AACA;AAED;;;;;;;;;;;AAWG;;;AACH,EAAA,GAAG,CAAC,OAAD,EAA+C;AACjD;AACA,UAAM,gBAAgB,GAAG,cAAc,CAAC,OAAD,EAAU,CAAC,WAAD,EAAc,SAAd,CAAV,CAAvC,CAFiD,CAGjD;;AACA,SAAK,OAAL,GAAe,SAAS,CAAC,KAAK,OAAN,EAAe,gBAAf,CAAxB;;AACA,SAAK,OAAL,CAAa,OAAb,CAAqB,KAAK,IAAI,KAAK,CAAC,GAAN,CAAU,gBAAV,CAA9B;;AACA,SAAK,WAAL,CAAiB,GAAjB,CAAqB,gBAArB;;AACA,WAAO,IAAP;AACA;;AAED,EAAA,GAAG,GAAA;AACF,WAAO,KAAK,WAAL,CAAiB,GAAjB,EAAP;AACA;AAED;;;AAGG;;;AACH,EAAA,UAAU,CAAC,IAAD,EAAY;AACrB,UAAM,YAAY,GAAG,KAAK,SAAL,CAAe,IAAf,CAArB;;AACA,SAAK,aAAL,CAAmB,OAAnB,CAA2B,CAAC;AAAE,MAAA;AAAF,KAAD,KAAc;AACxC,MAAA,KAAK,CAAC,cAAN,CAAqB,YAArB;AACA,KAFD;;AAGA,WAAO,IAAP;AACA;;AAED,EAAA,OAAO,GAAA;AACN,UAAM,OAAN;;AACA,SAAK,WAAL,CAAiB,OAAjB;;AACA,SAAK,OAAL,CAAa,OAAb,CAAqB,CAAC,IAAI,CAAC,CAAC,OAAF,EAA1B;;AACA,SAAK,aAAL,GAAqB,EAArB;AACA,SAAK,gBAAL,GAAwB,EAAxB;AACA,SAAK,OAAL,CAAa,aAAb,CAA2B,KAAK,UAAhC;AACA,WAAO,IAAP;AACA;;AA7UmG","sourceRoot":"","sourcesContent":["import { MidiClass } from \"../core/type/Midi\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"./Instrument\";\nimport { Synth } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport class PolySynth extends Instrument {\n    constructor() {\n        super(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n        this.name = \"PolySynth\";\n        /**\n         * The voices which are not currently in use\n         */\n        this._availableVoices = [];\n        /**\n         * The currently active voices\n         */\n        this._activeVoices = [];\n        /**\n         * All of the allocated voices for this synth.\n         */\n        this._voices = [];\n        /**\n         * The GC timeout. Held so that it could be cancelled when the node is disposed.\n         */\n        this._gcTimeout = -1;\n        /**\n         * A moving average of the number of active voices\n         */\n        this._averageActiveVoices = 0;\n        const options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n        // check against the old API (pre 14.3.0)\n        assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n        const defaults = options.voice.getDefaults();\n        this.options = Object.assign(defaults, options.options);\n        this.voice = options.voice;\n        this.maxPolyphony = options.maxPolyphony;\n        // create the first voice\n        this._dummyVoice = this._getNextAvailableVoice();\n        // remove it from the voices list\n        const index = this._voices.indexOf(this._dummyVoice);\n        this._voices.splice(index, 1);\n        // kick off the GC interval\n        this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n    }\n    static getDefaults() {\n        return Object.assign(Instrument.getDefaults(), {\n            maxPolyphony: 32,\n            options: {},\n            voice: Synth,\n        });\n    }\n    /**\n     * The number of active voices.\n     */\n    get activeVoices() {\n        return this._activeVoices.length;\n    }\n    /**\n     * Invoked when the source is done making sound, so that it can be\n     * readded to the pool of available voices\n     */\n    _makeVoiceAvailable(voice) {\n        this._availableVoices.push(voice);\n        // remove the midi note from 'active voices'\n        const activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n        this._activeVoices.splice(activeVoiceIndex, 1);\n    }\n    /**\n     * Get an available voice from the pool of available voices.\n     * If one is not available and the maxPolyphony limit is reached,\n     * steal a voice, otherwise return null.\n     */\n    _getNextAvailableVoice() {\n        // if there are available voices, return the first one\n        if (this._availableVoices.length) {\n            return this._availableVoices.shift();\n        }\n        else if (this._voices.length < this.maxPolyphony) {\n            // otherwise if there is still more maxPolyphony, make a new voice\n            const voice = new this.voice(Object.assign(this.options, {\n                context: this.context,\n                onsilence: this._makeVoiceAvailable.bind(this),\n            }));\n            voice.connect(this.output);\n            this._voices.push(voice);\n            return voice;\n        }\n        else {\n            warn(\"Max polyphony exceeded. Note dropped.\");\n        }\n    }\n    /**\n     * Occasionally check if there are any allocated voices which can be cleaned up.\n     */\n    _collectGarbage() {\n        this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n        if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n            // take off an available note\n            const firstAvail = this._availableVoices.shift();\n            const index = this._voices.indexOf(firstAvail);\n            this._voices.splice(index, 1);\n            if (!this.context.isOffline) {\n                firstAvail.dispose();\n            }\n        }\n    }\n    /**\n     * Internal method which triggers the attack\n     */\n    _triggerAttack(notes, time, velocity) {\n        notes.forEach(note => {\n            const midiNote = new MidiClass(this.context, note).toMidi();\n            const voice = this._getNextAvailableVoice();\n            if (voice) {\n                voice.triggerAttack(note, time, velocity);\n                this._activeVoices.push({\n                    midi: midiNote, voice, released: false,\n                });\n                this.log(\"triggerAttack\", note, time);\n            }\n        });\n    }\n    /**\n     * Internal method which triggers the release\n     */\n    _triggerRelease(notes, time) {\n        notes.forEach(note => {\n            const midiNote = new MidiClass(this.context, note).toMidi();\n            const event = this._activeVoices.find(({ midi, released }) => midi === midiNote && !released);\n            if (event) {\n                // trigger release on that note\n                event.voice.triggerRelease(time);\n                // mark it as released\n                event.released = true;\n                this.log(\"triggerRelease\", note, time);\n            }\n        });\n    }\n    /**\n     * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n     * to wait for just-in-time scheduling\n     */\n    _scheduleEvent(type, notes, time, velocity) {\n        assert(!this.disposed, \"Synth was already disposed\");\n        // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n        if (time <= this.now()) {\n            // do it immediately\n            if (type === \"attack\") {\n                this._triggerAttack(notes, time, velocity);\n            }\n            else {\n                this._triggerRelease(notes, time);\n            }\n        }\n        else {\n            // schedule it to start in the future\n            this.context.setTimeout(() => {\n                this._scheduleEvent(type, notes, time, velocity);\n            }, time - this.now());\n        }\n    }\n    /**\n     * Trigger the attack portion of the note\n     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n     * @param  time  The start time of the note.\n     * @param velocity The velocity of the note.\n     * @example\n     * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n     * // trigger a chord immediately with a velocity of 0.2\n     * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n     */\n    triggerAttack(notes, time, velocity) {\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        const computedTime = this.toSeconds(time);\n        this._scheduleEvent(\"attack\", notes, computedTime, velocity);\n        return this;\n    }\n    /**\n     * Trigger the release of the note. Unlike monophonic instruments,\n     * a note (or array of notes) needs to be passed in as the first argument.\n     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n     * @param  time  When the release will be triggered.\n     * @example\n     * @example\n     * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n     * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n     * // trigger the release of the given notes.\n     * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n     * poly.triggerRelease(\"F5\", \"+3\");\n     */\n    triggerRelease(notes, time) {\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        const computedTime = this.toSeconds(time);\n        this._scheduleEvent(\"release\", notes, computedTime);\n        return this;\n    }\n    /**\n     * Trigger the attack and release after the specified duration\n     * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n     * @param  duration the duration of the note\n     * @param  time  if no time is given, defaults to now\n     * @param  velocity the velocity of the attack (0-1)\n     * @example\n     * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n     * // can pass in an array of durations as well\n     * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n     */\n    triggerAttackRelease(notes, duration, time, velocity) {\n        const computedTime = this.toSeconds(time);\n        this.triggerAttack(notes, computedTime, velocity);\n        if (isArray(duration)) {\n            assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n            notes = notes;\n            for (let i = 0; i < notes.length; i++) {\n                const d = duration[Math.min(i, duration.length - 1)];\n                const durationSeconds = this.toSeconds(d);\n                assert(durationSeconds > 0, \"The duration must be greater than 0\");\n                this.triggerRelease(notes[i], computedTime + durationSeconds);\n            }\n        }\n        else {\n            const durationSeconds = this.toSeconds(duration);\n            assert(durationSeconds > 0, \"The duration must be greater than 0\");\n            this.triggerRelease(notes, computedTime + durationSeconds);\n        }\n        return this;\n    }\n    sync() {\n        if (this._syncState()) {\n            this._syncMethod(\"triggerAttack\", 1);\n            this._syncMethod(\"triggerRelease\", 1);\n        }\n        return this;\n    }\n    /**\n     * Set a member/attribute of the voices\n     * @example\n     * const poly = new Tone.PolySynth().toDestination();\n     * // set all of the voices using an options object for the synth type\n     * poly.set({\n     * \tenvelope: {\n     * \t\tattack: 0.25\n     * \t}\n     * });\n     * poly.triggerAttackRelease(\"Bb3\", 0.2);\n     */\n    set(options) {\n        // remove options which are controlled by the PolySynth\n        const sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]);\n        // store all of the options\n        this.options = deepMerge(this.options, sanitizedOptions);\n        this._voices.forEach(voice => voice.set(sanitizedOptions));\n        this._dummyVoice.set(sanitizedOptions);\n        return this;\n    }\n    get() {\n        return this._dummyVoice.get();\n    }\n    /**\n     * Trigger the release portion of all the currently active voices immediately.\n     * Useful for silencing the synth.\n     */\n    releaseAll(time) {\n        const computedTime = this.toSeconds(time);\n        this._activeVoices.forEach(({ voice }) => {\n            voice.triggerRelease(computedTime);\n        });\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._dummyVoice.dispose();\n        this._voices.forEach(v => v.dispose());\n        this._activeVoices = [];\n        this._availableVoices = [];\n        this.context.clearInterval(this._gcTimeout);\n        return this;\n    }\n}\n//# sourceMappingURL=PolySynth.js.map"]},"metadata":{},"sourceType":"module"}