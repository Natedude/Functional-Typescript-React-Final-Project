{"ast":null,"code":"import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors) => {\n  return (nativeContext, options) => {\n    const nativeWaveShaperNode = nativeContext.createWaveShaper();\n    /*\n     * Bug #119: Safari does not correctly map the values.\n     * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n     * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n     * isn't necessary anymore since v14.0.2 of Safari.\n     */\n\n    if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext' && nativeContext.createGain().gain.automationRate === undefined) {\n      return createNativeWaveShaperNodeFaker(nativeContext, options);\n    }\n\n    assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n    const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve); // Bug #104: Chrome, Edge and Opera will throw an InvalidAccessError when the curve has less than two samples.\n\n    if (curve !== null && curve.length < 2) {\n      throw createInvalidStateError();\n    } // Only values of type Float32Array can be assigned to the curve property.\n\n\n    assignNativeAudioNodeOption(nativeWaveShaperNode, {\n      curve\n    }, 'curve');\n    assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n    let disconnectNativeAudioBufferSourceNode = null;\n    let isConnected = false;\n    overwriteAccessors(nativeWaveShaperNode, 'curve', get => () => get.call(nativeWaveShaperNode), set => value => {\n      set.call(nativeWaveShaperNode, value);\n\n      if (isConnected) {\n        if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n        } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n          disconnectNativeAudioBufferSourceNode();\n          disconnectNativeAudioBufferSourceNode = null;\n        }\n      }\n\n      return value;\n    });\n\n    const whenConnected = () => {\n      isConnected = true;\n\n      if (isDCCurve(nativeWaveShaperNode.curve)) {\n        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n      }\n    };\n\n    const whenDisconnected = () => {\n      isConnected = false;\n\n      if (disconnectNativeAudioBufferSourceNode !== null) {\n        disconnectNativeAudioBufferSourceNode();\n        disconnectNativeAudioBufferSourceNode = null;\n      }\n    };\n\n    return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"sources":["../../../src/factories/native-wave-shaper-node-factory.ts"],"names":[],"mappings":"AAAA,SAAS,2BAAT,QAA4C,4CAA5C;AACA,SAAS,4BAAT,QAA6C,6CAA7C;AAGA,OAAO,MAAM,iCAAiC,GAAwC,CAClF,0CADkF,EAElF,uBAFkF,EAGlF,+BAHkF,EAIlF,SAJkF,EAKlF,kBALkF,EAMlF,6BANkF,EAOlF,kBAPkF,KAQlF;AACA,SAAO,CAAC,aAAD,EAAgB,OAAhB,KAA2B;AAC9B,UAAM,oBAAoB,GAAG,aAAa,CAAC,gBAAd,EAA7B;AAEA;;;;;AAKG;;AACH,QACI,6BAA6B,KAAK,IAAlC,IACA,6BAA6B,CAAC,IAA9B,KAAuC,oBADvC,IAEA,aAAa,CAAC,UAAd,GAA2B,IAA3B,CAAgC,cAAhC,KAAmD,SAHvD,EAIE;AACE,aAAO,+BAA+B,CAAC,aAAD,EAAgB,OAAhB,CAAtC;AACH;;AAED,IAAA,4BAA4B,CAAC,oBAAD,EAAuB,OAAvB,CAA5B;AAEA,UAAM,KAAK,GAAG,OAAO,CAAC,KAAR,KAAkB,IAAlB,IAA0B,OAAO,CAAC,KAAR,YAAyB,YAAnD,GAAkE,OAAO,CAAC,KAA1E,GAAkF,IAAI,YAAJ,CAAiB,OAAO,CAAC,KAAzB,CAAhG,CAnB8B,CAqB9B;;AACA,QAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,CAAC,MAAN,GAAe,CAArC,EAAwC;AACpC,YAAM,uBAAuB,EAA7B;AACH,KAxB6B,CA0B9B;;;AACA,IAAA,2BAA2B,CAAC,oBAAD,EAAuB;AAAE,MAAA;AAAF,KAAvB,EAAkC,OAAlC,CAA3B;AACA,IAAA,2BAA2B,CAAC,oBAAD,EAAuB,OAAvB,EAAgC,YAAhC,CAA3B;AAEA,QAAI,qCAAqC,GAAwB,IAAjE;AACA,QAAI,WAAW,GAAG,KAAlB;AAEA,IAAA,kBAAkB,CACd,oBADc,EAEd,OAFc,EAGb,GAAD,IAAS,MAAM,GAAG,CAAC,IAAJ,CAAS,oBAAT,CAHD,EAIb,GAAD,IAAU,KAAD,IAAU;AACf,MAAA,GAAG,CAAC,IAAJ,CAAS,oBAAT,EAA+B,KAA/B;;AAEA,UAAI,WAAJ,EAAiB;AACb,YAAI,SAAS,CAAC,KAAD,CAAT,IAAoB,qCAAqC,KAAK,IAAlE,EAAwE;AACpE,UAAA,qCAAqC,GAAG,0CAA0C,CAC9E,aAD8E,EAE9E,oBAF8E,CAAlF;AAIH,SALD,MAKO,IAAI,CAAC,SAAS,CAAC,KAAD,CAAV,IAAqB,qCAAqC,KAAK,IAAnE,EAAyE;AAC5E,UAAA,qCAAqC;AACrC,UAAA,qCAAqC,GAAG,IAAxC;AACH;AACJ;;AAED,aAAO,KAAP;AACH,KApBa,CAAlB;;AAuBA,UAAM,aAAa,GAAG,MAAK;AACvB,MAAA,WAAW,GAAG,IAAd;;AAEA,UAAI,SAAS,CAAC,oBAAoB,CAAC,KAAtB,CAAb,EAA2C;AACvC,QAAA,qCAAqC,GAAG,0CAA0C,CAAC,aAAD,EAAgB,oBAAhB,CAAlF;AACH;AACJ,KAND;;AAOA,UAAM,gBAAgB,GAAG,MAAK;AAC1B,MAAA,WAAW,GAAG,KAAd;;AAEA,UAAI,qCAAqC,KAAK,IAA9C,EAAoD;AAChD,QAAA,qCAAqC;AACrC,QAAA,qCAAqC,GAAG,IAAxC;AACH;AACJ,KAPD;;AASA,WAAO,kBAAkB,CAAC,oBAAD,EAAuB,aAAvB,EAAsC,gBAAtC,CAAzB;AACH,GAzED;AA0EH,CAnFM","sourceRoot":"","sourcesContent":["import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = nativeContext.createWaveShaper();\n        /*\n         * Bug #119: Safari does not correctly map the values.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n         * isn't necessary anymore since v14.0.2 of Safari.\n         */\n        if (nativeAudioContextConstructor !== null &&\n            nativeAudioContextConstructor.name === 'webkitAudioContext' &&\n            nativeContext.createGain().gain.automationRate === undefined) {\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n        const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n        // Bug #104: Chrome, Edge and Opera will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n        // Only values of type Float32Array can be assigned to the curve property.\n        assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        overwriteAccessors(nativeWaveShaperNode, 'curve', (get) => () => get.call(nativeWaveShaperNode), (set) => (value) => {\n            set.call(nativeWaveShaperNode, value);\n            if (isConnected) {\n                if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                    disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n                }\n                else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                    disconnectNativeAudioBufferSourceNode();\n                    disconnectNativeAudioBufferSourceNode = null;\n                }\n            }\n            return value;\n        });\n        const whenConnected = () => {\n            isConnected = true;\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-wave-shaper-node-factory.js.map"]},"metadata":{},"sourceType":"module"}