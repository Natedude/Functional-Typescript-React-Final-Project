{"ast":null,"code":"import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n  const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n  const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n  const feedbackLength = convertedFeedback.length;\n  const feedforwardLength = convertedFeedforward.length;\n  const minLength = Math.min(feedbackLength, feedforwardLength);\n\n  if (convertedFeedback[0] !== 1) {\n    for (let i = 0; i < feedbackLength; i += 1) {\n      convertedFeedforward[i] /= convertedFeedback[0];\n    }\n\n    for (let i = 1; i < feedforwardLength; i += 1) {\n      convertedFeedback[i] /= convertedFeedback[0];\n    }\n  }\n\n  const bufferLength = 32;\n  const xBuffer = new Float32Array(bufferLength);\n  const yBuffer = new Float32Array(bufferLength);\n  const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n  const numberOfChannels = renderedBuffer.numberOfChannels;\n\n  for (let i = 0; i < numberOfChannels; i += 1) {\n    const input = renderedBuffer.getChannelData(i);\n    const output = filteredBuffer.getChannelData(i);\n    xBuffer.fill(0);\n    yBuffer.fill(0);\n    filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n  }\n\n  return filteredBuffer;\n};\n\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (feedback, feedforward) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let filteredBufferPromise = null;\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioBufferSourceNode = null;\n      let nativeIIRFilterNode = getNativeAudioNode(proxy); // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext); // Bug #9: Safari does not support IIRFilterNodes.\n\n      if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n          buffer: null,\n          channelCount: 2,\n          channelCountMode: 'max',\n          channelInterpretation: 'speakers',\n          loop: false,\n          loopEnd: 0,\n          loopStart: 0,\n          playbackRate: 1\n        });\n      } else if (!nativeIIRFilterNodeIsOwnedByContext) {\n        // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n        nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n\n      if (nativeAudioBufferSourceNode !== null) {\n        if (filteredBufferPromise === null) {\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          }\n\n          const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor( // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n          proxy.context.destination.channelCount, // Bug #17: Safari does not yet expose the length.\n          proxy.context.length, nativeOfflineAudioContext.sampleRate);\n\n          filteredBufferPromise = (async () => {\n            await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination, trace);\n            const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n            return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n          })();\n        }\n\n        const filteredBuffer = await filteredBufferPromise;\n        nativeAudioBufferSourceNode.buffer = filteredBuffer;\n        nativeAudioBufferSourceNode.start(0);\n        return nativeAudioBufferSourceNode;\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode, trace);\n      return nativeIIRFilterNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","map":{"version":3,"sources":["../../../src/factories/iir-filter-node-renderer-factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n    const feedbackLength = convertedFeedback.length;\n    const feedforwardLength = convertedFeedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n    if (convertedFeedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            convertedFeedforward[i] /= convertedFeedback[0];\n        }\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            convertedFeedback[i] /= convertedFeedback[0];\n        }\n    }\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n        filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n    }\n    return filteredBuffer;\n};\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (feedback, feedforward) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let filteredBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioBufferSourceNode = null;\n            let nativeIIRFilterNode = getNativeAudioNode(proxy);\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n            }\n            else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n                nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n            if (nativeAudioBufferSourceNode !== null) {\n                if (filteredBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    proxy.context.destination.channelCount, \n                    // Bug #17: Safari does not yet expose the length.\n                    proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                    filteredBufferPromise = (async () => {\n                        await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination, trace);\n                        const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                        return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                    })();\n                }\n                const filteredBuffer = await filteredBufferPromise;\n                nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                nativeAudioBufferSourceNode.start(0);\n                return nativeAudioBufferSourceNode;\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode, trace);\n            return nativeIIRFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=iir-filter-node-renderer-factory.js.map"]},"metadata":{},"sourceType":"module"}