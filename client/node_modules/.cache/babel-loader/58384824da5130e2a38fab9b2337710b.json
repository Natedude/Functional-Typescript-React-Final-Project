{"ast":null,"code":"export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n  return async (audioNode, nativeOfflineAudioContext, nativeAudioNode, trace) => {\n    const audioNodeConnections = getAudioNodeConnections(audioNode);\n    const nextTrace = [...trace, audioNode];\n    await Promise.all(audioNodeConnections.activeInputs.map((connections, input) => Array.from(connections).filter(([source]) => !nextTrace.includes(source)).map(async ([source, output]) => {\n      const audioNodeRenderer = getAudioNodeRenderer(source);\n      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, nextTrace);\n      const destination = audioNode.context.destination;\n\n      if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n        renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n      }\n    })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n  };\n};","map":{"version":3,"sources":["../../../src/factories/render-inputs-of-audio-node.ts"],"names":[],"mappings":"AAGA,OAAO,MAAM,6BAA6B,GAAoC,CAC1E,uBAD0E,EAE1E,oBAF0E,EAG1E,cAH0E,KAI1E;AACA,SAAO,OAAO,SAAP,EAAkB,yBAAlB,EAA6C,eAA7C,EAA8D,KAA9D,KAAuE;AAC1E,UAAM,oBAAoB,GAAG,uBAAuB,CAAC,SAAD,CAApD;AACA,UAAM,SAAS,GAAG,CAAC,GAAG,KAAJ,EAAW,SAAX,CAAlB;AAEA,UAAM,OAAO,CAAC,GAAR,CACF,oBAAoB,CAAC,YAArB,CACK,GADL,CACS,CAAC,WAAD,EAAc,KAAd,KACD,KAAK,CAAC,IAAN,CAAW,WAAX,EACK,MADL,CACY,CAAC,CAAC,MAAD,CAAD,KAAc,CAAC,SAAS,CAAC,QAAV,CAAmB,MAAnB,CAD3B,EAEK,GAFL,CAES,OAAO,CAAC,MAAD,EAAS,MAAT,CAAP,KAA2B;AAC5B,YAAM,iBAAiB,GAAG,oBAAoB,CAAC,MAAD,CAA9C;AACA,YAAM,uBAAuB,GAAG,MAAM,iBAAiB,CAAC,MAAlB,CAAyB,MAAzB,EAAiC,yBAAjC,EAA4D,SAA5D,CAAtC;AACA,YAAM,WAAW,GAAoD,SAAS,CAAC,OAAV,CAAkB,WAAvF;;AAEA,UAAI,CAAC,cAAc,CAAC,MAAD,CAAf,KAA4B,SAAS,KAAK,WAAd,IAA6B,CAAC,cAAc,CAAC,SAAD,CAAxE,CAAJ,EAA0F;AACtF,QAAA,uBAAuB,CAAC,OAAxB,CAAgC,eAAhC,EAAiD,MAAjD,EAAyD,KAAzD;AACH;AACJ,KAVL,CAFR,EAcK,MAdL,CAcY,CAAC,oBAAD,EAAuB,iBAAvB,KAA6C,CAAC,GAAG,oBAAJ,EAA0B,GAAG,iBAA7B,CAdzD,EAc0G,EAd1G,CADE,CAAN;AAiBH,GArBD;AAsBH,CA3BM","sourceRoot":"","sourcesContent":["export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode, trace) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        const nextTrace = [...trace, audioNode];\n        await Promise.all(audioNodeConnections.activeInputs\n            .map((connections, input) => Array.from(connections)\n            .filter(([source]) => !nextTrace.includes(source))\n            .map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, nextTrace);\n            const destination = audioNode.context.destination;\n            if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n            }\n        }))\n            .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n    };\n};\n//# sourceMappingURL=render-inputs-of-audio-node.js.map"]},"metadata":{},"sourceType":"module"}