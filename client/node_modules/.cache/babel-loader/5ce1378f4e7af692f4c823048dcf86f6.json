{"ast":null,"code":"import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\n\nexport class Clock extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n    this.name = \"Clock\";\n    /**\n     * The callback function to invoke at the scheduled tick.\n     */\n\n    this.callback = noOp;\n    /**\n     * The last time the loop callback was invoked\n     */\n\n    this._lastUpdate = 0;\n    /**\n     * Keep track of the playback state\n     */\n\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * Context bound reference to the _loop method\n     * This is necessary to remove the event in the end.\n     */\n\n    this._boundLoop = this._loop.bind(this);\n    const options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n    this.callback = options.callback;\n    this._tickSource = new TickSource({\n      context: this.context,\n      frequency: options.frequency,\n      units: options.units\n    });\n    this._lastUpdate = 0;\n    this.frequency = this._tickSource.frequency;\n    readOnly(this, \"frequency\"); // add an initial state\n\n    this._state.setStateAtTime(\"stopped\", 0); // bind a callback to the worker thread\n\n\n    this.context.on(\"tick\", this._boundLoop);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      callback: noOp,\n      frequency: 1,\n      units: \"hertz\"\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n\n\n  get state() {\n    return this._state.getValueAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset  Where the tick counter starts counting from.\n   */\n\n\n  start(time, offset) {\n    // make sure the context is running\n    assertContextRunning(this.context); // start the loop\n\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      this._tickSource.start(computedTime, offset);\n\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"start\", computedTime, offset);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   * @example\n   * const clock = new Tone.Clock(time => {\n   * \tconsole.log(time);\n   * }, 1);\n   * clock.start();\n   * // stop the clock after 10 seconds\n   * clock.stop(\"+10\");\n   */\n\n\n  stop(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"stop\", computedTime);\n\n    this._state.cancel(computedTime);\n\n    this._state.setStateAtTime(\"stopped\", computedTime);\n\n    this._tickSource.stop(computedTime);\n\n    if (computedTime < this._lastUpdate) {\n      this.emit(\"stop\", computedTime);\n    }\n\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n\n\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n\n      this._tickSource.pause(computedTime);\n\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"pause\", computedTime);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked.\n   */\n\n\n  get ticks() {\n    return Math.ceil(this.getTicksAtTime(this.now()));\n  }\n\n  set ticks(t) {\n    this._tickSource.ticks = t;\n  }\n  /**\n   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n   */\n\n\n  get seconds() {\n    return this._tickSource.seconds;\n  }\n\n  set seconds(s) {\n    this._tickSource.seconds = s;\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  getSecondsAtTime(time) {\n    return this._tickSource.getSecondsAtTime(time);\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n\n\n  setTicksAtTime(ticks, time) {\n    this._tickSource.setTicksAtTime(ticks, time);\n\n    return this;\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n\n\n  getTimeOfTick(tick, before = this.now()) {\n    return this._tickSource.getTimeOfTick(tick, before);\n  }\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n\n\n  getTicksAtTime(time) {\n    return this._tickSource.getTicksAtTime(time);\n  }\n  /**\n   * Get the time of the next tick\n   * @param  offset The tick number.\n   */\n\n\n  nextTickTime(offset, when) {\n    const computedTime = this.toSeconds(when);\n    const currentTick = this.getTicksAtTime(computedTime);\n    return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n  }\n  /**\n   * The scheduling loop.\n   */\n\n\n  _loop() {\n    const startTime = this._lastUpdate;\n    const endTime = this.now();\n    this._lastUpdate = endTime;\n    this.log(\"loop\", startTime, endTime);\n\n    if (startTime !== endTime) {\n      // the state change events\n      this._state.forEachBetween(startTime, endTime, e => {\n        switch (e.state) {\n          case \"started\":\n            const offset = this._tickSource.getTicksAtTime(e.time);\n\n            this.emit(\"start\", e.time, offset);\n            break;\n\n          case \"stopped\":\n            if (e.time !== 0) {\n              this.emit(\"stop\", e.time);\n            }\n\n            break;\n\n          case \"paused\":\n            this.emit(\"pause\", e.time);\n            break;\n        }\n      }); // the tick callbacks\n\n\n      this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n        this.callback(time, ticks);\n      });\n    }\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   * @example\n   * const clock = new Tone.Clock();\n   * clock.start(\"+0.1\");\n   * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n   */\n\n\n  getStateAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    return this._state.getValueAtTime(computedTime);\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.context.off(\"tick\", this._boundLoop);\n\n    this._tickSource.dispose();\n\n    this._state.dispose();\n\n    return this;\n  }\n\n}\nEmitter.mixin(Clock);","map":{"version":3,"sources":["../../../../Tone/core/clock/Clock.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n        this.name = \"Clock\";\n        /**\n         * The callback function to invoke at the scheduled tick.\n         */\n        this.callback = noOp;\n        /**\n         * The last time the loop callback was invoked\n         */\n        this._lastUpdate = 0;\n        /**\n         * Keep track of the playback state\n         */\n        this._state = new StateTimeline(\"stopped\");\n        /**\n         * Context bound reference to the _loop method\n         * This is necessary to remove the event in the end.\n         */\n        this._boundLoop = this._loop.bind(this);\n        const options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n        this.callback = options.callback;\n        this._tickSource = new TickSource({\n            context: this.context,\n            frequency: options.frequency,\n            units: options.units,\n        });\n        this._lastUpdate = 0;\n        this.frequency = this._tickSource.frequency;\n        readOnly(this, \"frequency\");\n        // add an initial state\n        this._state.setStateAtTime(\"stopped\", 0);\n        // bind a callback to the worker thread\n        this.context.on(\"tick\", this._boundLoop);\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            callback: noOp,\n            frequency: 1,\n            units: \"hertz\",\n        });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    get state() {\n        return this._state.getValueAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset  Where the tick counter starts counting from.\n     */\n    start(time, offset) {\n        // make sure the context is running\n        assertContextRunning(this.context);\n        // start the loop\n        const computedTime = this.toSeconds(time);\n        this.log(\"start\", computedTime);\n        if (this._state.getValueAtTime(computedTime) !== \"started\") {\n            this._state.setStateAtTime(\"started\", computedTime);\n            this._tickSource.start(computedTime, offset);\n            if (computedTime < this._lastUpdate) {\n                this.emit(\"start\", computedTime, offset);\n            }\n        }\n        return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     * @example\n     * const clock = new Tone.Clock(time => {\n     * \tconsole.log(time);\n     * }, 1);\n     * clock.start();\n     * // stop the clock after 10 seconds\n     * clock.stop(\"+10\");\n     */\n    stop(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"stop\", computedTime);\n        this._state.cancel(computedTime);\n        this._state.setStateAtTime(\"stopped\", computedTime);\n        this._tickSource.stop(computedTime);\n        if (computedTime < this._lastUpdate) {\n            this.emit(\"stop\", computedTime);\n        }\n        return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n    pause(time) {\n        const computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            this._state.setStateAtTime(\"paused\", computedTime);\n            this._tickSource.pause(computedTime);\n            if (computedTime < this._lastUpdate) {\n                this.emit(\"pause\", computedTime);\n            }\n        }\n        return this;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked.\n     */\n    get ticks() {\n        return Math.ceil(this.getTicksAtTime(this.now()));\n    }\n    set ticks(t) {\n        this._tickSource.ticks = t;\n    }\n    /**\n     * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n     */\n    get seconds() {\n        return this._tickSource.seconds;\n    }\n    set seconds(s) {\n        this._tickSource.seconds = s;\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    getSecondsAtTime(time) {\n        return this._tickSource.getSecondsAtTime(time);\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n    setTicksAtTime(ticks, time) {\n        this._tickSource.setTicksAtTime(ticks, time);\n        return this;\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n    getTimeOfTick(tick, before = this.now()) {\n        return this._tickSource.getTimeOfTick(tick, before);\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n    getTicksAtTime(time) {\n        return this._tickSource.getTicksAtTime(time);\n    }\n    /**\n     * Get the time of the next tick\n     * @param  offset The tick number.\n     */\n    nextTickTime(offset, when) {\n        const computedTime = this.toSeconds(when);\n        const currentTick = this.getTicksAtTime(computedTime);\n        return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n    }\n    /**\n     * The scheduling loop.\n     */\n    _loop() {\n        const startTime = this._lastUpdate;\n        const endTime = this.now();\n        this._lastUpdate = endTime;\n        this.log(\"loop\", startTime, endTime);\n        if (startTime !== endTime) {\n            // the state change events\n            this._state.forEachBetween(startTime, endTime, e => {\n                switch (e.state) {\n                    case \"started\":\n                        const offset = this._tickSource.getTicksAtTime(e.time);\n                        this.emit(\"start\", e.time, offset);\n                        break;\n                    case \"stopped\":\n                        if (e.time !== 0) {\n                            this.emit(\"stop\", e.time);\n                        }\n                        break;\n                    case \"paused\":\n                        this.emit(\"pause\", e.time);\n                        break;\n                }\n            });\n            // the tick callbacks\n            this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n                this.callback(time, ticks);\n            });\n        }\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     * @return  The name of the state input in setStateAtTime.\n     * @example\n     * const clock = new Tone.Clock();\n     * clock.start(\"+0.1\");\n     * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n     */\n    getStateAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        return this._state.getValueAtTime(computedTime);\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this.context.off(\"tick\", this._boundLoop);\n        this._tickSource.dispose();\n        this._state.dispose();\n        return this;\n    }\n}\nEmitter.mixin(Clock);\n//# sourceMappingURL=Clock.js.map"]},"metadata":{},"sourceType":"module"}