{"ast":null,"code":"import { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst env = new Tone.Envelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 0.5,\n * \t\trelease: 0.8,\n * \t}).toDestination();\n * \tenv.triggerAttackRelease(0.5);\n * }, 1.5, 1);\n * @category Component\n */\n\nexport class Envelope extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n    this.name = \"Envelope\";\n    /**\n     * the signal which is output.\n     */\n\n    this._sig = new Signal({\n      context: this.context,\n      value: 0\n    });\n    /**\n     * The output signal of the envelope\n     */\n\n    this.output = this._sig;\n    /**\n     * Envelope has no input\n     */\n\n    this.input = undefined;\n    const options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n    this.attack = options.attack;\n    this.decay = options.decay;\n    this.sustain = options.sustain;\n    this.release = options.release;\n    this.attackCurve = options.attackCurve;\n    this.releaseCurve = options.releaseCurve;\n    this.decayCurve = options.decayCurve;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      attack: 0.01,\n      attackCurve: \"linear\",\n      decay: 0.1,\n      decayCurve: \"exponential\",\n      release: 1,\n      releaseCurve: \"exponential\",\n      sustain: 0.5\n    });\n  }\n  /**\n   * Read the current value of the envelope. Useful for\n   * synchronizing visual output to the envelope.\n   */\n\n\n  get value() {\n    return this.getValueAtTime(this.now());\n  }\n  /**\n   * Get the curve\n   * @param  curve\n   * @param  direction  In/Out\n   * @return The curve name\n   */\n\n\n  _getCurve(curve, direction) {\n    if (isString(curve)) {\n      return curve;\n    } else {\n      // look up the name in the curves array\n      let curveName;\n\n      for (curveName in EnvelopeCurves) {\n        if (EnvelopeCurves[curveName][direction] === curve) {\n          return curveName;\n        }\n      } // return the custom curve\n\n\n      return curve;\n    }\n  }\n  /**\n   * Assign a the curve to the given name using the direction\n   * @param  name\n   * @param  direction In/Out\n   * @param  curve\n   */\n\n\n  _setCurve(name, direction, curve) {\n    // check if it's a valid type\n    if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n      const curveDef = EnvelopeCurves[curve];\n\n      if (isObject(curveDef)) {\n        if (name !== \"_decayCurve\") {\n          this[name] = curveDef[direction];\n        }\n      } else {\n        this[name] = curveDef;\n      }\n    } else if (isArray(curve) && name !== \"_decayCurve\") {\n      this[name] = curve;\n    } else {\n      throw new Error(\"Envelope: invalid curve: \" + curve);\n    }\n  }\n  /**\n   * The shape of the attack.\n   * Can be any of these strings:\n   * * \"linear\"\n   * * \"exponential\"\n   * * \"sine\"\n   * * \"cosine\"\n   * * \"bounce\"\n   * * \"ripple\"\n   * * \"step\"\n   *\n   * Can also be an array which describes the curve. Values\n   * in the array are evenly subdivided and linearly\n   * interpolated over the duration of the attack.\n   * @example\n   * return Tone.Offline(() => {\n   * \tconst env = new Tone.Envelope(0.4).toDestination();\n   * \tenv.attackCurve = \"linear\";\n   * \tenv.triggerAttack();\n   * }, 1, 1);\n   */\n\n\n  get attackCurve() {\n    return this._getCurve(this._attackCurve, \"In\");\n  }\n\n  set attackCurve(curve) {\n    this._setCurve(\"_attackCurve\", \"In\", curve);\n  }\n  /**\n   * The shape of the release. See the attack curve types.\n   * @example\n   * return Tone.Offline(() => {\n   * \tconst env = new Tone.Envelope({\n   * \t\trelease: 0.8\n   * \t}).toDestination();\n   * \tenv.triggerAttack();\n   * \t// release curve could also be defined by an array\n   * \tenv.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];\n   * \tenv.triggerRelease(0.2);\n   * }, 1, 1);\n   */\n\n\n  get releaseCurve() {\n    return this._getCurve(this._releaseCurve, \"Out\");\n  }\n\n  set releaseCurve(curve) {\n    this._setCurve(\"_releaseCurve\", \"Out\", curve);\n  }\n  /**\n   * The shape of the decay either \"linear\" or \"exponential\"\n   * @example\n   * return Tone.Offline(() => {\n   * \tconst env = new Tone.Envelope({\n   * \t\tsustain: 0.1,\n   * \t\tdecay: 0.5\n   * \t}).toDestination();\n   * \tenv.decayCurve = \"linear\";\n   * \tenv.triggerAttack();\n   * }, 1, 1);\n   */\n\n\n  get decayCurve() {\n    return this._decayCurve;\n  }\n\n  set decayCurve(curve) {\n    assert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n    this._decayCurve = curve;\n  }\n  /**\n   * Trigger the attack/decay portion of the ADSR envelope.\n   * @param  time When the attack should start.\n   * @param velocity The velocity of the envelope scales the vales.\n   *                             number between 0-1\n   * @example\n   * const env = new Tone.AmplitudeEnvelope().toDestination();\n   * const osc = new Tone.Oscillator().connect(env).start();\n   * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n   * env.triggerAttack(\"+0.5\", 0.2);\n   */\n\n\n  triggerAttack(time, velocity = 1) {\n    this.log(\"triggerAttack\", time, velocity);\n    time = this.toSeconds(time);\n    const originalAttack = this.toSeconds(this.attack);\n    let attack = originalAttack;\n    const decay = this.toSeconds(this.decay); // check if it's not a complete attack\n\n    const currentValue = this.getValueAtTime(time);\n\n    if (currentValue > 0) {\n      // subtract the current value from the attack time\n      const attackRate = 1 / attack;\n      const remainingDistance = 1 - currentValue; // the attack is now the remaining time\n\n      attack = remainingDistance / attackRate;\n    } // attack\n\n\n    if (attack < this.sampleTime) {\n      this._sig.cancelScheduledValues(time); // case where the attack time is 0 should set instantly\n\n\n      this._sig.setValueAtTime(velocity, time);\n    } else if (this._attackCurve === \"linear\") {\n      this._sig.linearRampTo(velocity, attack, time);\n    } else if (this._attackCurve === \"exponential\") {\n      this._sig.targetRampTo(velocity, attack, time);\n    } else {\n      this._sig.cancelAndHoldAtTime(time);\n\n      let curve = this._attackCurve; // find the starting position in the curve\n\n      for (let i = 1; i < curve.length; i++) {\n        // the starting index is between the two values\n        if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n          curve = this._attackCurve.slice(i); // the first index is the current value\n\n          curve[0] = currentValue;\n          break;\n        }\n      }\n\n      this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n    } // decay\n\n\n    if (decay && this.sustain < 1) {\n      const decayValue = velocity * this.sustain;\n      const decayStart = time + attack;\n      this.log(\"decay\", decayStart);\n\n      if (this._decayCurve === \"linear\") {\n        this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n      } else {\n        this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Triggers the release of the envelope.\n   * @param  time When the release portion of the envelope should start.\n   * @example\n   * const env = new Tone.AmplitudeEnvelope().toDestination();\n   * const osc = new Tone.Oscillator({\n   * \ttype: \"sawtooth\"\n   * }).connect(env).start();\n   * env.triggerAttack();\n   * // trigger the release half a second after the attack\n   * env.triggerRelease(\"+0.5\");\n   */\n\n\n  triggerRelease(time) {\n    this.log(\"triggerRelease\", time);\n    time = this.toSeconds(time);\n    const currentValue = this.getValueAtTime(time);\n\n    if (currentValue > 0) {\n      const release = this.toSeconds(this.release);\n\n      if (release < this.sampleTime) {\n        this._sig.setValueAtTime(0, time);\n      } else if (this._releaseCurve === \"linear\") {\n        this._sig.linearRampTo(0, release, time);\n      } else if (this._releaseCurve === \"exponential\") {\n        this._sig.targetRampTo(0, release, time);\n      } else {\n        assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\n        this._sig.cancelAndHoldAtTime(time);\n\n        this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Get the scheduled value at the given time. This will\n   * return the unconverted (raw) value.\n   * @example\n   * const env = new Tone.Envelope(0.5, 1, 0.4, 2);\n   * env.triggerAttackRelease(2);\n   * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);\n   */\n\n\n  getValueAtTime(time) {\n    return this._sig.getValueAtTime(time);\n  }\n  /**\n   * triggerAttackRelease is shorthand for triggerAttack, then waiting\n   * some duration, then triggerRelease.\n   * @param duration The duration of the sustain.\n   * @param time When the attack should be triggered.\n   * @param velocity The velocity of the envelope.\n   * @example\n   * const env = new Tone.AmplitudeEnvelope().toDestination();\n   * const osc = new Tone.Oscillator().connect(env).start();\n   * // trigger the release 0.5 seconds after the attack\n   * env.triggerAttackRelease(0.5);\n   */\n\n\n  triggerAttackRelease(duration, time, velocity = 1) {\n    time = this.toSeconds(time);\n    this.triggerAttack(time, velocity);\n    this.triggerRelease(time + this.toSeconds(duration));\n    return this;\n  }\n  /**\n   * Cancels all scheduled envelope changes after the given time.\n   */\n\n\n  cancel(after) {\n    this._sig.cancelScheduledValues(this.toSeconds(after));\n\n    return this;\n  }\n  /**\n   * Connect the envelope to a destination node.\n   */\n\n\n  connect(destination, outputNumber = 0, inputNumber = 0) {\n    connectSignal(this, destination, outputNumber, inputNumber);\n    return this;\n  }\n  /**\n   * Render the envelope curve to an array of the given length.\n   * Good for visualizing the envelope curve. Rescales the duration of the\n   * envelope to fit the length.\n   */\n\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const duration = length / this.context.sampleRate;\n      const context = new OfflineContext(1, duration, this.context.sampleRate); // normalize the ADSR for the given duration with 20% sustain time\n\n      const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n      const envelopeDuration = attackPortion + this.toSeconds(this.release);\n      const sustainTime = envelopeDuration * 0.1;\n      const totalDuration = envelopeDuration + sustainTime; // @ts-ignore\n\n      const clone = new this.constructor(Object.assign(this.get(), {\n        attack: duration * this.toSeconds(this.attack) / totalDuration,\n        decay: duration * this.toSeconds(this.decay) / totalDuration,\n        release: duration * this.toSeconds(this.release) / totalDuration,\n        context\n      }));\n\n      clone._sig.toDestination();\n\n      clone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n      const buffer = yield context.render();\n      return buffer.getChannelData(0);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._sig.dispose();\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Envelope.prototype, \"attack\", void 0);\n\n__decorate([timeRange(0)], Envelope.prototype, \"decay\", void 0);\n\n__decorate([range(0, 1)], Envelope.prototype, \"sustain\", void 0);\n\n__decorate([timeRange(0)], Envelope.prototype, \"release\", void 0);\n/**\n * Generate some complex envelope curves.\n */\n\n\nconst EnvelopeCurves = (() => {\n  const curveLen = 128;\n  let i;\n  let k; // cosine curve\n\n  const cosineCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));\n  } // ripple curve\n\n\n  const rippleCurve = [];\n  const rippleCurveFreq = 6.4;\n\n  for (i = 0; i < curveLen - 1; i++) {\n    k = i / (curveLen - 1);\n    const sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n    rippleCurve[i] = sineWave / 10 + k * 0.83;\n  }\n\n  rippleCurve[curveLen - 1] = 1; // stairs curve\n\n  const stairsCurve = [];\n  const steps = 5;\n\n  for (i = 0; i < curveLen; i++) {\n    stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;\n  } // in-out easing curve\n\n\n  const sineCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n  } // a bounce curve\n\n\n  const bounceCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    const freq = Math.pow(k, 3) * 4 + 0.2;\n    const val = Math.cos(freq * Math.PI * 2 * k);\n    bounceCurve[i] = Math.abs(val * (1 - k));\n  }\n  /**\n   * Invert a value curve to make it work for the release\n   */\n\n\n  function invertCurve(curve) {\n    const out = new Array(curve.length);\n\n    for (let j = 0; j < curve.length; j++) {\n      out[j] = 1 - curve[j];\n    }\n\n    return out;\n  }\n  /**\n   * reverse the curve\n   */\n\n\n  function reverseCurve(curve) {\n    return curve.slice(0).reverse();\n  }\n  /**\n   * attack and release curve arrays\n   */\n\n\n  return {\n    bounce: {\n      In: invertCurve(bounceCurve),\n      Out: bounceCurve\n    },\n    cosine: {\n      In: cosineCurve,\n      Out: reverseCurve(cosineCurve)\n    },\n    exponential: \"exponential\",\n    linear: \"linear\",\n    ripple: {\n      In: rippleCurve,\n      Out: invertCurve(rippleCurve)\n    },\n    sine: {\n      In: sineCurve,\n      Out: invertCurve(sineCurve)\n    },\n    step: {\n      In: stairsCurve,\n      Out: invertCurve(stairsCurve)\n    }\n  };\n})();","map":{"version":3,"sources":["../../../../Tone/component/envelope/Envelope.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst env = new Tone.Envelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 0.5,\n * \t\trelease: 0.8,\n * \t}).toDestination();\n * \tenv.triggerAttackRelease(0.5);\n * }, 1.5, 1);\n * @category Component\n */\nexport class Envelope extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n        this.name = \"Envelope\";\n        /**\n         * the signal which is output.\n         */\n        this._sig = new Signal({\n            context: this.context,\n            value: 0,\n        });\n        /**\n         * The output signal of the envelope\n         */\n        this.output = this._sig;\n        /**\n         * Envelope has no input\n         */\n        this.input = undefined;\n        const options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n        this.attack = options.attack;\n        this.decay = options.decay;\n        this.sustain = options.sustain;\n        this.release = options.release;\n        this.attackCurve = options.attackCurve;\n        this.releaseCurve = options.releaseCurve;\n        this.decayCurve = options.decayCurve;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            attack: 0.01,\n            attackCurve: \"linear\",\n            decay: 0.1,\n            decayCurve: \"exponential\",\n            release: 1,\n            releaseCurve: \"exponential\",\n            sustain: 0.5,\n        });\n    }\n    /**\n     * Read the current value of the envelope. Useful for\n     * synchronizing visual output to the envelope.\n     */\n    get value() {\n        return this.getValueAtTime(this.now());\n    }\n    /**\n     * Get the curve\n     * @param  curve\n     * @param  direction  In/Out\n     * @return The curve name\n     */\n    _getCurve(curve, direction) {\n        if (isString(curve)) {\n            return curve;\n        }\n        else {\n            // look up the name in the curves array\n            let curveName;\n            for (curveName in EnvelopeCurves) {\n                if (EnvelopeCurves[curveName][direction] === curve) {\n                    return curveName;\n                }\n            }\n            // return the custom curve\n            return curve;\n        }\n    }\n    /**\n     * Assign a the curve to the given name using the direction\n     * @param  name\n     * @param  direction In/Out\n     * @param  curve\n     */\n    _setCurve(name, direction, curve) {\n        // check if it's a valid type\n        if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n            const curveDef = EnvelopeCurves[curve];\n            if (isObject(curveDef)) {\n                if (name !== \"_decayCurve\") {\n                    this[name] = curveDef[direction];\n                }\n            }\n            else {\n                this[name] = curveDef;\n            }\n        }\n        else if (isArray(curve) && name !== \"_decayCurve\") {\n            this[name] = curve;\n        }\n        else {\n            throw new Error(\"Envelope: invalid curve: \" + curve);\n        }\n    }\n    /**\n     * The shape of the attack.\n     * Can be any of these strings:\n     * * \"linear\"\n     * * \"exponential\"\n     * * \"sine\"\n     * * \"cosine\"\n     * * \"bounce\"\n     * * \"ripple\"\n     * * \"step\"\n     *\n     * Can also be an array which describes the curve. Values\n     * in the array are evenly subdivided and linearly\n     * interpolated over the duration of the attack.\n     * @example\n     * return Tone.Offline(() => {\n     * \tconst env = new Tone.Envelope(0.4).toDestination();\n     * \tenv.attackCurve = \"linear\";\n     * \tenv.triggerAttack();\n     * }, 1, 1);\n     */\n    get attackCurve() {\n        return this._getCurve(this._attackCurve, \"In\");\n    }\n    set attackCurve(curve) {\n        this._setCurve(\"_attackCurve\", \"In\", curve);\n    }\n    /**\n     * The shape of the release. See the attack curve types.\n     * @example\n     * return Tone.Offline(() => {\n     * \tconst env = new Tone.Envelope({\n     * \t\trelease: 0.8\n     * \t}).toDestination();\n     * \tenv.triggerAttack();\n     * \t// release curve could also be defined by an array\n     * \tenv.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];\n     * \tenv.triggerRelease(0.2);\n     * }, 1, 1);\n     */\n    get releaseCurve() {\n        return this._getCurve(this._releaseCurve, \"Out\");\n    }\n    set releaseCurve(curve) {\n        this._setCurve(\"_releaseCurve\", \"Out\", curve);\n    }\n    /**\n     * The shape of the decay either \"linear\" or \"exponential\"\n     * @example\n     * return Tone.Offline(() => {\n     * \tconst env = new Tone.Envelope({\n     * \t\tsustain: 0.1,\n     * \t\tdecay: 0.5\n     * \t}).toDestination();\n     * \tenv.decayCurve = \"linear\";\n     * \tenv.triggerAttack();\n     * }, 1, 1);\n     */\n    get decayCurve() {\n        return this._decayCurve;\n    }\n    set decayCurve(curve) {\n        assert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n        this._decayCurve = curve;\n    }\n    /**\n     * Trigger the attack/decay portion of the ADSR envelope.\n     * @param  time When the attack should start.\n     * @param velocity The velocity of the envelope scales the vales.\n     *                             number between 0-1\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator().connect(env).start();\n     * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n     * env.triggerAttack(\"+0.5\", 0.2);\n     */\n    triggerAttack(time, velocity = 1) {\n        this.log(\"triggerAttack\", time, velocity);\n        time = this.toSeconds(time);\n        const originalAttack = this.toSeconds(this.attack);\n        let attack = originalAttack;\n        const decay = this.toSeconds(this.decay);\n        // check if it's not a complete attack\n        const currentValue = this.getValueAtTime(time);\n        if (currentValue > 0) {\n            // subtract the current value from the attack time\n            const attackRate = 1 / attack;\n            const remainingDistance = 1 - currentValue;\n            // the attack is now the remaining time\n            attack = remainingDistance / attackRate;\n        }\n        // attack\n        if (attack < this.sampleTime) {\n            this._sig.cancelScheduledValues(time);\n            // case where the attack time is 0 should set instantly\n            this._sig.setValueAtTime(velocity, time);\n        }\n        else if (this._attackCurve === \"linear\") {\n            this._sig.linearRampTo(velocity, attack, time);\n        }\n        else if (this._attackCurve === \"exponential\") {\n            this._sig.targetRampTo(velocity, attack, time);\n        }\n        else {\n            this._sig.cancelAndHoldAtTime(time);\n            let curve = this._attackCurve;\n            // find the starting position in the curve\n            for (let i = 1; i < curve.length; i++) {\n                // the starting index is between the two values\n                if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n                    curve = this._attackCurve.slice(i);\n                    // the first index is the current value\n                    curve[0] = currentValue;\n                    break;\n                }\n            }\n            this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n        }\n        // decay\n        if (decay && this.sustain < 1) {\n            const decayValue = velocity * this.sustain;\n            const decayStart = time + attack;\n            this.log(\"decay\", decayStart);\n            if (this._decayCurve === \"linear\") {\n                this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n            }\n            else {\n                this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n            }\n        }\n        return this;\n    }\n    /**\n     * Triggers the release of the envelope.\n     * @param  time When the release portion of the envelope should start.\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator({\n     * \ttype: \"sawtooth\"\n     * }).connect(env).start();\n     * env.triggerAttack();\n     * // trigger the release half a second after the attack\n     * env.triggerRelease(\"+0.5\");\n     */\n    triggerRelease(time) {\n        this.log(\"triggerRelease\", time);\n        time = this.toSeconds(time);\n        const currentValue = this.getValueAtTime(time);\n        if (currentValue > 0) {\n            const release = this.toSeconds(this.release);\n            if (release < this.sampleTime) {\n                this._sig.setValueAtTime(0, time);\n            }\n            else if (this._releaseCurve === \"linear\") {\n                this._sig.linearRampTo(0, release, time);\n            }\n            else if (this._releaseCurve === \"exponential\") {\n                this._sig.targetRampTo(0, release, time);\n            }\n            else {\n                assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n                this._sig.cancelAndHoldAtTime(time);\n                this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n            }\n        }\n        return this;\n    }\n    /**\n     * Get the scheduled value at the given time. This will\n     * return the unconverted (raw) value.\n     * @example\n     * const env = new Tone.Envelope(0.5, 1, 0.4, 2);\n     * env.triggerAttackRelease(2);\n     * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);\n     */\n    getValueAtTime(time) {\n        return this._sig.getValueAtTime(time);\n    }\n    /**\n     * triggerAttackRelease is shorthand for triggerAttack, then waiting\n     * some duration, then triggerRelease.\n     * @param duration The duration of the sustain.\n     * @param time When the attack should be triggered.\n     * @param velocity The velocity of the envelope.\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator().connect(env).start();\n     * // trigger the release 0.5 seconds after the attack\n     * env.triggerAttackRelease(0.5);\n     */\n    triggerAttackRelease(duration, time, velocity = 1) {\n        time = this.toSeconds(time);\n        this.triggerAttack(time, velocity);\n        this.triggerRelease(time + this.toSeconds(duration));\n        return this;\n    }\n    /**\n     * Cancels all scheduled envelope changes after the given time.\n     */\n    cancel(after) {\n        this._sig.cancelScheduledValues(this.toSeconds(after));\n        return this;\n    }\n    /**\n     * Connect the envelope to a destination node.\n     */\n    connect(destination, outputNumber = 0, inputNumber = 0) {\n        connectSignal(this, destination, outputNumber, inputNumber);\n        return this;\n    }\n    /**\n     * Render the envelope curve to an array of the given length.\n     * Good for visualizing the envelope curve. Rescales the duration of the\n     * envelope to fit the length.\n     */\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const duration = length / this.context.sampleRate;\n            const context = new OfflineContext(1, duration, this.context.sampleRate);\n            // normalize the ADSR for the given duration with 20% sustain time\n            const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n            const envelopeDuration = attackPortion + this.toSeconds(this.release);\n            const sustainTime = envelopeDuration * 0.1;\n            const totalDuration = envelopeDuration + sustainTime;\n            // @ts-ignore\n            const clone = new this.constructor(Object.assign(this.get(), {\n                attack: duration * this.toSeconds(this.attack) / totalDuration,\n                decay: duration * this.toSeconds(this.decay) / totalDuration,\n                release: duration * this.toSeconds(this.release) / totalDuration,\n                context\n            }));\n            clone._sig.toDestination();\n            clone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n            const buffer = yield context.render();\n            return buffer.getChannelData(0);\n        });\n    }\n    dispose() {\n        super.dispose();\n        this._sig.dispose();\n        return this;\n    }\n}\n__decorate([\n    timeRange(0)\n], Envelope.prototype, \"attack\", void 0);\n__decorate([\n    timeRange(0)\n], Envelope.prototype, \"decay\", void 0);\n__decorate([\n    range(0, 1)\n], Envelope.prototype, \"sustain\", void 0);\n__decorate([\n    timeRange(0)\n], Envelope.prototype, \"release\", void 0);\n/**\n * Generate some complex envelope curves.\n */\nconst EnvelopeCurves = (() => {\n    const curveLen = 128;\n    let i;\n    let k;\n    // cosine curve\n    const cosineCurve = [];\n    for (i = 0; i < curveLen; i++) {\n        cosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n    }\n    // ripple curve\n    const rippleCurve = [];\n    const rippleCurveFreq = 6.4;\n    for (i = 0; i < curveLen - 1; i++) {\n        k = (i / (curveLen - 1));\n        const sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n        rippleCurve[i] = sineWave / 10 + k * 0.83;\n    }\n    rippleCurve[curveLen - 1] = 1;\n    // stairs curve\n    const stairsCurve = [];\n    const steps = 5;\n    for (i = 0; i < curveLen; i++) {\n        stairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n    }\n    // in-out easing curve\n    const sineCurve = [];\n    for (i = 0; i < curveLen; i++) {\n        k = i / (curveLen - 1);\n        sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n    // a bounce curve\n    const bounceCurve = [];\n    for (i = 0; i < curveLen; i++) {\n        k = i / (curveLen - 1);\n        const freq = Math.pow(k, 3) * 4 + 0.2;\n        const val = Math.cos(freq * Math.PI * 2 * k);\n        bounceCurve[i] = Math.abs(val * (1 - k));\n    }\n    /**\n     * Invert a value curve to make it work for the release\n     */\n    function invertCurve(curve) {\n        const out = new Array(curve.length);\n        for (let j = 0; j < curve.length; j++) {\n            out[j] = 1 - curve[j];\n        }\n        return out;\n    }\n    /**\n     * reverse the curve\n     */\n    function reverseCurve(curve) {\n        return curve.slice(0).reverse();\n    }\n    /**\n     * attack and release curve arrays\n     */\n    return {\n        bounce: {\n            In: invertCurve(bounceCurve),\n            Out: bounceCurve,\n        },\n        cosine: {\n            In: cosineCurve,\n            Out: reverseCurve(cosineCurve),\n        },\n        exponential: \"exponential\",\n        linear: \"linear\",\n        ripple: {\n            In: rippleCurve,\n            Out: invertCurve(rippleCurve),\n        },\n        sine: {\n            In: sineCurve,\n            Out: invertCurve(sineCurve),\n        },\n        step: {\n            In: stairsCurve,\n            Out: invertCurve(stairsCurve),\n        },\n    };\n})();\n//# sourceMappingURL=Envelope.js.map"]},"metadata":{},"sourceType":"module"}