{"ast":null,"code":"import { TicksClass } from \"../core/type/Ticks\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\n\nexport class Sequence extends ToneEvent {\n  constructor() {\n    super(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n    this.name = \"Sequence\";\n    /**\n     * The object responsible for scheduling all of the events\n     */\n\n    this._part = new Part({\n      callback: this._seqCallback.bind(this),\n      context: this.context\n    });\n    /**\n     * private reference to all of the sequence proxies\n     */\n\n    this._events = [];\n    /**\n     * The proxied array\n     */\n\n    this._eventsArray = [];\n    const options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n    this._subdivision = this.toTicks(options.subdivision);\n    this.events = options.events; // set all of the values\n\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this.playbackRate = options.playbackRate;\n    this.probability = options.probability;\n    this.humanize = options.humanize;\n    this.mute = options.mute;\n    this.playbackRate = options.playbackRate;\n  }\n\n  static getDefaults() {\n    return Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n      events: [],\n      loop: true,\n      loopEnd: 0,\n      loopStart: 0,\n      subdivision: \"8n\"\n    });\n  }\n  /**\n   * The internal callback for when an event is invoked\n   */\n\n\n  _seqCallback(time, value) {\n    if (value !== null) {\n      this.callback(time, value);\n    }\n  }\n  /**\n   * The sequence\n   */\n\n\n  get events() {\n    return this._events;\n  }\n\n  set events(s) {\n    this.clear();\n    this._eventsArray = s;\n    this._events = this._createSequence(this._eventsArray);\n\n    this._eventsUpdated();\n  }\n  /**\n   * Start the part at the given time.\n   * @param  time    When to start the part.\n   * @param  offset  The offset index to start at\n   */\n\n\n  start(time, offset) {\n    this._part.start(time, offset ? this._indexTime(offset) : offset);\n\n    return this;\n  }\n  /**\n   * Stop the part at the given time.\n   * @param  time  When to stop the part.\n   */\n\n\n  stop(time) {\n    this._part.stop(time);\n\n    return this;\n  }\n  /**\n   * The subdivision of the sequence. This can only be\n   * set in the constructor. The subdivision is the\n   * interval between successive steps.\n   */\n\n\n  get subdivision() {\n    return new TicksClass(this.context, this._subdivision).toSeconds();\n  }\n  /**\n   * Create a sequence proxy which can be monitored to create subsequences\n   */\n\n\n  _createSequence(array) {\n    return new Proxy(array, {\n      get: (target, property) => {\n        // property is index in this case\n        return target[property];\n      },\n      set: (target, property, value) => {\n        if (isString(property) && isFinite(parseInt(property, 10))) {\n          if (isArray(value)) {\n            target[property] = this._createSequence(value);\n          } else {\n            target[property] = value;\n          }\n        } else {\n          target[property] = value;\n        }\n\n        this._eventsUpdated(); // return true to accept the changes\n\n\n        return true;\n      }\n    });\n  }\n  /**\n   * When the sequence has changed, all of the events need to be recreated\n   */\n\n\n  _eventsUpdated() {\n    this._part.clear();\n\n    this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset); // update the loopEnd\n\n\n    this.loopEnd = this.loopEnd;\n  }\n  /**\n   * reschedule all of the events that need to be rescheduled\n   */\n\n\n  _rescheduleSequence(sequence, subdivision, startOffset) {\n    sequence.forEach((value, index) => {\n      const eventOffset = index * subdivision + startOffset;\n\n      if (isArray(value)) {\n        this._rescheduleSequence(value, subdivision / value.length, eventOffset);\n      } else {\n        const startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\n        this._part.add(startTime, value);\n      }\n    });\n  }\n  /**\n   * Get the time of the index given the Sequence's subdivision\n   * @param  index\n   * @return The time of that index\n   */\n\n\n  _indexTime(index) {\n    return new TicksClass(this.context, index * this._subdivision + this.startOffset).toSeconds();\n  }\n  /**\n   * Clear all of the events\n   */\n\n\n  clear() {\n    this._part.clear();\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._part.dispose();\n\n    return this;\n  } //-------------------------------------\n  // PROXY CALLS\n  //-------------------------------------\n\n\n  get loop() {\n    return this._part.loop;\n  }\n\n  set loop(l) {\n    this._part.loop = l;\n  }\n  /**\n   * The index at which the sequence should start looping\n   */\n\n\n  get loopStart() {\n    return this._loopStart;\n  }\n\n  set loopStart(index) {\n    this._loopStart = index;\n    this._part.loopStart = this._indexTime(index);\n  }\n  /**\n   * The index at which the sequence should end looping\n   */\n\n\n  get loopEnd() {\n    return this._loopEnd;\n  }\n\n  set loopEnd(index) {\n    this._loopEnd = index;\n\n    if (index === 0) {\n      this._part.loopEnd = this._indexTime(this._eventsArray.length);\n    } else {\n      this._part.loopEnd = this._indexTime(index);\n    }\n  }\n\n  get startOffset() {\n    return this._part.startOffset;\n  }\n\n  set startOffset(start) {\n    this._part.startOffset = start;\n  }\n\n  get playbackRate() {\n    return this._part.playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._part.playbackRate = rate;\n  }\n\n  get probability() {\n    return this._part.probability;\n  }\n\n  set probability(prob) {\n    this._part.probability = prob;\n  }\n\n  get progress() {\n    return this._part.progress;\n  }\n\n  get humanize() {\n    return this._part.humanize;\n  }\n\n  set humanize(variation) {\n    this._part.humanize = variation;\n  }\n  /**\n   * The number of scheduled events\n   */\n\n\n  get length() {\n    return this._part.length;\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/event/Sequence.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { TicksClass } from \"../core/type/Ticks\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Sequence extends ToneEvent {\n    constructor() {\n        super(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n        this.name = \"Sequence\";\n        /**\n         * The object responsible for scheduling all of the events\n         */\n        this._part = new Part({\n            callback: this._seqCallback.bind(this),\n            context: this.context,\n        });\n        /**\n         * private reference to all of the sequence proxies\n         */\n        this._events = [];\n        /**\n         * The proxied array\n         */\n        this._eventsArray = [];\n        const options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n        this._subdivision = this.toTicks(options.subdivision);\n        this.events = options.events;\n        // set all of the values\n        this.loop = options.loop;\n        this.loopStart = options.loopStart;\n        this.loopEnd = options.loopEnd;\n        this.playbackRate = options.playbackRate;\n        this.probability = options.probability;\n        this.humanize = options.humanize;\n        this.mute = options.mute;\n        this.playbackRate = options.playbackRate;\n    }\n    static getDefaults() {\n        return Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n            events: [],\n            loop: true,\n            loopEnd: 0,\n            loopStart: 0,\n            subdivision: \"8n\",\n        });\n    }\n    /**\n     * The internal callback for when an event is invoked\n     */\n    _seqCallback(time, value) {\n        if (value !== null) {\n            this.callback(time, value);\n        }\n    }\n    /**\n     * The sequence\n     */\n    get events() {\n        return this._events;\n    }\n    set events(s) {\n        this.clear();\n        this._eventsArray = s;\n        this._events = this._createSequence(this._eventsArray);\n        this._eventsUpdated();\n    }\n    /**\n     * Start the part at the given time.\n     * @param  time    When to start the part.\n     * @param  offset  The offset index to start at\n     */\n    start(time, offset) {\n        this._part.start(time, offset ? this._indexTime(offset) : offset);\n        return this;\n    }\n    /**\n     * Stop the part at the given time.\n     * @param  time  When to stop the part.\n     */\n    stop(time) {\n        this._part.stop(time);\n        return this;\n    }\n    /**\n     * The subdivision of the sequence. This can only be\n     * set in the constructor. The subdivision is the\n     * interval between successive steps.\n     */\n    get subdivision() {\n        return new TicksClass(this.context, this._subdivision).toSeconds();\n    }\n    /**\n     * Create a sequence proxy which can be monitored to create subsequences\n     */\n    _createSequence(array) {\n        return new Proxy(array, {\n            get: (target, property) => {\n                // property is index in this case\n                return target[property];\n            },\n            set: (target, property, value) => {\n                if (isString(property) && isFinite(parseInt(property, 10))) {\n                    if (isArray(value)) {\n                        target[property] = this._createSequence(value);\n                    }\n                    else {\n                        target[property] = value;\n                    }\n                }\n                else {\n                    target[property] = value;\n                }\n                this._eventsUpdated();\n                // return true to accept the changes\n                return true;\n            },\n        });\n    }\n    /**\n     * When the sequence has changed, all of the events need to be recreated\n     */\n    _eventsUpdated() {\n        this._part.clear();\n        this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n        // update the loopEnd\n        this.loopEnd = this.loopEnd;\n    }\n    /**\n     * reschedule all of the events that need to be rescheduled\n     */\n    _rescheduleSequence(sequence, subdivision, startOffset) {\n        sequence.forEach((value, index) => {\n            const eventOffset = index * (subdivision) + startOffset;\n            if (isArray(value)) {\n                this._rescheduleSequence(value, subdivision / value.length, eventOffset);\n            }\n            else {\n                const startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n                this._part.add(startTime, value);\n            }\n        });\n    }\n    /**\n     * Get the time of the index given the Sequence's subdivision\n     * @param  index\n     * @return The time of that index\n     */\n    _indexTime(index) {\n        return new TicksClass(this.context, index * (this._subdivision) + this.startOffset).toSeconds();\n    }\n    /**\n     * Clear all of the events\n     */\n    clear() {\n        this._part.clear();\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._part.dispose();\n        return this;\n    }\n    //-------------------------------------\n    // PROXY CALLS\n    //-------------------------------------\n    get loop() {\n        return this._part.loop;\n    }\n    set loop(l) {\n        this._part.loop = l;\n    }\n    /**\n     * The index at which the sequence should start looping\n     */\n    get loopStart() {\n        return this._loopStart;\n    }\n    set loopStart(index) {\n        this._loopStart = index;\n        this._part.loopStart = this._indexTime(index);\n    }\n    /**\n     * The index at which the sequence should end looping\n     */\n    get loopEnd() {\n        return this._loopEnd;\n    }\n    set loopEnd(index) {\n        this._loopEnd = index;\n        if (index === 0) {\n            this._part.loopEnd = this._indexTime(this._eventsArray.length);\n        }\n        else {\n            this._part.loopEnd = this._indexTime(index);\n        }\n    }\n    get startOffset() {\n        return this._part.startOffset;\n    }\n    set startOffset(start) {\n        this._part.startOffset = start;\n    }\n    get playbackRate() {\n        return this._part.playbackRate;\n    }\n    set playbackRate(rate) {\n        this._part.playbackRate = rate;\n    }\n    get probability() {\n        return this._part.probability;\n    }\n    set probability(prob) {\n        this._part.probability = prob;\n    }\n    get progress() {\n        return this._part.progress;\n    }\n    get humanize() {\n        return this._part.humanize;\n    }\n    set humanize(variation) {\n        this._part.humanize = variation;\n    }\n    /**\n     * The number of scheduled events\n     */\n    get length() {\n        return this._part.length;\n    }\n}\n//# sourceMappingURL=Sequence.js.map"]},"metadata":{},"sourceType":"module"}