{"ast":null,"code":"import { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n/**\n * Start at the first value and go up to the last\n */\n\nfunction* upPatternGen(values) {\n  let index = 0;\n\n  while (index < values.length) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    index++;\n  }\n}\n/**\n * Start at the last value and go down to 0\n */\n\n\nfunction* downPatternGen(values) {\n  let index = values.length - 1;\n\n  while (index >= 0) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    index--;\n  }\n}\n/**\n * Infinitely yield the generator\n */\n\n\nfunction* infiniteGen(values, gen) {\n  while (true) {\n    yield* gen(values);\n  }\n}\n/**\n * Make sure that the index is in the given range\n */\n\n\nfunction clampToArraySize(index, values) {\n  return clamp(index, 0, values.length - 1);\n}\n/**\n * Alternate between two generators\n */\n\n\nfunction* alternatingGenerator(values, directionUp) {\n  let index = directionUp ? 0 : values.length - 1;\n\n  while (true) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n\n    if (directionUp) {\n      index++;\n\n      if (index >= values.length - 1) {\n        directionUp = false;\n      }\n    } else {\n      index--;\n\n      if (index <= 0) {\n        directionUp = true;\n      }\n    }\n  }\n}\n/**\n * Starting from the bottom move up 2, down 1\n */\n\n\nfunction* jumpUp(values) {\n  let index = 0;\n  let stepIndex = 0;\n\n  while (index < values.length) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    stepIndex++;\n    index += stepIndex % 2 ? 2 : -1;\n  }\n}\n/**\n * Starting from the top move down 2, up 1\n */\n\n\nfunction* jumpDown(values) {\n  let index = values.length - 1;\n  let stepIndex = 0;\n\n  while (index >= 0) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    stepIndex++;\n    index += stepIndex % 2 ? -2 : 1;\n  }\n}\n/**\n * Choose a random index each time\n */\n\n\nfunction* randomGen(values) {\n  while (true) {\n    const randomIndex = Math.floor(Math.random() * values.length);\n    yield values[randomIndex];\n  }\n}\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\n\n\nfunction* randomOnce(values) {\n  // create an array of indices\n  const copy = [];\n\n  for (let i = 0; i < values.length; i++) {\n    copy.push(i);\n  }\n\n  while (copy.length > 0) {\n    // random choose an index, and then remove it so it's not chosen again\n    const randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n    const index = clampToArraySize(randVal[0], values);\n    yield values[index];\n  }\n}\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\n\n\nfunction* randomWalk(values) {\n  // randomly choose a starting index in the values array\n  let index = Math.floor(Math.random() * values.length);\n\n  while (true) {\n    if (index === 0) {\n      index++; // at bottom of array, so force upward step\n    } else if (index === values.length - 1) {\n      index--; // at top of array, so force downward step\n    } else if (Math.random() < 0.5) {\n      // else choose random downward or upward step\n      index--;\n    } else {\n      index++;\n    }\n\n    yield values[index];\n  }\n}\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\n\n\nexport function* PatternGenerator(values, pattern = \"up\", index = 0) {\n  // safeguards\n  assert(values.length > 0, \"The array must have more than one value in it\");\n\n  switch (pattern) {\n    case \"up\":\n      yield* infiniteGen(values, upPatternGen);\n\n    case \"down\":\n      yield* infiniteGen(values, downPatternGen);\n\n    case \"upDown\":\n      yield* alternatingGenerator(values, true);\n\n    case \"downUp\":\n      yield* alternatingGenerator(values, false);\n\n    case \"alternateUp\":\n      yield* infiniteGen(values, jumpUp);\n\n    case \"alternateDown\":\n      yield* infiniteGen(values, jumpDown);\n\n    case \"random\":\n      yield* randomGen(values);\n\n    case \"randomOnce\":\n      yield* infiniteGen(values, randomOnce);\n\n    case \"randomWalk\":\n      yield* randomWalk(values);\n  }\n}","map":{"version":3,"sources":["../../../Tone/event/PatternGenerator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n/**\n * Start at the first value and go up to the last\n */\nfunction* upPatternGen(values) {\n    let index = 0;\n    while (index < values.length) {\n        index = clampToArraySize(index, values);\n        yield values[index];\n        index++;\n    }\n}\n/**\n * Start at the last value and go down to 0\n */\nfunction* downPatternGen(values) {\n    let index = values.length - 1;\n    while (index >= 0) {\n        index = clampToArraySize(index, values);\n        yield values[index];\n        index--;\n    }\n}\n/**\n * Infinitely yield the generator\n */\nfunction* infiniteGen(values, gen) {\n    while (true) {\n        yield* gen(values);\n    }\n}\n/**\n * Make sure that the index is in the given range\n */\nfunction clampToArraySize(index, values) {\n    return clamp(index, 0, values.length - 1);\n}\n/**\n * Alternate between two generators\n */\nfunction* alternatingGenerator(values, directionUp) {\n    let index = directionUp ? 0 : values.length - 1;\n    while (true) {\n        index = clampToArraySize(index, values);\n        yield values[index];\n        if (directionUp) {\n            index++;\n            if (index >= values.length - 1) {\n                directionUp = false;\n            }\n        }\n        else {\n            index--;\n            if (index <= 0) {\n                directionUp = true;\n            }\n        }\n    }\n}\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction* jumpUp(values) {\n    let index = 0;\n    let stepIndex = 0;\n    while (index < values.length) {\n        index = clampToArraySize(index, values);\n        yield values[index];\n        stepIndex++;\n        index += (stepIndex % 2 ? 2 : -1);\n    }\n}\n/**\n * Starting from the top move down 2, up 1\n */\nfunction* jumpDown(values) {\n    let index = values.length - 1;\n    let stepIndex = 0;\n    while (index >= 0) {\n        index = clampToArraySize(index, values);\n        yield values[index];\n        stepIndex++;\n        index += (stepIndex % 2 ? -2 : 1);\n    }\n}\n/**\n * Choose a random index each time\n */\nfunction* randomGen(values) {\n    while (true) {\n        const randomIndex = Math.floor(Math.random() * values.length);\n        yield values[randomIndex];\n    }\n}\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction* randomOnce(values) {\n    // create an array of indices\n    const copy = [];\n    for (let i = 0; i < values.length; i++) {\n        copy.push(i);\n    }\n    while (copy.length > 0) {\n        // random choose an index, and then remove it so it's not chosen again\n        const randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n        const index = clampToArraySize(randVal[0], values);\n        yield values[index];\n    }\n}\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\nfunction* randomWalk(values) {\n    // randomly choose a starting index in the values array\n    let index = Math.floor(Math.random() * values.length);\n    while (true) {\n        if (index === 0) {\n            index++; // at bottom of array, so force upward step\n        }\n        else if (index === values.length - 1) {\n            index--; // at top of array, so force downward step\n        }\n        else if (Math.random() < 0.5) { // else choose random downward or upward step\n            index--;\n        }\n        else {\n            index++;\n        }\n        yield values[index];\n    }\n}\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function* PatternGenerator(values, pattern = \"up\", index = 0) {\n    // safeguards\n    assert(values.length > 0, \"The array must have more than one value in it\");\n    switch (pattern) {\n        case \"up\":\n            yield* infiniteGen(values, upPatternGen);\n        case \"down\":\n            yield* infiniteGen(values, downPatternGen);\n        case \"upDown\":\n            yield* alternatingGenerator(values, true);\n        case \"downUp\":\n            yield* alternatingGenerator(values, false);\n        case \"alternateUp\":\n            yield* infiniteGen(values, jumpUp);\n        case \"alternateDown\":\n            yield* infiniteGen(values, jumpDown);\n        case \"random\":\n            yield* randomGen(values);\n        case \"randomOnce\":\n            yield* infiniteGen(values, randomOnce);\n        case \"randomWalk\":\n            yield* randomWalk(values);\n    }\n}\n//# sourceMappingURL=PatternGenerator.js.map"]},"metadata":{},"sourceType":"module"}