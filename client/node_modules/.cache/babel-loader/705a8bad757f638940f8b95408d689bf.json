{"ast":null,"code":"import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n/**\n * Some objects should not be merged\n */\n\nfunction noCopy(key, arg) {\n  return key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\nexport function deepMerge(target, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (noCopy(key, source[key])) {\n        target[key] = source[key];\n      } else if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        deepMerge(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  } // @ts-ignore\n\n\n  return deepMerge(target, ...sources);\n}\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\n\nexport function deepEquals(arrayA, arrayB) {\n  return arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n/**\n * Convert an args array into an object.\n */\n\nexport function optionsFromArguments(defaults, argsArray, keys = [], objKey) {\n  const opts = {};\n  const args = Array.from(argsArray); // if the first argument is an object and has an object key\n\n  if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n    // if it's not part of the defaults\n    const partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\n    if (!partOfDefaults) {\n      // merge that key\n      deepMerge(opts, {\n        [objKey]: args[0]\n      }); // remove the obj key from the keys\n\n      keys.splice(keys.indexOf(objKey), 1); // shift the first argument off\n\n      args.shift();\n    }\n  }\n\n  if (args.length === 1 && isObject(args[0])) {\n    deepMerge(opts, args[0]);\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      if (isDefined(args[i])) {\n        opts[keys[i]] = args[i];\n      }\n    }\n  }\n\n  return deepMerge(defaults, opts);\n}\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\n\nexport function getDefaultsFromInstance(instance) {\n  return instance.constructor.getDefaults();\n}\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\n\nexport function defaultArg(given, fallback) {\n  if (isUndef(given)) {\n    return fallback;\n  } else {\n    return given;\n  }\n}\n/**\n * Remove all of the properties belonging to omit from obj.\n */\n\nexport function omitFromObject(obj, omit) {\n  omit.forEach(prop => {\n    if (Reflect.has(obj, prop)) {\n      delete obj[prop];\n    }\n  });\n  return obj;\n}","map":{"version":3,"sources":["../../../../Tone/core/util/Defaults.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key, arg) {\n    return key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\nexport function deepMerge(target, ...sources) {\n    if (!sources.length) {\n        return target;\n    }\n    const source = sources.shift();\n    if (isObject(target) && isObject(source)) {\n        for (const key in source) {\n            if (noCopy(key, source[key])) {\n                target[key] = source[key];\n            }\n            else if (isObject(source[key])) {\n                if (!target[key]) {\n                    Object.assign(target, { [key]: {} });\n                }\n                deepMerge(target[key], source[key]);\n            }\n            else {\n                Object.assign(target, { [key]: source[key] });\n            }\n        }\n    }\n    // @ts-ignore\n    return deepMerge(target, ...sources);\n}\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals(arrayA, arrayB) {\n    return arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments(defaults, argsArray, keys = [], objKey) {\n    const opts = {};\n    const args = Array.from(argsArray);\n    // if the first argument is an object and has an object key\n    if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n        // if it's not part of the defaults\n        const partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n        if (!partOfDefaults) {\n            // merge that key\n            deepMerge(opts, { [objKey]: args[0] });\n            // remove the obj key from the keys\n            keys.splice(keys.indexOf(objKey), 1);\n            // shift the first argument off\n            args.shift();\n        }\n    }\n    if (args.length === 1 && isObject(args[0])) {\n        deepMerge(opts, args[0]);\n    }\n    else {\n        for (let i = 0; i < keys.length; i++) {\n            if (isDefined(args[i])) {\n                opts[keys[i]] = args[i];\n            }\n        }\n    }\n    return deepMerge(defaults, opts);\n}\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance(instance) {\n    return instance.constructor.getDefaults();\n}\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg(given, fallback) {\n    if (isUndef(given)) {\n        return fallback;\n    }\n    else {\n        return given;\n    }\n}\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject(obj, omit) {\n    omit.forEach(prop => {\n        if (Reflect.has(obj, prop)) {\n            delete obj[prop];\n        }\n    });\n    return obj;\n}\n//# sourceMappingURL=Defaults.js.map"]},"metadata":{},"sourceType":"module"}