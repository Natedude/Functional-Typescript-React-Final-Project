{"ast":null,"code":"import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\n\nconst verifyParameterDescriptors = parameterDescriptors => {\n  if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n    throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n  }\n};\n\nconst verifyProcessorCtor = processorCtor => {\n  if (!isConstructible(processorCtor)) {\n    throw new TypeError('The given value for processorCtor should be a constructor.');\n  }\n\n  if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n    throw new TypeError('The given value for processorCtor should have a prototype.');\n  }\n};\n\nexport const createAddAudioWorkletModule = (cacheTestResult, createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window) => {\n  let index = 0;\n  return (context, moduleURL, options = {\n    credentials: 'omit'\n  }) => {\n    const resolvedRequestsOfContext = resolvedRequests.get(context);\n\n    if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n      return Promise.resolve();\n    }\n\n    const ongoingRequestsOfContext = ongoingRequests.get(context);\n\n    if (ongoingRequestsOfContext !== undefined) {\n      const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n\n      if (promiseOfOngoingRequest !== undefined) {\n        return promiseOfOngoingRequest;\n      }\n    }\n\n    const nativeContext = getNativeContext(context); // Bug #59: Safari does not implement the audioWorklet property.\n\n    const promise = nativeContext.audioWorklet === undefined ? fetchSource(moduleURL).then(([source, absoluteUrl]) => {\n      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n      /*\n       * This is the unminified version of the code used below:\n       *\n       * ```js\n       * ${ importStatements };\n       * ((a, b) => {\n       *     (a[b] = a[b] || [ ]).push(\n       *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n       *             ${ sourceWithoutImportStatements }\n       *         }\n       *     );\n       * })(window, '_AWGS');\n       * ```\n       */\n      // tslint:disable-next-line:max-line-length\n\n      const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`; // @todo Evaluating the given source code is a possible security problem.\n\n      return evaluateSource(wrappedSource);\n    }).then(() => {\n      const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n\n      if (evaluateAudioWorkletGlobalScope === undefined) {\n        // Bug #182 Chrome, Edge and Opera do throw an instance of a SyntaxError instead of a DOMException.\n        throw new SyntaxError();\n      }\n\n      exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {}, undefined, (name, processorCtor) => {\n        if (name.trim() === '') {\n          throw createNotSupportedError();\n        }\n\n        const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n\n        if (nodeNameToProcessorConstructorMap !== undefined) {\n          if (nodeNameToProcessorConstructorMap.has(name)) {\n            throw createNotSupportedError();\n          }\n\n          verifyProcessorCtor(processorCtor);\n          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n          nodeNameToProcessorConstructorMap.set(name, processorCtor);\n        } else {\n          verifyProcessorCtor(processorCtor);\n          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n        }\n      }, nativeContext.sampleRate, undefined, undefined));\n    }) : Promise.all([fetchSource(moduleURL), Promise.resolve(cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {\n      const currentIndex = index + 1;\n      index = currentIndex;\n      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n      /*\n       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n       *\n       * This is the unminified version of the code used below.\n       *\n       * ```js\n       * class extends AudioWorkletProcessor {\n       *\n       *     __buffers = new WeakSet();\n       *\n       *     constructor () {\n       *         super();\n       *\n       *         this.port.postMessage = ((postMessage) => {\n       *             return (message, transferables) => {\n       *                 const filteredTransferables = (transferables)\n       *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n       *                     : transferables;\n       *\n       *                 return postMessage.call(this.port, message, filteredTransferables);\n       *              };\n       *         })(this.port.postMessage);\n       *     }\n       * }\n       * ```\n       */\n\n      const patchedAudioWorkletProcessor = isSupportingPostMessage ? 'AudioWorkletProcessor' : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n      /*\n       * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n       *\n       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n       *\n       * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n       *\n       * This is the unminified version of the code used below:\n       *\n       * ```js\n       * `${ importStatements };\n       * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n       * })(\n       *     ${Â patchedAudioWorkletProcessor },\n       *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n       *\n       *         __collectBuffers = (array) => {\n       *             array.forEach((element) => this.__buffers.add(element.buffer));\n       *         };\n       *\n       *         process (inputs, outputs, parameters) {\n       *             inputs.forEach(this.__collectBuffers);\n       *             outputs.forEach(this.__collectBuffers);\n       *             this.__collectBuffers(Object.values(parameters));\n       *\n       *             return super.process(\n       *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n       *                 outputs,\n       *                 parameters\n       *             );\n       *         }\n       *\n       *     })\n       * );\n       *\n       * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n       *\n       *     process () {\n       *         return false;\n       *     }\n       *\n       * })`\n       * ```\n       */\n\n      const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n      const bufferRegistration = isSupportingPostMessage ? '' : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n      const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;\n      const blob = new Blob([wrappedSource], {\n        type: 'application/javascript; charset=utf-8'\n      });\n      const url = URL.createObjectURL(blob);\n      return nativeContext.audioWorklet.addModule(url, options).then(() => {\n        if (isNativeOfflineAudioContext(nativeContext)) {\n          return nativeContext;\n        } // Bug #186: Chrome, Edge and Opera do not allow to create an AudioWorkletNode on a closed AudioContext.\n\n\n        const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n        return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);\n      }).then(nativeContextOrBackupOfflineAudioContext => {\n        if (nativeAudioWorkletNodeConstructor === null) {\n          throw new SyntaxError();\n        }\n\n        try {\n          // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n          new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`); // tslint:disable-line:no-unused-expression\n        } catch {\n          throw new SyntaxError();\n        }\n      }).finally(() => URL.revokeObjectURL(url));\n    });\n\n    if (ongoingRequestsOfContext === undefined) {\n      ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n    } else {\n      ongoingRequestsOfContext.set(moduleURL, promise);\n    }\n\n    promise.then(() => {\n      const updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n\n      if (updatedResolvedRequestsOfContext === undefined) {\n        resolvedRequests.set(context, new Set([moduleURL]));\n      } else {\n        updatedResolvedRequestsOfContext.add(moduleURL);\n      }\n    }).finally(() => {\n      const updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n\n      if (updatedOngoingRequestsOfContext !== undefined) {\n        updatedOngoingRequestsOfContext.delete(moduleURL);\n      }\n    });\n    return promise;\n  };\n};","map":{"version":3,"sources":["../../../src/factories/add-audio-worklet-module.ts"],"names":[],"mappings":"AAAA,SAAS,uCAAT,QAAwD,YAAxD;AACA,SAAS,eAAT,QAAgC,6BAAhC;AACA,SAAS,qBAAT,QAAsC,oCAAtC;;AAIA,MAAM,0BAA0B,GAAI,oBAAD,IAAoF;AACnH,MAAI,oBAAoB,KAAK,SAAzB,IAAsC,CAAC,KAAK,CAAC,OAAN,CAAc,oBAAd,CAA3C,EAAgF;AAC5E,UAAM,IAAI,SAAJ,CAAc,qFAAd,CAAN;AACH;AACJ,CAJD;;AAMA,MAAM,mBAAmB,GAAiD,aAA9C,IAAkE;AAC1F,MAAI,CAAC,eAAe,CAAC,aAAD,CAApB,EAAqC;AACjC,UAAM,IAAI,SAAJ,CAAc,4DAAd,CAAN;AACH;;AAED,MAAI,aAAa,CAAC,SAAd,KAA4B,IAA5B,IAAoC,OAAO,aAAa,CAAC,SAArB,KAAmC,QAA3E,EAAqF;AACjF,UAAM,IAAI,SAAJ,CAAc,4DAAd,CAAN;AACH;AACJ,CARD;;AAUA,OAAO,MAAM,2BAA2B,GAAkC,CACtE,eADsE,EAEtE,uBAFsE,EAGtE,cAHsE,EAItE,gCAJsE,EAKtE,WALsE,EAMtE,gBANsE,EAOtE,oCAPsE,EAQtE,2BARsE,EAStE,iCATsE,EAUtE,eAVsE,EAWtE,gBAXsE,EAYtE,2CAZsE,EAatE,MAbsE,KActE;AACA,MAAI,KAAK,GAAG,CAAZ;AAEA,SAAO,CAAC,OAAD,EAAU,SAAV,EAAqB,OAAO,GAAG;AAAE,IAAA,WAAW,EAAE;AAAf,GAA/B,KAA0D;AAC7D,UAAM,yBAAyB,GAAG,gBAAgB,CAAC,GAAjB,CAAqB,OAArB,CAAlC;;AAEA,QAAI,yBAAyB,KAAK,SAA9B,IAA2C,yBAAyB,CAAC,GAA1B,CAA8B,SAA9B,CAA/C,EAAyF;AACrF,aAAO,OAAO,CAAC,OAAR,EAAP;AACH;;AAED,UAAM,wBAAwB,GAAG,eAAe,CAAC,GAAhB,CAAoB,OAApB,CAAjC;;AAEA,QAAI,wBAAwB,KAAK,SAAjC,EAA4C;AACxC,YAAM,uBAAuB,GAAG,wBAAwB,CAAC,GAAzB,CAA6B,SAA7B,CAAhC;;AAEA,UAAI,uBAAuB,KAAK,SAAhC,EAA2C;AACvC,eAAO,uBAAP;AACH;AACJ;;AAED,UAAM,aAAa,GAAG,gBAAgB,CAAC,OAAD,CAAtC,CAjB6D,CAmB7D;;AACA,UAAM,OAAO,GACT,aAAa,CAAC,YAAd,KAA+B,SAA/B,GACM,WAAW,CAAC,SAAD,CAAX,CACK,IADL,CACU,CAAC,CAAC,MAAD,EAAS,WAAT,CAAD,KAA0B;AAC5B,YAAM,CAAC,gBAAD,EAAmB,6BAAnB,IAAoD,qBAAqB,CAAC,MAAD,EAAS,WAAT,CAA/E;AAEA;;;;;;;;;;;;;AAaG;AACH;;AACA,YAAM,aAAa,GAAG,GAAG,gBAAgB,4GAA4G,6BAA6B;AACvL,qBADK,CAlB4B,CAqB5B;;AACA,aAAO,cAAc,CAAC,aAAD,CAArB;AACH,KAxBL,EAyBK,IAzBL,CAyBU,MAAK;AACP,YAAM,+BAA+B,GAAsD,MAAO,CAAC,KAAR,CAAe,GAAf,EAA3F;;AAEA,UAAI,+BAA+B,KAAK,SAAxC,EAAmD;AAC/C;AACA,cAAM,IAAI,WAAJ,EAAN;AACH;;AAED,MAAA,gCAAgC,CAAC,aAAa,CAAC,WAAf,EAA4B,aAAa,CAAC,UAA1C,EAAsD,MAClF,+BAA+B,CAC3B,MAAM,qBAAN,CAA2B,EADA,EAE3B,SAF2B,EAG3B,CAAC,IAAD,EAAO,aAAP,KAAwB;AACpB,YAAI,IAAI,CAAC,IAAL,OAAgB,EAApB,EAAwB;AACpB,gBAAM,uBAAuB,EAA7B;AACH;;AAED,cAAM,iCAAiC,GAAG,uCAAuC,CAAC,GAAxC,CAA4C,aAA5C,CAA1C;;AAEA,YAAI,iCAAiC,KAAK,SAA1C,EAAqD;AACjD,cAAI,iCAAiC,CAAC,GAAlC,CAAsC,IAAtC,CAAJ,EAAiD;AAC7C,kBAAM,uBAAuB,EAA7B;AACH;;AAED,UAAA,mBAAmB,CAAC,aAAD,CAAnB;AACA,UAAA,0BAA0B,CAAC,aAAa,CAAC,oBAAf,CAA1B;AAEA,UAAA,iCAAiC,CAAC,GAAlC,CAAsC,IAAtC,EAA4C,aAA5C;AACH,SATD,MASO;AACH,UAAA,mBAAmB,CAAC,aAAD,CAAnB;AACA,UAAA,0BAA0B,CAAC,aAAa,CAAC,oBAAf,CAA1B;AAEA,UAAA,uCAAuC,CAAC,GAAxC,CAA4C,aAA5C,EAA2D,IAAI,GAAJ,CAAQ,CAAC,CAAC,IAAD,EAAO,aAAP,CAAD,CAAR,CAA3D;AACH;AACJ,OAzB0B,EA0B3B,aAAa,CAAC,UA1Ba,EA2B3B,SA3B2B,EA4B3B,SA5B2B,CADH,CAAhC;AAgCH,KAjEL,CADN,GAmEM,OAAO,CAAC,GAAR,CAAY,CACR,WAAW,CAAC,SAAD,CADH,EAER,OAAO,CAAC,OAAR,CACI,eAAe,CAAC,2CAAD,EAA8C,2CAA9C,CADnB,CAFQ,CAAZ,EAKG,IALH,CAKQ,CAAC,CAAC,CAAC,MAAD,EAAS,WAAT,CAAD,EAAwB,uBAAxB,CAAD,KAAqD;AACzD,YAAM,YAAY,GAAG,KAAK,GAAG,CAA7B;AAEA,MAAA,KAAK,GAAG,YAAR;AAEA,YAAM,CAAC,gBAAD,EAAmB,6BAAnB,IAAoD,qBAAqB,CAAC,MAAD,EAAS,WAAT,CAA/E;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBG;;AACH,YAAM,4BAA4B,GAAG,uBAAuB,GACtD,uBADsD,GAEtD,uLAFN;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CG;;AACH,YAAM,gBAAgB,GAAG,uBAAuB,GAAG,EAAH,GAAQ,oDAAxD;AACA,YAAM,kBAAkB,GAAG,uBAAuB,GAC5C,EAD4C,GAE5C,qEAFN;AAGA,YAAM,aAAa,GAAG,GAAG,gBAAgB,iDAAiD,6BAA6B;KACxI,4BAA4B,+CAA+C,gBAAgB,kBAAkB,kBAAkB,gGAAgG,YAAY,8DAD1N;AAEA,YAAM,IAAI,GAAG,IAAI,IAAJ,CAAS,CAAC,aAAD,CAAT,EAA0B;AAAE,QAAA,IAAI,EAAE;AAAR,OAA1B,CAAb;AACA,YAAM,GAAG,GAAG,GAAG,CAAC,eAAJ,CAAoB,IAApB,CAAZ;AAEA,aAAO,aAAa,CAAC,YAAd,CACF,SADE,CACQ,GADR,EACa,OADb,EAEF,IAFE,CAEG,MAAK;AACP,YAAI,2BAA2B,CAAC,aAAD,CAA/B,EAAgD;AAC5C,iBAAO,aAAP;AACH,SAHM,CAKP;;;AACA,cAAM,yBAAyB,GAAG,oCAAoC,CAAC,aAAD,CAAtE;AAEA,eAAO,yBAAyB,CAAC,YAA1B,CAAuC,SAAvC,CAAiD,GAAjD,EAAsD,OAAtD,EAA+D,IAA/D,CAAoE,MAAM,yBAA1E,CAAP;AACH,OAXE,EAYF,IAZE,CAYI,wCAAD,IAA6C;AAC/C,YAAI,iCAAiC,KAAK,IAA1C,EAAgD;AAC5C,gBAAM,IAAI,WAAJ,EAAN;AACH;;AAED,YAAI;AACA;AACA,cAAI,iCAAJ,CAAsC,wCAAtC,EAAgF,QAAQ,YAAY,EAApG,EAFA,CAEyG;AAC5G,SAHD,CAGE,MAAM;AACJ,gBAAM,IAAI,WAAJ,EAAN;AACH;AACJ,OAvBE,EAwBF,OAxBE,CAwBM,MAAM,GAAG,CAAC,eAAJ,CAAoB,GAApB,CAxBZ,CAAP;AAyBH,KAtHD,CApEV;;AA4LA,QAAI,wBAAwB,KAAK,SAAjC,EAA4C;AACxC,MAAA,eAAe,CAAC,GAAhB,CAAoB,OAApB,EAA6B,IAAI,GAAJ,CAAQ,CAAC,CAAC,SAAD,EAAY,OAAZ,CAAD,CAAR,CAA7B;AACH,KAFD,MAEO;AACH,MAAA,wBAAwB,CAAC,GAAzB,CAA6B,SAA7B,EAAwC,OAAxC;AACH;;AAED,IAAA,OAAO,CACF,IADL,CACU,MAAK;AACP,YAAM,gCAAgC,GAAG,gBAAgB,CAAC,GAAjB,CAAqB,OAArB,CAAzC;;AAEA,UAAI,gCAAgC,KAAK,SAAzC,EAAoD;AAChD,QAAA,gBAAgB,CAAC,GAAjB,CAAqB,OAArB,EAA8B,IAAI,GAAJ,CAAQ,CAAC,SAAD,CAAR,CAA9B;AACH,OAFD,MAEO;AACH,QAAA,gCAAgC,CAAC,GAAjC,CAAqC,SAArC;AACH;AACJ,KATL,EAUK,OAVL,CAUa,MAAK;AACV,YAAM,+BAA+B,GAAG,eAAe,CAAC,GAAhB,CAAoB,OAApB,CAAxC;;AAEA,UAAI,+BAA+B,KAAK,SAAxC,EAAmD;AAC/C,QAAA,+BAA+B,CAAC,MAAhC,CAAuC,SAAvC;AACH;AACJ,KAhBL;AAkBA,WAAO,OAAP;AACH,GAzOD;AA0OH,CA3PM","sourceRoot":"","sourcesContent":["import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nconst verifyParameterDescriptors = (parameterDescriptors) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\nconst verifyProcessorCtor = (processorCtor) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\nexport const createAddAudioWorkletModule = (cacheTestResult, createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window) => {\n    let index = 0;\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n        const nativeContext = getNativeContext(context);\n        // Bug #59: Safari does not implement the audioWorklet property.\n        const promise = nativeContext.audioWorklet === undefined\n            ? fetchSource(moduleURL)\n                .then(([source, absoluteUrl]) => {\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * ${ importStatements };\n                 * ((a, b) => {\n                 *     (a[b] = a[b] || [ ]).push(\n                 *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n                 *             ${ sourceWithoutImportStatements }\n                 *         }\n                 *     );\n                 * })(window, '_AWGS');\n                 * ```\n                 */\n                // tslint:disable-next-line:max-line-length\n                const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n                // @todo Evaluating the given source code is a possible security problem.\n                return evaluateSource(wrappedSource);\n            })\n                .then(() => {\n                const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n                if (evaluateAudioWorkletGlobalScope === undefined) {\n                    // Bug #182 Chrome, Edge and Opera do throw an instance of a SyntaxError instead of a DOMException.\n                    throw new SyntaxError();\n                }\n                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {\n                }, undefined, (name, processorCtor) => {\n                    if (name.trim() === '') {\n                        throw createNotSupportedError();\n                    }\n                    const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n                    if (nodeNameToProcessorConstructorMap !== undefined) {\n                        if (nodeNameToProcessorConstructorMap.has(name)) {\n                            throw createNotSupportedError();\n                        }\n                        verifyProcessorCtor(processorCtor);\n                        verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                        nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                    }\n                    else {\n                        verifyProcessorCtor(processorCtor);\n                        verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                        NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                    }\n                }, nativeContext.sampleRate, undefined, undefined));\n            })\n            : Promise.all([\n                fetchSource(moduleURL),\n                Promise.resolve(cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))\n            ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {\n                const currentIndex = index + 1;\n                index = currentIndex;\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                 *\n                 * This is the unminified version of the code used below.\n                 *\n                 * ```js\n                 * class extends AudioWorkletProcessor {\n                 *\n                 *     __buffers = new WeakSet();\n                 *\n                 *     constructor () {\n                 *         super();\n                 *\n                 *         this.port.postMessage = ((postMessage) => {\n                 *             return (message, transferables) => {\n                 *                 const filteredTransferables = (transferables)\n                 *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n                 *                     : transferables;\n                 *\n                 *                 return postMessage.call(this.port, message, filteredTransferables);\n                 *              };\n                 *         })(this.port.postMessage);\n                 *     }\n                 * }\n                 * ```\n                 */\n                const patchedAudioWorkletProcessor = isSupportingPostMessage\n                    ? 'AudioWorkletProcessor'\n                    : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n                /*\n                 * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n                 *\n                 * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                 *\n                 * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                 *\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * `${ importStatements };\n                 * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n                 * })(\n                 *     ${Â patchedAudioWorkletProcessor },\n                 *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                 *\n                 *         __collectBuffers = (array) => {\n                 *             array.forEach((element) => this.__buffers.add(element.buffer));\n                 *         };\n                 *\n                 *         process (inputs, outputs, parameters) {\n                 *             inputs.forEach(this.__collectBuffers);\n                 *             outputs.forEach(this.__collectBuffers);\n                 *             this.__collectBuffers(Object.values(parameters));\n                 *\n                 *             return super.process(\n                 *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                 *                 outputs,\n                 *                 parameters\n                 *             );\n                 *         }\n                 *\n                 *     })\n                 * );\n                 *\n                 * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n                 *\n                 *     process () {\n                 *         return false;\n                 *     }\n                 *\n                 * })`\n                 * ```\n                 */\n                const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n                const bufferRegistration = isSupportingPostMessage\n                    ? ''\n                    : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n                const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;\n                const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                const url = URL.createObjectURL(blob);\n                return nativeContext.audioWorklet\n                    .addModule(url, options)\n                    .then(() => {\n                    if (isNativeOfflineAudioContext(nativeContext)) {\n                        return nativeContext;\n                    }\n                    // Bug #186: Chrome, Edge and Opera do not allow to create an AudioWorkletNode on a closed AudioContext.\n                    const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n                    return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);\n                })\n                    .then((nativeContextOrBackupOfflineAudioContext) => {\n                    if (nativeAudioWorkletNodeConstructor === null) {\n                        throw new SyntaxError();\n                    }\n                    try {\n                        // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                        new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`); // tslint:disable-line:no-unused-expression\n                    }\n                    catch {\n                        throw new SyntaxError();\n                    }\n                })\n                    .finally(() => URL.revokeObjectURL(url));\n            });\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        }\n        else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n        promise\n            .then(() => {\n            const updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n            if (updatedResolvedRequestsOfContext === undefined) {\n                resolvedRequests.set(context, new Set([moduleURL]));\n            }\n            else {\n                updatedResolvedRequestsOfContext.add(moduleURL);\n            }\n        })\n            .finally(() => {\n            const updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n            if (updatedOngoingRequestsOfContext !== undefined) {\n                updatedOngoingRequestsOfContext.delete(moduleURL);\n            }\n        });\n        return promise;\n    };\n};\n//# sourceMappingURL=add-audio-worklet-module.js.map"]},"metadata":{},"sourceType":"module"}