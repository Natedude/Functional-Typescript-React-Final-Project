{"ast":null,"code":"import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = nativeAudioNode => {\n  const connections = new Map();\n\n  nativeAudioNode.connect = (connect => {\n    // tslint:disable-next-line:invalid-void\n    return (destination, output = 0, input = 0) => {\n      const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output); // Save the new connection only if the calls to connect above didn't throw an error.\n\n      const connectionsToDestination = connections.get(destination);\n\n      if (connectionsToDestination === undefined) {\n        connections.set(destination, [{\n          input,\n          output\n        }]);\n      } else {\n        if (connectionsToDestination.every(connection => connection.input !== input || connection.output !== output)) {\n          connectionsToDestination.push({\n            input,\n            output\n          });\n        }\n      }\n\n      return returnValue;\n    };\n  })(nativeAudioNode.connect.bind(nativeAudioNode));\n\n  nativeAudioNode.disconnect = (disconnect => {\n    return (destinationOrOutput, output, input) => {\n      disconnect.apply(nativeAudioNode);\n\n      if (destinationOrOutput === undefined) {\n        connections.clear();\n      } else if (typeof destinationOrOutput === 'number') {\n        for (const [destination, connectionsToDestination] of connections) {\n          const filteredConnections = connectionsToDestination.filter(connection => connection.output !== destinationOrOutput);\n\n          if (filteredConnections.length === 0) {\n            connections.delete(destination);\n          } else {\n            connections.set(destination, filteredConnections);\n          }\n        }\n      } else if (connections.has(destinationOrOutput)) {\n        if (output === undefined) {\n          connections.delete(destinationOrOutput);\n        } else {\n          const connectionsToDestination = connections.get(destinationOrOutput);\n\n          if (connectionsToDestination !== undefined) {\n            const filteredConnections = connectionsToDestination.filter(connection => connection.output !== output && (connection.input !== input || input === undefined));\n\n            if (filteredConnections.length === 0) {\n              connections.delete(destinationOrOutput);\n            } else {\n              connections.set(destinationOrOutput, filteredConnections);\n            }\n          }\n        }\n      }\n\n      for (const [destination, connectionsToDestination] of connections) {\n        connectionsToDestination.forEach(connection => {\n          if (isNativeAudioNode(destination)) {\n            nativeAudioNode.connect(destination, connection.output, connection.input);\n          } else {\n            nativeAudioNode.connect(destination, connection.output);\n          }\n        });\n      }\n    };\n  })(nativeAudioNode.disconnect);\n};","map":{"version":3,"sources":["../../../src/helpers/wrap-audio-node-disconnect-method.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {\n    const connections = new Map();\n    nativeAudioNode.connect = ((connect) => {\n        // tslint:disable-next-line:invalid-void\n        return (destination, output = 0, input = 0) => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            }\n            else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput, output, input) => {\n            disconnect.apply(nativeAudioNode);\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    }\n                    else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            }\n            else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                }\n                else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== output && (connection.input !== input || input === undefined));\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        }\n                        else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    }\n                    else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n//# sourceMappingURL=wrap-audio-node-disconnect-method.js.map"]},"metadata":{},"sourceType":"module"}