{"ast":null,"code":"import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nexport const createDetectCycles = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n  return function detectCycles(chain, nextLink) {\n    const audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey(audioParamAudioNodeStore, nextLink);\n\n    if (isDelayNode(audioNode)) {\n      return [];\n    }\n\n    if (chain[0] === audioNode) {\n      return [chain];\n    }\n\n    if (chain.includes(audioNode)) {\n      return [];\n    }\n\n    const {\n      outputs\n    } = getAudioNodeConnections(audioNode);\n    return Array.from(outputs).map(outputConnection => detectCycles([...chain, audioNode], outputConnection[0])).reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n  };\n};","map":{"version":3,"sources":["../../../src/factories/detect-cycles.ts"],"names":[],"mappings":"AAAA,SAAS,WAAT,QAA4B,sBAA5B;AACA,SAAS,WAAT,QAA4B,sBAA5B;AAIA,OAAO,MAAM,kBAAkB,GAAyB,CAAC,wBAAD,EAA2B,uBAA3B,EAAoD,cAApD,KAAsE;AAC1H,SAAO,SAAS,YAAT,CAA0C,KAA1C,EAAkE,QAAlE,EAAuG;AAC1G,UAAM,SAAS,GAAG,WAAW,CAAC,QAAD,CAAX,GAAwB,QAAxB,GAAkD,cAAc,CAAC,wBAAD,EAA2B,QAA3B,CAAlF;;AAEA,QAAI,WAAW,CAAC,SAAD,CAAf,EAA4B;AACxB,aAAO,EAAP;AACH;;AAED,QAAI,KAAK,CAAC,CAAD,CAAL,KAAa,SAAjB,EAA4B;AACxB,aAAO,CAAC,KAAD,CAAP;AACH;;AAED,QAAI,KAAK,CAAC,QAAN,CAAe,SAAf,CAAJ,EAA+B;AAC3B,aAAO,EAAP;AACH;;AAED,UAAM;AAAE,MAAA;AAAF,QAAc,uBAAuB,CAAC,SAAD,CAA3C;AAEA,WAAO,KAAK,CAAC,IAAN,CAAW,OAAX,EACF,GADE,CACG,gBAAD,IAAsB,YAAY,CAAC,CAAC,GAAG,KAAJ,EAAW,SAAX,CAAD,EAAwB,gBAAgB,CAAC,CAAD,CAAxC,CADpC,EAEF,MAFE,CAEK,CAAC,YAAD,EAAe,YAAf,KAAgC,YAAY,CAAC,MAAb,CAAoB,YAApB,CAFrC,EAEwE,EAFxE,CAAP;AAGH,GApBD;AAqBH,CAtBM","sourceRoot":"","sourcesContent":["import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nexport const createDetectCycles = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles(chain, nextLink) {\n        const audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey(audioParamAudioNodeStore, nextLink);\n        if (isDelayNode(audioNode)) {\n            return [];\n        }\n        if (chain[0] === audioNode) {\n            return [chain];\n        }\n        if (chain.includes(audioNode)) {\n            return [];\n        }\n        const { outputs } = getAudioNodeConnections(audioNode);\n        return Array.from(outputs)\n            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))\n            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n    };\n};\n//# sourceMappingURL=detect-cycles.js.map"]},"metadata":{},"sourceType":"module"}