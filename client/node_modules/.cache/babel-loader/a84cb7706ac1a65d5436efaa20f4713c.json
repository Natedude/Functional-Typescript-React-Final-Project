{"ast":null,"code":"import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 1,\n  numberOfOutputs: 1,\n  parameterData: {},\n  processorOptions: {}\n};\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) => {\n  return class AudioWorkletNode extends audioNodeConstructor {\n    constructor(context, name, options) {\n      var _a;\n\n      const nativeContext = getNativeContext(context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS,\n        ...options\n      }); // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n\n      testAudioWorkletNodeOptionsClonability(mergedOptions);\n      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n      const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name); // Bug #186: Chrome, Edge and Opera do not allow to create an AudioWorkletNode on a closed AudioContext.\n\n      const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== 'closed' ? nativeContext : (_a = getBackupOfflineAudioContext(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;\n      const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n      const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n      /*\n       * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n       * returns false.\n       */\n\n      super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n      const parameters = [];\n      nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n        const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n        parameters.push([nm, audioParam]);\n      });\n      this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n      this._onprocessorerror = null;\n      this._parameters = new ReadOnlyMap(parameters);\n      /*\n       * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n       * the destination.\n       */\n\n      if (isOffline) {\n        addUnrenderedAudioWorkletNode(nativeContext, this);\n      }\n\n      const {\n        activeInputs\n      } = getAudioNodeConnections(this);\n      setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n    }\n\n    get onprocessorerror() {\n      return this._onprocessorerror;\n    }\n\n    set onprocessorerror(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n      const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n      this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n    }\n\n    get parameters() {\n      if (this._parameters === null) {\n        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n        return this._nativeAudioWorkletNode.parameters;\n      }\n\n      return this._parameters;\n    }\n\n    get port() {\n      return this._nativeAudioWorkletNode.port;\n    }\n\n  };\n};","map":{"version":3,"sources":["../../../src/factories/audio-worklet-node-constructor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    parameterData: {},\n    processorOptions: {}\n};\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) => {\n    return class AudioWorkletNode extends audioNodeConstructor {\n        constructor(context, name, options) {\n            var _a;\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS, ...options });\n            // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n            testAudioWorkletNodeOptionsClonability(mergedOptions);\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name);\n            // Bug #186: Chrome, Edge and Opera do not allow to create an AudioWorkletNode on a closed AudioContext.\n            const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== 'closed'\n                ? nativeContext\n                : (_a = getBackupOfflineAudioContext(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null));\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, this);\n            }\n            const { activeInputs } = getAudioNodeConnections(this);\n            setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=audio-worklet-node-constructor.js.map"]},"metadata":{},"sourceType":"module"}