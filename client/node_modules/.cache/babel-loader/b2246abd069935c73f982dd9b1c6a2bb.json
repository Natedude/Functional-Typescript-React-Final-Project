{"ast":null,"code":"import { Tone } from \"../Tone\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck\";\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n */\n\nexport class TimeBaseClass extends Tone {\n  /**\n   * @param context The context associated with the time value. Used to compute\n   * Transport and context-relative timing.\n   * @param  value  The time value as a number, string or object\n   * @param  units  Unit values\n   */\n  constructor(context, value, units) {\n    super();\n    /**\n     * The default units\n     */\n\n    this.defaultUnits = \"s\";\n    this._val = value;\n    this._units = units;\n    this.context = context;\n    this._expressions = this._getExpressions();\n  }\n  /**\n   * All of the time encoding expressions\n   */\n\n\n  _getExpressions() {\n    return {\n      hz: {\n        method: value => {\n          return this._frequencyToUnits(parseFloat(value));\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?)hz$/i\n      },\n      i: {\n        method: value => {\n          return this._ticksToUnits(parseInt(value, 10));\n        },\n        regexp: /^(\\d+)i$/i\n      },\n      m: {\n        method: value => {\n          return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n        },\n        regexp: /^(\\d+)m$/i\n      },\n      n: {\n        method: (value, dot) => {\n          const numericValue = parseInt(value, 10);\n          const scalar = dot === \".\" ? 1.5 : 1;\n\n          if (numericValue === 1) {\n            return this._beatsToUnits(this._getTimeSignature()) * scalar;\n          } else {\n            return this._beatsToUnits(4 / numericValue) * scalar;\n          }\n        },\n        regexp: /^(\\d+)n(\\.?)$/i\n      },\n      number: {\n        method: value => {\n          return this._expressions[this.defaultUnits].method.call(this, value);\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?)$/\n      },\n      s: {\n        method: value => {\n          return this._secondsToUnits(parseFloat(value));\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?)s$/\n      },\n      samples: {\n        method: value => {\n          return parseInt(value, 10) / this.context.sampleRate;\n        },\n        regexp: /^(\\d+)samples$/\n      },\n      t: {\n        method: value => {\n          const numericValue = parseInt(value, 10);\n          return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n        },\n        regexp: /^(\\d+)t$/i\n      },\n      tr: {\n        method: (m, q, s) => {\n          let total = 0;\n\n          if (m && m !== \"0\") {\n            total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n          }\n\n          if (q && q !== \"0\") {\n            total += this._beatsToUnits(parseFloat(q));\n          }\n\n          if (s && s !== \"0\") {\n            total += this._beatsToUnits(parseFloat(s) / 4);\n          }\n\n          return total;\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/\n      }\n    };\n  } //-------------------------------------\n  // \tVALUE OF\n  //-------------------------------------\n\n  /**\n   * Evaluate the time value. Returns the time in seconds.\n   */\n\n\n  valueOf() {\n    if (this._val instanceof TimeBaseClass) {\n      this.fromType(this._val);\n    }\n\n    if (isUndef(this._val)) {\n      return this._noArg();\n    } else if (isString(this._val) && isUndef(this._units)) {\n      for (const units in this._expressions) {\n        if (this._expressions[units].regexp.test(this._val.trim())) {\n          this._units = units;\n          break;\n        }\n      }\n    } else if (isObject(this._val)) {\n      let total = 0;\n\n      for (const typeName in this._val) {\n        if (isDefined(this._val[typeName])) {\n          const quantity = this._val[typeName]; // @ts-ignore\n\n          const time = new this.constructor(this.context, typeName).valueOf() * quantity;\n          total += time;\n        }\n      }\n\n      return total;\n    }\n\n    if (isDefined(this._units)) {\n      const expr = this._expressions[this._units];\n\n      const matching = this._val.toString().trim().match(expr.regexp);\n\n      if (matching) {\n        return expr.method.apply(this, matching.slice(1));\n      } else {\n        return expr.method.call(this, this._val);\n      }\n    } else if (isString(this._val)) {\n      return parseFloat(this._val);\n    } else {\n      return this._val;\n    }\n  } //-------------------------------------\n  // \tUNIT CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Returns the value of a frequency in the current units\n   */\n\n\n  _frequencyToUnits(freq) {\n    return 1 / freq;\n  }\n  /**\n   * Return the value of the beats in the current units\n   */\n\n\n  _beatsToUnits(beats) {\n    return 60 / this._getBpm() * beats;\n  }\n  /**\n   * Returns the value of a second in the current units\n   */\n\n\n  _secondsToUnits(seconds) {\n    return seconds;\n  }\n  /**\n   * Returns the value of a tick in the current time units\n   */\n\n\n  _ticksToUnits(ticks) {\n    return ticks * this._beatsToUnits(1) / this._getPPQ();\n  }\n  /**\n   * With no arguments, return 'now'\n   */\n\n\n  _noArg() {\n    return this._now();\n  } //-------------------------------------\n  // \tTEMPO CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Return the bpm\n   */\n\n\n  _getBpm() {\n    return this.context.transport.bpm.value;\n  }\n  /**\n   * Return the timeSignature\n   */\n\n\n  _getTimeSignature() {\n    return this.context.transport.timeSignature;\n  }\n  /**\n   * Return the PPQ or 192 if Transport is not available\n   */\n\n\n  _getPPQ() {\n    return this.context.transport.PPQ;\n  } //-------------------------------------\n  // \tCONVERSION INTERFACE\n  //-------------------------------------\n\n  /**\n   * Coerce a time type into this units type.\n   * @param type Any time type units\n   */\n\n\n  fromType(type) {\n    this._units = undefined;\n\n    switch (this.defaultUnits) {\n      case \"s\":\n        this._val = type.toSeconds();\n        break;\n\n      case \"i\":\n        this._val = type.toTicks();\n        break;\n\n      case \"hz\":\n        this._val = type.toFrequency();\n        break;\n\n      case \"midi\":\n        this._val = type.toMidi();\n        break;\n    }\n\n    return this;\n  }\n  /**\n   * Return the value in hertz\n   */\n\n\n  toFrequency() {\n    return 1 / this.toSeconds();\n  }\n  /**\n   * Return the time in samples\n   */\n\n\n  toSamples() {\n    return this.toSeconds() * this.context.sampleRate;\n  }\n  /**\n   * Return the time in milliseconds.\n   */\n\n\n  toMilliseconds() {\n    return this.toSeconds() * 1000;\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/core/type/TimeBase.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Tone } from \"../Tone\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck\";\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n */\nexport class TimeBaseClass extends Tone {\n    /**\n     * @param context The context associated with the time value. Used to compute\n     * Transport and context-relative timing.\n     * @param  value  The time value as a number, string or object\n     * @param  units  Unit values\n     */\n    constructor(context, value, units) {\n        super();\n        /**\n         * The default units\n         */\n        this.defaultUnits = \"s\";\n        this._val = value;\n        this._units = units;\n        this.context = context;\n        this._expressions = this._getExpressions();\n    }\n    /**\n     * All of the time encoding expressions\n     */\n    _getExpressions() {\n        return {\n            hz: {\n                method: (value) => {\n                    return this._frequencyToUnits(parseFloat(value));\n                },\n                regexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n            },\n            i: {\n                method: (value) => {\n                    return this._ticksToUnits(parseInt(value, 10));\n                },\n                regexp: /^(\\d+)i$/i,\n            },\n            m: {\n                method: (value) => {\n                    return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n                },\n                regexp: /^(\\d+)m$/i,\n            },\n            n: {\n                method: (value, dot) => {\n                    const numericValue = parseInt(value, 10);\n                    const scalar = dot === \".\" ? 1.5 : 1;\n                    if (numericValue === 1) {\n                        return this._beatsToUnits(this._getTimeSignature()) * scalar;\n                    }\n                    else {\n                        return this._beatsToUnits(4 / numericValue) * scalar;\n                    }\n                },\n                regexp: /^(\\d+)n(\\.?)$/i,\n            },\n            number: {\n                method: (value) => {\n                    return this._expressions[this.defaultUnits].method.call(this, value);\n                },\n                regexp: /^(\\d+(?:\\.\\d+)?)$/,\n            },\n            s: {\n                method: (value) => {\n                    return this._secondsToUnits(parseFloat(value));\n                },\n                regexp: /^(\\d+(?:\\.\\d+)?)s$/,\n            },\n            samples: {\n                method: (value) => {\n                    return parseInt(value, 10) / this.context.sampleRate;\n                },\n                regexp: /^(\\d+)samples$/,\n            },\n            t: {\n                method: (value) => {\n                    const numericValue = parseInt(value, 10);\n                    return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n                },\n                regexp: /^(\\d+)t$/i,\n            },\n            tr: {\n                method: (m, q, s) => {\n                    let total = 0;\n                    if (m && m !== \"0\") {\n                        total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n                    }\n                    if (q && q !== \"0\") {\n                        total += this._beatsToUnits(parseFloat(q));\n                    }\n                    if (s && s !== \"0\") {\n                        total += this._beatsToUnits(parseFloat(s) / 4);\n                    }\n                    return total;\n                },\n                regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n            },\n        };\n    }\n    //-------------------------------------\n    // \tVALUE OF\n    //-------------------------------------\n    /**\n     * Evaluate the time value. Returns the time in seconds.\n     */\n    valueOf() {\n        if (this._val instanceof TimeBaseClass) {\n            this.fromType(this._val);\n        }\n        if (isUndef(this._val)) {\n            return this._noArg();\n        }\n        else if (isString(this._val) && isUndef(this._units)) {\n            for (const units in this._expressions) {\n                if (this._expressions[units].regexp.test(this._val.trim())) {\n                    this._units = units;\n                    break;\n                }\n            }\n        }\n        else if (isObject(this._val)) {\n            let total = 0;\n            for (const typeName in this._val) {\n                if (isDefined(this._val[typeName])) {\n                    const quantity = this._val[typeName];\n                    // @ts-ignore\n                    const time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n                    total += time;\n                }\n            }\n            return total;\n        }\n        if (isDefined(this._units)) {\n            const expr = this._expressions[this._units];\n            const matching = this._val.toString().trim().match(expr.regexp);\n            if (matching) {\n                return expr.method.apply(this, matching.slice(1));\n            }\n            else {\n                return expr.method.call(this, this._val);\n            }\n        }\n        else if (isString(this._val)) {\n            return parseFloat(this._val);\n        }\n        else {\n            return this._val;\n        }\n    }\n    //-------------------------------------\n    // \tUNIT CONVERSIONS\n    //-------------------------------------\n    /**\n     * Returns the value of a frequency in the current units\n     */\n    _frequencyToUnits(freq) {\n        return 1 / freq;\n    }\n    /**\n     * Return the value of the beats in the current units\n     */\n    _beatsToUnits(beats) {\n        return (60 / this._getBpm()) * beats;\n    }\n    /**\n     * Returns the value of a second in the current units\n     */\n    _secondsToUnits(seconds) {\n        return seconds;\n    }\n    /**\n     * Returns the value of a tick in the current time units\n     */\n    _ticksToUnits(ticks) {\n        return (ticks * (this._beatsToUnits(1)) / this._getPPQ());\n    }\n    /**\n     * With no arguments, return 'now'\n     */\n    _noArg() {\n        return this._now();\n    }\n    //-------------------------------------\n    // \tTEMPO CONVERSIONS\n    //-------------------------------------\n    /**\n     * Return the bpm\n     */\n    _getBpm() {\n        return this.context.transport.bpm.value;\n    }\n    /**\n     * Return the timeSignature\n     */\n    _getTimeSignature() {\n        return this.context.transport.timeSignature;\n    }\n    /**\n     * Return the PPQ or 192 if Transport is not available\n     */\n    _getPPQ() {\n        return this.context.transport.PPQ;\n    }\n    //-------------------------------------\n    // \tCONVERSION INTERFACE\n    //-------------------------------------\n    /**\n     * Coerce a time type into this units type.\n     * @param type Any time type units\n     */\n    fromType(type) {\n        this._units = undefined;\n        switch (this.defaultUnits) {\n            case \"s\":\n                this._val = type.toSeconds();\n                break;\n            case \"i\":\n                this._val = type.toTicks();\n                break;\n            case \"hz\":\n                this._val = type.toFrequency();\n                break;\n            case \"midi\":\n                this._val = type.toMidi();\n                break;\n        }\n        return this;\n    }\n    /**\n     * Return the value in hertz\n     */\n    toFrequency() {\n        return 1 / this.toSeconds();\n    }\n    /**\n     * Return the time in samples\n     */\n    toSamples() {\n        return this.toSeconds() * this.context.sampleRate;\n    }\n    /**\n     * Return the time in milliseconds.\n     */\n    toMilliseconds() {\n        return this.toSeconds() * 1000;\n    }\n}\n//# sourceMappingURL=TimeBase.js.map"]},"metadata":{},"sourceType":"module"}