{"ast":null,"code":"import { Signal } from \"./Signal\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n/**\n * Adds the ability to synchronize the signal to the [[Transport]]\n */\n\nexport class SyncedSignal extends Signal {\n  constructor() {\n    super(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n    this.name = \"SyncedSignal\";\n    /**\n     * Don't override when something is connected to the input\n     */\n\n    this.override = false;\n    const options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]);\n    this._lastVal = options.value;\n    this._synced = this.context.transport.scheduleRepeat(this._onTick.bind(this), \"1i\");\n    this._syncedCallback = this._anchorValue.bind(this);\n    this.context.transport.on(\"start\", this._syncedCallback);\n    this.context.transport.on(\"pause\", this._syncedCallback);\n    this.context.transport.on(\"stop\", this._syncedCallback); // disconnect the constant source from the output and replace it with another one\n\n    this._constantSource.disconnect();\n\n    this._constantSource.stop(0); // create a new one\n\n\n    this._constantSource = this.output = new ToneConstantSource({\n      context: this.context,\n      offset: options.value,\n      units: options.units\n    }).start(0);\n    this.setValueAtTime(options.value, 0);\n  }\n  /**\n   * Callback which is invoked every tick.\n   */\n\n\n  _onTick(time) {\n    const val = super.getValueAtTime(this.context.transport.seconds); // approximate ramp curves with linear ramps\n\n    if (this._lastVal !== val) {\n      this._lastVal = val;\n\n      this._constantSource.offset.setValueAtTime(val, time);\n    }\n  }\n  /**\n   * Anchor the value at the start and stop of the Transport\n   */\n\n\n  _anchorValue(time) {\n    const val = super.getValueAtTime(this.context.transport.seconds);\n    this._lastVal = val;\n\n    this._constantSource.offset.cancelAndHoldAtTime(time);\n\n    this._constantSource.offset.setValueAtTime(val, time);\n  }\n\n  getValueAtTime(time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    return super.getValueAtTime(computedTime);\n  }\n\n  setValueAtTime(value, time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.setValueAtTime(value, computedTime);\n    return this;\n  }\n\n  linearRampToValueAtTime(value, time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.linearRampToValueAtTime(value, computedTime);\n    return this;\n  }\n\n  exponentialRampToValueAtTime(value, time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.exponentialRampToValueAtTime(value, computedTime);\n    return this;\n  }\n\n  setTargetAtTime(value, startTime, timeConstant) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.setTargetAtTime(value, computedTime, timeConstant);\n    return this;\n  }\n\n  cancelScheduledValues(startTime) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.cancelScheduledValues(computedTime);\n    return this;\n  }\n\n  setValueCurveAtTime(values, startTime, duration, scaling) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    duration = this.toSeconds(duration);\n    super.setValueCurveAtTime(values, computedTime, duration, scaling);\n    return this;\n  }\n\n  cancelAndHoldAtTime(time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.cancelAndHoldAtTime(computedTime);\n    return this;\n  }\n\n  setRampPoint(time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.setRampPoint(computedTime);\n    return this;\n  }\n\n  exponentialRampTo(value, rampTime, startTime) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.exponentialRampTo(value, rampTime, computedTime);\n    return this;\n  }\n\n  linearRampTo(value, rampTime, startTime) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.linearRampTo(value, rampTime, computedTime);\n    return this;\n  }\n\n  targetRampTo(value, rampTime, startTime) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.targetRampTo(value, rampTime, computedTime);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n    this.context.transport.clear(this._synced);\n    this.context.transport.off(\"start\", this._syncedCallback);\n    this.context.transport.off(\"pause\", this._syncedCallback);\n    this.context.transport.off(\"stop\", this._syncedCallback);\n\n    this._constantSource.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/signal/SyncedSignal.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Signal } from \"./Signal\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n/**\n * Adds the ability to synchronize the signal to the [[Transport]]\n */\nexport class SyncedSignal extends Signal {\n    constructor() {\n        super(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n        this.name = \"SyncedSignal\";\n        /**\n         * Don't override when something is connected to the input\n         */\n        this.override = false;\n        const options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]);\n        this._lastVal = options.value;\n        this._synced = this.context.transport.scheduleRepeat(this._onTick.bind(this), \"1i\");\n        this._syncedCallback = this._anchorValue.bind(this);\n        this.context.transport.on(\"start\", this._syncedCallback);\n        this.context.transport.on(\"pause\", this._syncedCallback);\n        this.context.transport.on(\"stop\", this._syncedCallback);\n        // disconnect the constant source from the output and replace it with another one\n        this._constantSource.disconnect();\n        this._constantSource.stop(0);\n        // create a new one\n        this._constantSource = this.output = new ToneConstantSource({\n            context: this.context,\n            offset: options.value,\n            units: options.units,\n        }).start(0);\n        this.setValueAtTime(options.value, 0);\n    }\n    /**\n     * Callback which is invoked every tick.\n     */\n    _onTick(time) {\n        const val = super.getValueAtTime(this.context.transport.seconds);\n        // approximate ramp curves with linear ramps\n        if (this._lastVal !== val) {\n            this._lastVal = val;\n            this._constantSource.offset.setValueAtTime(val, time);\n        }\n    }\n    /**\n     * Anchor the value at the start and stop of the Transport\n     */\n    _anchorValue(time) {\n        const val = super.getValueAtTime(this.context.transport.seconds);\n        this._lastVal = val;\n        this._constantSource.offset.cancelAndHoldAtTime(time);\n        this._constantSource.offset.setValueAtTime(val, time);\n    }\n    getValueAtTime(time) {\n        const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n        return super.getValueAtTime(computedTime);\n    }\n    setValueAtTime(value, time) {\n        const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n        super.setValueAtTime(value, computedTime);\n        return this;\n    }\n    linearRampToValueAtTime(value, time) {\n        const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n        super.linearRampToValueAtTime(value, computedTime);\n        return this;\n    }\n    exponentialRampToValueAtTime(value, time) {\n        const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n        super.exponentialRampToValueAtTime(value, computedTime);\n        return this;\n    }\n    setTargetAtTime(value, startTime, timeConstant) {\n        const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n        super.setTargetAtTime(value, computedTime, timeConstant);\n        return this;\n    }\n    cancelScheduledValues(startTime) {\n        const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n        super.cancelScheduledValues(computedTime);\n        return this;\n    }\n    setValueCurveAtTime(values, startTime, duration, scaling) {\n        const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n        duration = this.toSeconds(duration);\n        super.setValueCurveAtTime(values, computedTime, duration, scaling);\n        return this;\n    }\n    cancelAndHoldAtTime(time) {\n        const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n        super.cancelAndHoldAtTime(computedTime);\n        return this;\n    }\n    setRampPoint(time) {\n        const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n        super.setRampPoint(computedTime);\n        return this;\n    }\n    exponentialRampTo(value, rampTime, startTime) {\n        const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n        super.exponentialRampTo(value, rampTime, computedTime);\n        return this;\n    }\n    linearRampTo(value, rampTime, startTime) {\n        const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n        super.linearRampTo(value, rampTime, computedTime);\n        return this;\n    }\n    targetRampTo(value, rampTime, startTime) {\n        const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n        super.targetRampTo(value, rampTime, computedTime);\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this.context.transport.clear(this._synced);\n        this.context.transport.off(\"start\", this._syncedCallback);\n        this.context.transport.off(\"pause\", this._syncedCallback);\n        this.context.transport.off(\"stop\", this._syncedCallback);\n        this._constantSource.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=SyncedSignal.js.map"]},"metadata":{},"sourceType":"module"}