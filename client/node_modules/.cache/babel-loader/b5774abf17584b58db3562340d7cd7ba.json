{"ast":null,"code":"import { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\n\nexport class Param extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n    this.name = \"Param\";\n    this.overridden = false;\n    /**\n     * The minimum output value\n     */\n\n    this._minOutput = 1e-7;\n    const options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n    assert(isDefined(options.param) && (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n    while (!isAudioParam(options.param)) {\n      options.param = options.param._param;\n    }\n\n    this._swappable = isDefined(options.swappable) ? options.swappable : false;\n\n    if (this._swappable) {\n      this.input = this.context.createGain(); // initialize\n\n      this._param = options.param;\n      this.input.connect(this._param);\n    } else {\n      this._param = this.input = options.param;\n    }\n\n    this._events = new Timeline(1000);\n    this._initialValue = this._param.defaultValue;\n    this.units = options.units;\n    this.convert = options.convert;\n    this._minValue = options.minValue;\n    this._maxValue = options.maxValue; // if the value is defined, set it immediately\n\n    if (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n      this.setValueAtTime(options.value, 0);\n    }\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      convert: true,\n      units: \"number\"\n    });\n  }\n\n  get value() {\n    const now = this.now();\n    return this.getValueAtTime(now);\n  }\n\n  set value(value) {\n    this.cancelScheduledValues(this.now());\n    this.setValueAtTime(value, this.now());\n  }\n\n  get minValue() {\n    // if it's not the default minValue, return it\n    if (isDefined(this._minValue)) {\n      return this._minValue;\n    } else if (this.units === \"time\" || this.units === \"frequency\" || this.units === \"normalRange\" || this.units === \"positive\" || this.units === \"transportTime\" || this.units === \"ticks\" || this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n      return 0;\n    } else if (this.units === \"audioRange\") {\n      return -1;\n    } else if (this.units === \"decibels\") {\n      return -Infinity;\n    } else {\n      return this._param.minValue;\n    }\n  }\n\n  get maxValue() {\n    if (isDefined(this._maxValue)) {\n      return this._maxValue;\n    } else if (this.units === \"normalRange\" || this.units === \"audioRange\") {\n      return 1;\n    } else {\n      return this._param.maxValue;\n    }\n  }\n  /**\n   * Type guard based on the unit name\n   */\n\n\n  _is(arg, type) {\n    return this.units === type;\n  }\n  /**\n   * Make sure the value is always in the defined range\n   */\n\n\n  _assertRange(value) {\n    if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n      assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n    }\n\n    return value;\n  }\n  /**\n   * Convert the given value from the type specified by Param.units\n   * into the destination value (such as Gain or Frequency).\n   */\n\n\n  _fromType(val) {\n    if (this.convert && !this.overridden) {\n      if (this._is(val, \"time\")) {\n        return this.toSeconds(val);\n      } else if (this._is(val, \"decibels\")) {\n        return dbToGain(val);\n      } else if (this._is(val, \"frequency\")) {\n        return this.toFrequency(val);\n      } else {\n        return val;\n      }\n    } else if (this.overridden) {\n      // if it's overridden, should only schedule 0s\n      return 0;\n    } else {\n      return val;\n    }\n  }\n  /**\n   * Convert the parameters value into the units specified by Param.units.\n   */\n\n\n  _toType(val) {\n    if (this.convert && this.units === \"decibels\") {\n      return gainToDb(val);\n    } else {\n      return val;\n    }\n  } //-------------------------------------\n  // ABSTRACT PARAM INTERFACE\n  // all docs are generated from ParamInterface.ts\n  //-------------------------------------\n\n\n  setValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n\n    const numericValue = this._fromType(value);\n\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\n    this._assertRange(numericValue);\n\n    this.log(this.units, \"setValueAtTime\", value, computedTime);\n\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: numericValue\n    });\n\n    this._param.setValueAtTime(numericValue, computedTime);\n\n    return this;\n  }\n\n  getValueAtTime(time) {\n    const computedTime = Math.max(this.toSeconds(time), 0);\n\n    const after = this._events.getAfter(computedTime);\n\n    const before = this._events.get(computedTime);\n\n    let value = this._initialValue; // if it was set by\n\n    if (before === null) {\n      value = this._initialValue;\n    } else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n      const previous = this._events.getBefore(before.time);\n\n      let previousVal;\n\n      if (previous === null) {\n        previousVal = this._initialValue;\n      } else {\n        previousVal = previous.value;\n      }\n\n      if (before.type === \"setTargetAtTime\") {\n        value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n      }\n    } else if (after === null) {\n      value = before.value;\n    } else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n      let beforeValue = before.value;\n\n      if (before.type === \"setTargetAtTime\") {\n        const previous = this._events.getBefore(before.time);\n\n        if (previous === null) {\n          beforeValue = this._initialValue;\n        } else {\n          beforeValue = previous.value;\n        }\n      }\n\n      if (after.type === \"linearRampToValueAtTime\") {\n        value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      } else {\n        value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      }\n    } else {\n      value = before.value;\n    }\n\n    return this._toType(value);\n  }\n\n  setRampPoint(time) {\n    time = this.toSeconds(time);\n    let currentVal = this.getValueAtTime(time);\n    this.cancelAndHoldAtTime(time);\n\n    if (this._fromType(currentVal) === 0) {\n      currentVal = this._toType(this._minOutput);\n    }\n\n    this.setValueAtTime(currentVal, time);\n    return this;\n  }\n\n  linearRampToValueAtTime(value, endTime) {\n    const numericValue = this._fromType(value);\n\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\n    this._assertRange(numericValue);\n\n    this._events.add({\n      time: computedTime,\n      type: \"linearRampToValueAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\n    this._param.linearRampToValueAtTime(numericValue, computedTime);\n\n    return this;\n  }\n\n  exponentialRampToValueAtTime(value, endTime) {\n    let numericValue = this._fromType(value); // the value can't be 0\n\n\n    numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n\n    this._assertRange(numericValue);\n\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`); // store the event\n\n    this._events.add({\n      time: computedTime,\n      type: \"exponentialRampToValueAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\n    this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\n    return this;\n  }\n\n  exponentialRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n\n  linearRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n\n  targetRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialApproachValueAtTime(value, startTime, rampTime);\n    return this;\n  }\n\n  exponentialApproachValueAtTime(value, time, rampTime) {\n    time = this.toSeconds(time);\n    rampTime = this.toSeconds(rampTime);\n    const timeConstant = Math.log(rampTime + 1) / Math.log(200);\n    this.setTargetAtTime(value, time, timeConstant); // at 90% start a linear ramp to the final value\n\n    this.cancelAndHoldAtTime(time + rampTime * 0.9);\n    this.linearRampToValueAtTime(value, time + rampTime);\n    return this;\n  }\n\n  setTargetAtTime(value, startTime, timeConstant) {\n    const numericValue = this._fromType(value); // The value will never be able to approach without timeConstant > 0.\n\n\n    assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n    const computedTime = this.toSeconds(startTime);\n\n    this._assertRange(numericValue);\n\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\n    this._events.add({\n      constant: timeConstant,\n      time: computedTime,\n      type: \"setTargetAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\n    this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\n    return this;\n  }\n\n  setValueCurveAtTime(values, startTime, duration, scaling = 1) {\n    duration = this.toSeconds(duration);\n    startTime = this.toSeconds(startTime);\n    const startingValue = this._fromType(values[0]) * scaling;\n    this.setValueAtTime(this._toType(startingValue), startTime);\n    const segTime = duration / (values.length - 1);\n\n    for (let i = 1; i < values.length; i++) {\n      const numericValue = this._fromType(values[i]) * scaling;\n      this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n    }\n\n    return this;\n  }\n\n  cancelScheduledValues(time) {\n    const computedTime = this.toSeconds(time);\n    assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\n    this._events.cancel(computedTime);\n\n    this._param.cancelScheduledValues(computedTime);\n\n    this.log(this.units, \"cancelScheduledValues\", computedTime);\n    return this;\n  }\n\n  cancelAndHoldAtTime(time) {\n    const computedTime = this.toSeconds(time);\n\n    const valueAtTime = this._fromType(this.getValueAtTime(computedTime)); // remove the schedule events\n\n\n    assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n    this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime); // if there is an event at the given computedTime\n    // and that even is not a \"set\"\n\n    const before = this._events.get(computedTime);\n\n    const after = this._events.getAfter(computedTime);\n\n    if (before && EQ(before.time, computedTime)) {\n      // remove everything after\n      if (after) {\n        this._param.cancelScheduledValues(after.time);\n\n        this._events.cancel(after.time);\n      } else {\n        this._param.cancelAndHoldAtTime(computedTime);\n\n        this._events.cancel(computedTime + this.sampleTime);\n      }\n    } else if (after) {\n      this._param.cancelScheduledValues(after.time); // cancel the next event(s)\n\n\n      this._events.cancel(after.time);\n\n      if (after.type === \"linearRampToValueAtTime\") {\n        this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      } else if (after.type === \"exponentialRampToValueAtTime\") {\n        this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      }\n    } // set the value at the given time\n\n\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: valueAtTime\n    });\n\n    this._param.setValueAtTime(valueAtTime, computedTime);\n\n    return this;\n  }\n\n  rampTo(value, rampTime = 0.1, startTime) {\n    if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n      this.exponentialRampTo(value, rampTime, startTime);\n    } else {\n      this.linearRampTo(value, rampTime, startTime);\n    }\n\n    return this;\n  }\n  /**\n   * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n   * The applied values will start at the context's current time and schedule\n   * all of the events which are scheduled on this Param onto the passed in param.\n   */\n\n\n  apply(param) {\n    const now = this.context.currentTime; // set the param's value at the current time and schedule everything else\n\n    param.setValueAtTime(this.getValueAtTime(now), now); // if the previous event was a curve, then set the rest of it\n\n    const previousEvent = this._events.get(now);\n\n    if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n      // approx it until the next event with linear ramps\n      const nextEvent = this._events.getAfter(previousEvent.time); // or for 2 seconds if there is no event\n\n\n      const endTime = nextEvent ? nextEvent.time : now + 2;\n      const subdivisions = (endTime - now) / 10;\n\n      for (let i = now; i < endTime; i += subdivisions) {\n        param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n      }\n    }\n\n    this._events.forEachAfter(this.context.currentTime, event => {\n      if (event.type === \"cancelScheduledValues\") {\n        param.cancelScheduledValues(event.time);\n      } else if (event.type === \"setTargetAtTime\") {\n        param.setTargetAtTime(event.value, event.time, event.constant);\n      } else {\n        param[event.type](event.value, event.time);\n      }\n    });\n\n    return this;\n  }\n  /**\n   * Replace the Param's internal AudioParam. Will apply scheduled curves\n   * onto the parameter and replace the connections.\n   */\n\n\n  setParam(param) {\n    assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n    const input = this.input;\n    input.disconnect(this._param);\n    this.apply(param);\n    this._param = param;\n    input.connect(this._param);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._events.dispose();\n\n    return this;\n  }\n\n  get defaultValue() {\n    return this._toType(this._param.defaultValue);\n  } //-------------------------------------\n  // \tAUTOMATION CURVE CALCULATIONS\n  // \tMIT License, copyright (c) 2014 Jordan Santell\n  //-------------------------------------\n  // Calculates the the value along the curve produced by setTargetAtTime\n\n\n  _exponentialApproach(t0, v0, v1, timeConstant, t) {\n    return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n  } // Calculates the the value along the curve produced by linearRampToValueAtTime\n\n\n  _linearInterpolate(t0, v0, t1, v1, t) {\n    return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n  } // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\n\n  _exponentialInterpolate(t0, v0, t1, v1, t) {\n    return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/core/context/Param.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n        this.name = \"Param\";\n        this.overridden = false;\n        /**\n         * The minimum output value\n         */\n        this._minOutput = 1e-7;\n        const options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n        assert(isDefined(options.param) &&\n            (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n        while (!isAudioParam(options.param)) {\n            options.param = options.param._param;\n        }\n        this._swappable = isDefined(options.swappable) ? options.swappable : false;\n        if (this._swappable) {\n            this.input = this.context.createGain();\n            // initialize\n            this._param = options.param;\n            this.input.connect(this._param);\n        }\n        else {\n            this._param = this.input = options.param;\n        }\n        this._events = new Timeline(1000);\n        this._initialValue = this._param.defaultValue;\n        this.units = options.units;\n        this.convert = options.convert;\n        this._minValue = options.minValue;\n        this._maxValue = options.maxValue;\n        // if the value is defined, set it immediately\n        if (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n            this.setValueAtTime(options.value, 0);\n        }\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            convert: true,\n            units: \"number\",\n        });\n    }\n    get value() {\n        const now = this.now();\n        return this.getValueAtTime(now);\n    }\n    set value(value) {\n        this.cancelScheduledValues(this.now());\n        this.setValueAtTime(value, this.now());\n    }\n    get minValue() {\n        // if it's not the default minValue, return it\n        if (isDefined(this._minValue)) {\n            return this._minValue;\n        }\n        else if (this.units === \"time\" || this.units === \"frequency\" ||\n            this.units === \"normalRange\" || this.units === \"positive\" ||\n            this.units === \"transportTime\" || this.units === \"ticks\" ||\n            this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n            return 0;\n        }\n        else if (this.units === \"audioRange\") {\n            return -1;\n        }\n        else if (this.units === \"decibels\") {\n            return -Infinity;\n        }\n        else {\n            return this._param.minValue;\n        }\n    }\n    get maxValue() {\n        if (isDefined(this._maxValue)) {\n            return this._maxValue;\n        }\n        else if (this.units === \"normalRange\" ||\n            this.units === \"audioRange\") {\n            return 1;\n        }\n        else {\n            return this._param.maxValue;\n        }\n    }\n    /**\n     * Type guard based on the unit name\n     */\n    _is(arg, type) {\n        return this.units === type;\n    }\n    /**\n     * Make sure the value is always in the defined range\n     */\n    _assertRange(value) {\n        if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n            assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n        }\n        return value;\n    }\n    /**\n     * Convert the given value from the type specified by Param.units\n     * into the destination value (such as Gain or Frequency).\n     */\n    _fromType(val) {\n        if (this.convert && !this.overridden) {\n            if (this._is(val, \"time\")) {\n                return this.toSeconds(val);\n            }\n            else if (this._is(val, \"decibels\")) {\n                return dbToGain(val);\n            }\n            else if (this._is(val, \"frequency\")) {\n                return this.toFrequency(val);\n            }\n            else {\n                return val;\n            }\n        }\n        else if (this.overridden) {\n            // if it's overridden, should only schedule 0s\n            return 0;\n        }\n        else {\n            return val;\n        }\n    }\n    /**\n     * Convert the parameters value into the units specified by Param.units.\n     */\n    _toType(val) {\n        if (this.convert && this.units === \"decibels\") {\n            return gainToDb(val);\n        }\n        else {\n            return val;\n        }\n    }\n    //-------------------------------------\n    // ABSTRACT PARAM INTERFACE\n    // all docs are generated from ParamInterface.ts\n    //-------------------------------------\n    setValueAtTime(value, time) {\n        const computedTime = this.toSeconds(time);\n        const numericValue = this._fromType(value);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n        this._assertRange(numericValue);\n        this.log(this.units, \"setValueAtTime\", value, computedTime);\n        this._events.add({\n            time: computedTime,\n            type: \"setValueAtTime\",\n            value: numericValue,\n        });\n        this._param.setValueAtTime(numericValue, computedTime);\n        return this;\n    }\n    getValueAtTime(time) {\n        const computedTime = Math.max(this.toSeconds(time), 0);\n        const after = this._events.getAfter(computedTime);\n        const before = this._events.get(computedTime);\n        let value = this._initialValue;\n        // if it was set by\n        if (before === null) {\n            value = this._initialValue;\n        }\n        else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n            const previous = this._events.getBefore(before.time);\n            let previousVal;\n            if (previous === null) {\n                previousVal = this._initialValue;\n            }\n            else {\n                previousVal = previous.value;\n            }\n            if (before.type === \"setTargetAtTime\") {\n                value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n            }\n        }\n        else if (after === null) {\n            value = before.value;\n        }\n        else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n            let beforeValue = before.value;\n            if (before.type === \"setTargetAtTime\") {\n                const previous = this._events.getBefore(before.time);\n                if (previous === null) {\n                    beforeValue = this._initialValue;\n                }\n                else {\n                    beforeValue = previous.value;\n                }\n            }\n            if (after.type === \"linearRampToValueAtTime\") {\n                value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n            }\n            else {\n                value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n            }\n        }\n        else {\n            value = before.value;\n        }\n        return this._toType(value);\n    }\n    setRampPoint(time) {\n        time = this.toSeconds(time);\n        let currentVal = this.getValueAtTime(time);\n        this.cancelAndHoldAtTime(time);\n        if (this._fromType(currentVal) === 0) {\n            currentVal = this._toType(this._minOutput);\n        }\n        this.setValueAtTime(currentVal, time);\n        return this;\n    }\n    linearRampToValueAtTime(value, endTime) {\n        const numericValue = this._fromType(value);\n        const computedTime = this.toSeconds(endTime);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n        this._assertRange(numericValue);\n        this._events.add({\n            time: computedTime,\n            type: \"linearRampToValueAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n        this._param.linearRampToValueAtTime(numericValue, computedTime);\n        return this;\n    }\n    exponentialRampToValueAtTime(value, endTime) {\n        let numericValue = this._fromType(value);\n        // the value can't be 0\n        numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n        this._assertRange(numericValue);\n        const computedTime = this.toSeconds(endTime);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n        // store the event\n        this._events.add({\n            time: computedTime,\n            type: \"exponentialRampToValueAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n        this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n        return this;\n    }\n    exponentialRampTo(value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n        return this;\n    }\n    linearRampTo(value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n        return this;\n    }\n    targetRampTo(value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.exponentialApproachValueAtTime(value, startTime, rampTime);\n        return this;\n    }\n    exponentialApproachValueAtTime(value, time, rampTime) {\n        time = this.toSeconds(time);\n        rampTime = this.toSeconds(rampTime);\n        const timeConstant = Math.log(rampTime + 1) / Math.log(200);\n        this.setTargetAtTime(value, time, timeConstant);\n        // at 90% start a linear ramp to the final value\n        this.cancelAndHoldAtTime(time + rampTime * 0.9);\n        this.linearRampToValueAtTime(value, time + rampTime);\n        return this;\n    }\n    setTargetAtTime(value, startTime, timeConstant) {\n        const numericValue = this._fromType(value);\n        // The value will never be able to approach without timeConstant > 0.\n        assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n        const computedTime = this.toSeconds(startTime);\n        this._assertRange(numericValue);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n        this._events.add({\n            constant: timeConstant,\n            time: computedTime,\n            type: \"setTargetAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n        this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n        return this;\n    }\n    setValueCurveAtTime(values, startTime, duration, scaling = 1) {\n        duration = this.toSeconds(duration);\n        startTime = this.toSeconds(startTime);\n        const startingValue = this._fromType(values[0]) * scaling;\n        this.setValueAtTime(this._toType(startingValue), startTime);\n        const segTime = duration / (values.length - 1);\n        for (let i = 1; i < values.length; i++) {\n            const numericValue = this._fromType(values[i]) * scaling;\n            this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n        }\n        return this;\n    }\n    cancelScheduledValues(time) {\n        const computedTime = this.toSeconds(time);\n        assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n        this._events.cancel(computedTime);\n        this._param.cancelScheduledValues(computedTime);\n        this.log(this.units, \"cancelScheduledValues\", computedTime);\n        return this;\n    }\n    cancelAndHoldAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        const valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n        // remove the schedule events\n        assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n        this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n        // if there is an event at the given computedTime\n        // and that even is not a \"set\"\n        const before = this._events.get(computedTime);\n        const after = this._events.getAfter(computedTime);\n        if (before && EQ(before.time, computedTime)) {\n            // remove everything after\n            if (after) {\n                this._param.cancelScheduledValues(after.time);\n                this._events.cancel(after.time);\n            }\n            else {\n                this._param.cancelAndHoldAtTime(computedTime);\n                this._events.cancel(computedTime + this.sampleTime);\n            }\n        }\n        else if (after) {\n            this._param.cancelScheduledValues(after.time);\n            // cancel the next event(s)\n            this._events.cancel(after.time);\n            if (after.type === \"linearRampToValueAtTime\") {\n                this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n            }\n            else if (after.type === \"exponentialRampToValueAtTime\") {\n                this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n            }\n        }\n        // set the value at the given time\n        this._events.add({\n            time: computedTime,\n            type: \"setValueAtTime\",\n            value: valueAtTime,\n        });\n        this._param.setValueAtTime(valueAtTime, computedTime);\n        return this;\n    }\n    rampTo(value, rampTime = 0.1, startTime) {\n        if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n            this.exponentialRampTo(value, rampTime, startTime);\n        }\n        else {\n            this.linearRampTo(value, rampTime, startTime);\n        }\n        return this;\n    }\n    /**\n     * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n     * The applied values will start at the context's current time and schedule\n     * all of the events which are scheduled on this Param onto the passed in param.\n     */\n    apply(param) {\n        const now = this.context.currentTime;\n        // set the param's value at the current time and schedule everything else\n        param.setValueAtTime(this.getValueAtTime(now), now);\n        // if the previous event was a curve, then set the rest of it\n        const previousEvent = this._events.get(now);\n        if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n            // approx it until the next event with linear ramps\n            const nextEvent = this._events.getAfter(previousEvent.time);\n            // or for 2 seconds if there is no event\n            const endTime = nextEvent ? nextEvent.time : now + 2;\n            const subdivisions = (endTime - now) / 10;\n            for (let i = now; i < endTime; i += subdivisions) {\n                param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n            }\n        }\n        this._events.forEachAfter(this.context.currentTime, event => {\n            if (event.type === \"cancelScheduledValues\") {\n                param.cancelScheduledValues(event.time);\n            }\n            else if (event.type === \"setTargetAtTime\") {\n                param.setTargetAtTime(event.value, event.time, event.constant);\n            }\n            else {\n                param[event.type](event.value, event.time);\n            }\n        });\n        return this;\n    }\n    /**\n     * Replace the Param's internal AudioParam. Will apply scheduled curves\n     * onto the parameter and replace the connections.\n     */\n    setParam(param) {\n        assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n        const input = this.input;\n        input.disconnect(this._param);\n        this.apply(param);\n        this._param = param;\n        input.connect(this._param);\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._events.dispose();\n        return this;\n    }\n    get defaultValue() {\n        return this._toType(this._param.defaultValue);\n    }\n    //-------------------------------------\n    // \tAUTOMATION CURVE CALCULATIONS\n    // \tMIT License, copyright (c) 2014 Jordan Santell\n    //-------------------------------------\n    // Calculates the the value along the curve produced by setTargetAtTime\n    _exponentialApproach(t0, v0, v1, timeConstant, t) {\n        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n    }\n    // Calculates the the value along the curve produced by linearRampToValueAtTime\n    _linearInterpolate(t0, v0, t1, v1, t) {\n        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n    }\n    // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n    _exponentialInterpolate(t0, v0, t1, v1, t) {\n        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n    }\n}\n//# sourceMappingURL=Param.js.map"]},"metadata":{},"sourceType":"module"}