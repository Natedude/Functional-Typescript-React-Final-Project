{"ast":null,"code":"import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections) => {\n  return (nativeContext, baseLatency, processorConstructor, options) => {\n    if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n      throw createNotSupportedError();\n    }\n\n    const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount); // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n\n    if (outputChannelCount.some(channelCount => channelCount < 1)) {\n      throw createNotSupportedError();\n    }\n\n    if (outputChannelCount.length !== options.numberOfOutputs) {\n      throw createIndexSizeError();\n    } // Bug #61: This is not part of the standard but required for the faker to work.\n\n\n    if (options.channelCountMode !== 'explicit') {\n      throw createNotSupportedError();\n    }\n\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length; // Bug #61: This is not part of the standard but required for the faker to work.\n\n    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n      throw createNotSupportedError();\n    }\n\n    const messageChannel = new MessageChannel();\n    const gainNodes = [];\n    const inputChannelSplitterNodes = [];\n\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes.push(createNativeGainNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: options.channelCountMode,\n        channelInterpretation: options.channelInterpretation,\n        gain: 1\n      }));\n      inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete',\n        numberOfOutputs: options.channelCount\n      }));\n    }\n\n    const constantSourceNodes = [];\n\n    if (processorConstructor.parameterDescriptors !== undefined) {\n      for (const {\n        defaultValue,\n        maxValue,\n        minValue,\n        name\n      } of processorConstructor.parameterDescriptors) {\n        const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          offset: options.parameterData[name] !== undefined ? options.parameterData[name] : defaultValue === undefined ? 0 : defaultValue\n        });\n        Object.defineProperties(constantSourceNode.offset, {\n          defaultValue: {\n            get: () => defaultValue === undefined ? 0 : defaultValue\n          },\n          maxValue: {\n            get: () => maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n          },\n          minValue: {\n            get: () => minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n          }\n        });\n        constantSourceNodes.push(constantSourceNode);\n      }\n    }\n\n    const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n    });\n    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n    Math.max(1, numberOfOutputChannels));\n    const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: Math.max(1, numberOfOutputChannels),\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: Math.max(1, numberOfOutputChannels)\n    });\n    const outputChannelMergerNodes = [];\n\n    for (let i = 0; i < options.numberOfOutputs; i += 1) {\n      outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'speakers',\n        numberOfInputs: outputChannelCount[i]\n      }));\n    }\n\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n      for (let j = 0; j < options.channelCount; j += 1) {\n        inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n      }\n    }\n\n    const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.map(({\n      name\n    }, index) => {\n      const constantSourceNode = constantSourceNodes[index];\n      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n      constantSourceNode.start(0);\n      return [name, constantSourceNode.offset];\n    }));\n    inputChannelMergerNode.connect(scriptProcessorNode);\n    let channelInterpretation = options.channelInterpretation;\n    let onprocessorerror = null; // Bug #87: Expose at least one output to make this node connectable.\n\n    const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n    const nativeAudioWorkletNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n\n      get channelCount() {\n        return options.channelCount;\n      },\n\n      set channelCount(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelCountMode() {\n        return options.channelCountMode;\n      },\n\n      set channelCountMode(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelInterpretation() {\n        return channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        for (const gainNode of gainNodes) {\n          gainNode.channelInterpretation = value;\n        }\n\n        channelInterpretation = value;\n      },\n\n      get context() {\n        return scriptProcessorNode.context;\n      },\n\n      get inputs() {\n        return gainNodes;\n      },\n\n      get numberOfInputs() {\n        return options.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return options.numberOfOutputs;\n      },\n\n      get onprocessorerror() {\n        return onprocessorerror;\n      },\n\n      set onprocessorerror(value) {\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n        }\n\n        onprocessorerror = typeof value === 'function' ? value : null;\n\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n        }\n      },\n\n      get parameters() {\n        return parameterMap;\n      },\n\n      get port() {\n        return messageChannel.port2;\n      },\n\n      addEventListener(...args) {\n        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n      disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n\n      dispatchEvent(...args) {\n        return scriptProcessorNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n    const patchedEventListeners = new Map();\n\n    messageChannel.port1.addEventListener = (addEventListener => {\n      return (...args) => {\n        if (args[0] === 'message') {\n          const unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n\n          if (unpatchedEventListener !== null) {\n            const patchedEventListener = patchedEventListeners.get(args[1]);\n\n            if (patchedEventListener !== undefined) {\n              args[1] = patchedEventListener;\n            } else {\n              args[1] = event => {\n                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n              };\n\n              patchedEventListeners.set(unpatchedEventListener, args[1]);\n            }\n          }\n        }\n\n        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.addEventListener);\n\n    messageChannel.port1.removeEventListener = (removeEventListener => {\n      return (...args) => {\n        if (args[0] === 'message') {\n          const patchedEventListener = patchedEventListeners.get(args[1]);\n\n          if (patchedEventListener !== undefined) {\n            patchedEventListeners.delete(args[1]);\n            args[1] = patchedEventListener;\n          }\n        }\n\n        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.removeEventListener);\n\n    let onmessage = null;\n    Object.defineProperty(messageChannel.port1, 'onmessage', {\n      get: () => onmessage,\n      set: value => {\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.removeEventListener('message', onmessage);\n        }\n\n        onmessage = typeof value === 'function' ? value : null;\n\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.addEventListener('message', onmessage);\n          messageChannel.port1.start();\n        }\n      }\n    });\n    processorConstructor.prototype.port = messageChannel.port1;\n    let audioWorkletProcessor = null;\n    const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n    audioWorkletProcessorPromise.then(dWrkltPrcssr => audioWorkletProcessor = dWrkltPrcssr);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters = processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, {\n      name\n    }) => ({ ...prmtrs,\n      [name]: new Float32Array(128)\n    }), {});\n    let isActive = true;\n\n    const disconnectOutputsGraph = () => {\n      if (options.numberOfOutputs > 0) {\n        scriptProcessorNode.disconnect(outputChannelSplitterNode);\n      }\n\n      for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n        const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n        for (let j = 0; j < outputChannelCount[i]; j += 1) {\n          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n        }\n\n        outputChannelSplitterNodeOutput += outputChannelCount[i];\n      }\n    };\n\n    const activeInputIndexes = new Map(); // tslint:disable-next-line:deprecation\n\n    scriptProcessorNode.onaudioprocess = ({\n      inputBuffer,\n      outputBuffer\n    }) => {\n      if (audioWorkletProcessor !== null) {\n        const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n\n        for (let i = 0; i < bufferSize; i += 128) {\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.channelCount; k += 1) {\n              copyFromChannel(inputBuffer, inputs[j], k, k, i);\n            }\n          }\n\n          if (processorConstructor.parameterDescriptors !== undefined) {\n            processorConstructor.parameterDescriptors.forEach(({\n              name\n            }, index) => {\n              copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n          }\n\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n              // The byteLength will be 0 when the ArrayBuffer was transferred.\n              if (outputs[j][k].byteLength === 0) {\n                outputs[j][k] = new Float32Array(128);\n              }\n            }\n          }\n\n          try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n              const activeInput = activeInputs[index];\n\n              if (activeInput.size > 0) {\n                activeInputIndexes.set(index, bufferSize / 128);\n                return input;\n              }\n\n              const count = activeInputIndexes.get(index);\n\n              if (count === undefined) {\n                return [];\n              }\n\n              if (input.every(channelData => channelData.every(sample => sample === 0))) {\n                if (count === 1) {\n                  activeInputIndexes.delete(index);\n                } else {\n                  activeInputIndexes.set(index, count - 1);\n                }\n              }\n\n              return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            isActive = activeSourceFlag;\n\n            for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n              for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n              }\n\n              outputChannelSplitterNodeOutput += outputChannelCount[j];\n            }\n          } catch (error) {\n            isActive = false;\n            nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n              colno: error.colno,\n              filename: error.filename,\n              lineno: error.lineno,\n              message: error.message\n            }));\n          }\n\n          if (!isActive) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n              gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n\n              for (let k = 0; k < options.channelCount; k += 1) {\n                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n              }\n            }\n\n            if (processorConstructor.parameterDescriptors !== undefined) {\n              const length = processorConstructor.parameterDescriptors.length;\n\n              for (let j = 0; j < length; j += 1) {\n                const constantSourceNode = constantSourceNodes[j];\n                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                constantSourceNode.stop();\n              }\n            }\n\n            inputChannelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n            if (isConnected) {\n              disconnectOutputsGraph();\n            } else {\n              disconnectFakeGraph();\n            }\n\n            break;\n          }\n        }\n      }\n    };\n\n    let isConnected = false; // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n\n    const nativeGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: 0\n    });\n\n    const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n    const disconnectFakeGraph = () => {\n      scriptProcessorNode.disconnect(nativeGainNode);\n      nativeGainNode.disconnect();\n    };\n\n    const whenConnected = () => {\n      if (isActive) {\n        disconnectFakeGraph();\n\n        if (options.numberOfOutputs > 0) {\n          scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n          for (let j = 0; j < outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n\n          outputChannelSplitterNodeOutput += outputChannelCount[i];\n        }\n      }\n\n      isConnected = true;\n    };\n\n    const whenDisconnected = () => {\n      if (isActive) {\n        connectFakeGraph();\n        disconnectOutputsGraph();\n      }\n\n      isConnected = false;\n    };\n\n    connectFakeGraph();\n    return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"sources":["../../../src/factories/native-audio-worklet-node-faker-factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        const outputChannelCount = Array.isArray(options.outputChannelCount)\n            ? options.outputChannelCount\n            : Array.from(options.outputChannelCount);\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some((channelCount) => channelCount < 1)) {\n            throw createNotSupportedError();\n        }\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n            throw createIndexSizeError();\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: options.parameterData[name] !== undefined\n                        ? options.parameterData[name]\n                        : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = typeof value === 'function' ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map();\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = typeof args[1] === 'function'\n                        ? args[1]\n                        : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = typeof value === 'function' ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        const parameters = processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n                for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n                outputChannelSplitterNodeOutput += outputChannelCount[i];\n            }\n        };\n        const activeInputIndexes = new Map();\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const activeInput = activeInputs[index];\n                            if (activeInput.size > 0) {\n                                activeInputIndexes.set(index, bufferSize / 128);\n                                return input;\n                            }\n                            const count = activeInputIndexes.get(index);\n                            if (count === undefined) {\n                                return [];\n                            }\n                            if (input.every((channelData) => channelData.every((sample) => sample === 0))) {\n                                if (count === 1) {\n                                    activeInputIndexes.delete(index);\n                                }\n                                else {\n                                    activeInputIndexes.set(index, count - 1);\n                                }\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n                            colno: error.colno,\n                            filename: error.filename,\n                            lineno: error.lineno,\n                            message: error.message\n                        }));\n                    }\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        }\n                        else {\n                            disconnectFakeGraph();\n                        }\n                        break;\n                    }\n                }\n            }\n        };\n        let isConnected = false;\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n            }\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n            isConnected = false;\n        };\n        connectFakeGraph();\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-audio-worklet-node-faker-factory.js.map"]},"metadata":{},"sourceType":"module"}