{"ast":null,"code":"import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible) => {\n  return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n    const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n    const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n    const audioParam = {\n      get defaultValue() {\n        return nativeAudioParam.defaultValue;\n      },\n\n      get maxValue() {\n        return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n      },\n\n      get minValue() {\n        return minValue === null ? nativeAudioParam.minValue : minValue;\n      },\n\n      get value() {\n        return nativeAudioParam.value;\n      },\n\n      set value(value) {\n        nativeAudioParam.value = value; // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n\n        audioParam.setValueAtTime(value, audioNode.context.currentTime);\n      },\n\n      cancelAndHoldAtTime(cancelTime) {\n        // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n        if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n        } else {\n          const previousLastEvent = Array.from(automationEventList).pop();\n\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          const currentLastEvent = Array.from(automationEventList).pop();\n          nativeAudioParam.cancelScheduledValues(cancelTime);\n\n          if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n            if (currentLastEvent.type === 'exponentialRampToValue') {\n              nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'linearRampToValue') {\n              nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'setValue') {\n              nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n            } else if (currentLastEvent.type === 'setValueCurve') {\n              nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n            }\n          }\n        }\n\n        return audioParam;\n      },\n\n      cancelScheduledValues(cancelTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n        nativeAudioParam.cancelScheduledValues(cancelTime);\n        return audioParam;\n      },\n\n      exponentialRampToValueAtTime(value, endTime) {\n        // Bug #45: Safari does not throw an error yet.\n        if (value === 0) {\n          throw new RangeError();\n        } // Bug #187: Safari does not throw an error yet.\n\n\n        if (!Number.isFinite(endTime) || endTime < 0) {\n          throw new RangeError();\n        }\n\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n\n      linearRampToValueAtTime(value, endTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.linearRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n\n      setTargetAtTime(target, startTime, timeConstant) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n        nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n        return audioParam;\n      },\n\n      setValueAtTime(value, startTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createSetValueAutomationEvent(value, startTime));\n        nativeAudioParam.setValueAtTime(value, startTime);\n        return audioParam;\n      },\n\n      setValueCurveAtTime(values, startTime, duration) {\n        // Bug 183: Safari only accepts a Float32Array.\n        const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n        /*\n         * Bug #152: Safari does not correctly interpolate the values of the curve.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n         * existence of the webkitAudioContext is used as a workaround here.\n         */\n\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n          const endTime = startTime + duration;\n          const sampleRate = audioNode.context.sampleRate;\n          const firstSample = Math.ceil(startTime * sampleRate);\n          const lastSample = Math.floor(endTime * sampleRate);\n          const numberOfInterpolatedValues = lastSample - firstSample;\n          const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n\n          for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n            const theoreticIndex = (convertedValues.length - 1) / duration * ((firstSample + i) / sampleRate - startTime);\n            const lowerIndex = Math.floor(theoreticIndex);\n            const upperIndex = Math.ceil(theoreticIndex);\n            interpolatedValues[i] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n          }\n\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n          const timeOfLastSample = lastSample / sampleRate;\n\n          if (timeOfLastSample < endTime) {\n            setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n          }\n\n          setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n        } else {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n        }\n\n        return audioParam;\n      }\n\n    };\n    audioParamStore.set(audioParam, nativeAudioParam);\n    audioParamAudioNodeStore.set(audioParam, audioNode);\n    addAudioParamConnections(audioParam, audioParamRenderer);\n    return audioParam;\n  };\n};","map":{"version":3,"sources":["../../../src/factories/audio-param-factory.ts"],"names":[],"mappings":"AAAA,SAAS,mBAAT,QAAoC,mBAApC;AAIA,OAAO,MAAM,uBAAuB,GAA8B,CAC9D,wBAD8D,EAE9D,wBAF8D,EAG9D,eAH8D,EAI9D,wBAJ8D,EAK9D,kCAL8D,EAM9D,0CAN8D,EAO9D,2CAP8D,EAQ9D,sCAR8D,EAS9D,8BAT8D,EAU9D,6BAV8D,EAW9D,kCAX8D,EAY9D,6BAZ8D,EAa9D,2BAb8D,KAc9D;AACA,SAAO,CACH,SADG,EAEH,iCAFG,EAGH,gBAHG,EAIH,QAAA,GAA0B,IAJvB,EAKH,QAAA,GAA0B,IALvB,KAMU;AACb,UAAM,mBAAmB,GAAG,IAAI,mBAAJ,CAAwB,gBAAgB,CAAC,YAAzC,CAA5B;AACA,UAAM,kBAAkB,GAAG,iCAAiC,GAAG,wBAAwB,CAAC,mBAAD,CAA3B,GAAmD,IAA/G;AACA,UAAM,UAAU,GAAG;AACf,UAAI,YAAJ,GAAgB;AACZ,eAAO,gBAAgB,CAAC,YAAxB;AACH,OAHc;;AAIf,UAAI,QAAJ,GAAY;AACR,eAAO,QAAQ,KAAK,IAAb,GAAoB,gBAAgB,CAAC,QAArC,GAAgD,QAAvD;AACH,OANc;;AAOf,UAAI,QAAJ,GAAY;AACR,eAAO,QAAQ,KAAK,IAAb,GAAoB,gBAAgB,CAAC,QAArC,GAAgD,QAAvD;AACH,OATc;;AAUf,UAAI,KAAJ,GAAS;AACL,eAAO,gBAAgB,CAAC,KAAxB;AACH,OAZc;;AAaf,UAAI,KAAJ,CAAU,KAAV,EAAe;AACX,QAAA,gBAAgB,CAAC,KAAjB,GAAyB,KAAzB,CADW,CAGX;;AACA,QAAA,UAAU,CAAC,cAAX,CAA0B,KAA1B,EAAiC,SAAS,CAAC,OAAV,CAAkB,WAAnD;AACH,OAlBc;;AAmBf,MAAA,mBAAmB,CAAC,UAAD,EAAmB;AAClC;AACA,YAAI,OAAO,gBAAgB,CAAC,mBAAxB,KAAgD,UAApD,EAAgE;AAC5D,cAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC7B,YAAA,mBAAmB,CAAC,KAApB,CAA0B,SAAS,CAAC,OAAV,CAAkB,WAA5C;AACH;;AAED,UAAA,mBAAmB,CAAC,GAApB,CAAwB,kCAAkC,CAAC,UAAD,CAA1D;AACA,UAAA,gBAAgB,CAAC,mBAAjB,CAAqC,UAArC;AACH,SAPD,MAOO;AACH,gBAAM,iBAAiB,GAAG,KAAK,CAAC,IAAN,CAAW,mBAAX,EAAgC,GAAhC,EAA1B;;AAEA,cAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC7B,YAAA,mBAAmB,CAAC,KAApB,CAA0B,SAAS,CAAC,OAAV,CAAkB,WAA5C;AACH;;AAED,UAAA,mBAAmB,CAAC,GAApB,CAAwB,kCAAkC,CAAC,UAAD,CAA1D;AAEA,gBAAM,gBAAgB,GAAG,KAAK,CAAC,IAAN,CAAW,mBAAX,EAAgC,GAAhC,EAAzB;AAEA,UAAA,gBAAgB,CAAC,qBAAjB,CAAuC,UAAvC;;AAEA,cAAI,iBAAiB,KAAK,gBAAtB,IAA0C,gBAAgB,KAAK,SAAnE,EAA8E;AAC1E,gBAAI,gBAAgB,CAAC,IAAjB,KAA0B,wBAA9B,EAAwD;AACpD,cAAA,gBAAgB,CAAC,4BAAjB,CAA8C,gBAAgB,CAAC,KAA/D,EAAsE,gBAAgB,CAAC,OAAvF;AACH,aAFD,MAEO,IAAI,gBAAgB,CAAC,IAAjB,KAA0B,mBAA9B,EAAmD;AACtD,cAAA,gBAAgB,CAAC,uBAAjB,CAAyC,gBAAgB,CAAC,KAA1D,EAAiE,gBAAgB,CAAC,OAAlF;AACH,aAFM,MAEA,IAAI,gBAAgB,CAAC,IAAjB,KAA0B,UAA9B,EAA0C;AAC7C,cAAA,gBAAgB,CAAC,cAAjB,CAAgC,gBAAgB,CAAC,KAAjD,EAAwD,gBAAgB,CAAC,SAAzE;AACH,aAFM,MAEA,IAAI,gBAAgB,CAAC,IAAjB,KAA0B,eAA9B,EAA+C;AAClD,cAAA,gBAAgB,CAAC,mBAAjB,CACI,gBAAgB,CAAC,MADrB,EAEI,gBAAgB,CAAC,SAFrB,EAGI,gBAAgB,CAAC,QAHrB;AAKH;AACJ;AACJ;;AAED,eAAO,UAAP;AACH,OA3Dc;;AA4Df,MAAA,qBAAqB,CAAC,UAAD,EAAmB;AACpC,YAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC7B,UAAA,mBAAmB,CAAC,KAApB,CAA0B,SAAS,CAAC,OAAV,CAAkB,WAA5C;AACH;;AAED,QAAA,mBAAmB,CAAC,GAApB,CAAwB,0CAA0C,CAAC,UAAD,CAAlE;AACA,QAAA,gBAAgB,CAAC,qBAAjB,CAAuC,UAAvC;AAEA,eAAO,UAAP;AACH,OArEc;;AAsEf,MAAA,4BAA4B,CAAC,KAAD,EAAgB,OAAhB,EAA+B;AACvD;AACA,YAAI,KAAK,KAAK,CAAd,EAAiB;AACb,gBAAM,IAAI,UAAJ,EAAN;AACH,SAJsD,CAMvD;;;AACA,YAAI,CAAC,MAAM,CAAC,QAAP,CAAgB,OAAhB,CAAD,IAA6B,OAAO,GAAG,CAA3C,EAA8C;AAC1C,gBAAM,IAAI,UAAJ,EAAN;AACH;;AAED,YAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC7B,UAAA,mBAAmB,CAAC,KAApB,CAA0B,SAAS,CAAC,OAAV,CAAkB,WAA5C;AACH;;AAED,QAAA,mBAAmB,CAAC,GAApB,CAAwB,2CAA2C,CAAC,KAAD,EAAQ,OAAR,CAAnE;AACA,QAAA,gBAAgB,CAAC,4BAAjB,CAA8C,KAA9C,EAAqD,OAArD;AAEA,eAAO,UAAP;AACH,OAzFc;;AA0Ff,MAAA,uBAAuB,CAAC,KAAD,EAAgB,OAAhB,EAA+B;AAClD,YAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC7B,UAAA,mBAAmB,CAAC,KAApB,CAA0B,SAAS,CAAC,OAAV,CAAkB,WAA5C;AACH;;AAED,QAAA,mBAAmB,CAAC,GAApB,CAAwB,sCAAsC,CAAC,KAAD,EAAQ,OAAR,CAA9D;AACA,QAAA,gBAAgB,CAAC,uBAAjB,CAAyC,KAAzC,EAAgD,OAAhD;AAEA,eAAO,UAAP;AACH,OAnGc;;AAoGf,MAAA,eAAe,CAAC,MAAD,EAAiB,SAAjB,EAAoC,YAApC,EAAwD;AACnE,YAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC7B,UAAA,mBAAmB,CAAC,KAApB,CAA0B,SAAS,CAAC,OAAV,CAAkB,WAA5C;AACH;;AAED,QAAA,mBAAmB,CAAC,GAApB,CAAwB,8BAA8B,CAAC,MAAD,EAAS,SAAT,EAAoB,YAApB,CAAtD;AACA,QAAA,gBAAgB,CAAC,eAAjB,CAAiC,MAAjC,EAAyC,SAAzC,EAAoD,YAApD;AAEA,eAAO,UAAP;AACH,OA7Gc;;AA8Gf,MAAA,cAAc,CAAC,KAAD,EAAgB,SAAhB,EAAiC;AAC3C,YAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC7B,UAAA,mBAAmB,CAAC,KAApB,CAA0B,SAAS,CAAC,OAAV,CAAkB,WAA5C;AACH;;AAED,QAAA,mBAAmB,CAAC,GAApB,CAAwB,6BAA6B,CAAC,KAAD,EAAQ,SAAR,CAArD;AACA,QAAA,gBAAgB,CAAC,cAAjB,CAAgC,KAAhC,EAAuC,SAAvC;AAEA,eAAO,UAAP;AACH,OAvHc;;AAwHf,MAAA,mBAAmB,CAAC,MAAD,EAA2B,SAA3B,EAA8C,QAA9C,EAA8D;AAC7E;AACA,cAAM,eAAe,GAAG,MAAM,YAAY,YAAlB,GAAiC,MAAjC,GAA0C,IAAI,YAAJ,CAAiB,MAAjB,CAAlE;AACA;;;;AAIG;;AACH,YAAI,6BAA6B,KAAK,IAAlC,IAA0C,6BAA6B,CAAC,IAA9B,KAAuC,oBAArF,EAA2G;AACvG,gBAAM,OAAO,GAAG,SAAS,GAAG,QAA5B;AACA,gBAAM,UAAU,GAAG,SAAS,CAAC,OAAV,CAAkB,UAArC;AACA,gBAAM,WAAW,GAAG,IAAI,CAAC,IAAL,CAAU,SAAS,GAAG,UAAtB,CAApB;AACA,gBAAM,UAAU,GAAG,IAAI,CAAC,KAAL,CAAW,OAAO,GAAG,UAArB,CAAnB;AACA,gBAAM,0BAA0B,GAAG,UAAU,GAAG,WAAhD;AACA,gBAAM,kBAAkB,GAAG,IAAI,YAAJ,CAAiB,0BAAjB,CAA3B;;AAEA,eAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,0BAApB,EAAgD,CAAC,IAAI,CAArD,EAAwD;AACpD,kBAAM,cAAc,GAAI,CAAC,eAAe,CAAC,MAAhB,GAAyB,CAA1B,IAA+B,QAAhC,IAA6C,CAAC,WAAW,GAAG,CAAf,IAAoB,UAApB,GAAiC,SAA9E,CAAvB;AACA,kBAAM,UAAU,GAAG,IAAI,CAAC,KAAL,CAAW,cAAX,CAAnB;AACA,kBAAM,UAAU,GAAG,IAAI,CAAC,IAAL,CAAU,cAAV,CAAnB;AAEA,YAAA,kBAAkB,CAAC,CAAD,CAAlB,GACI,UAAU,KAAK,UAAf,GACM,eAAe,CAAC,UAAD,CADrB,GAEM,CAAC,KAAK,cAAc,GAAG,UAAtB,CAAD,IAAsC,eAAe,CAAC,UAAD,CAArD,GACA,CAAC,KAAK,UAAU,GAAG,cAAlB,CAAD,IAAsC,eAAe,CAAC,UAAD,CAJ/D;AAKH;;AAED,cAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC7B,YAAA,mBAAmB,CAAC,KAApB,CAA0B,SAAS,CAAC,OAAV,CAAkB,WAA5C;AACH;;AAED,UAAA,mBAAmB,CAAC,GAApB,CAAwB,kCAAkC,CAAC,kBAAD,EAAqB,SAArB,EAAgC,QAAhC,CAA1D;AACA,UAAA,gBAAgB,CAAC,mBAAjB,CAAqC,kBAArC,EAAyD,SAAzD,EAAoE,QAApE;AAEA,gBAAM,gBAAgB,GAAG,UAAU,GAAG,UAAtC;;AAEA,cAAI,gBAAgB,GAAG,OAAvB,EAAgC;AAC5B,YAAA,2BAA2B,CAAC,UAAD,EAAa,kBAAkB,CAAC,kBAAkB,CAAC,MAAnB,GAA4B,CAA7B,CAA/B,EAAgE,gBAAhE,CAA3B;AACH;;AAED,UAAA,2BAA2B,CAAC,UAAD,EAAa,eAAe,CAAC,eAAe,CAAC,MAAhB,GAAyB,CAA1B,CAA5B,EAA0D,OAA1D,CAA3B;AACH,SAlCD,MAkCO;AACH,cAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC7B,YAAA,mBAAmB,CAAC,KAApB,CAA0B,SAAS,CAAC,OAAV,CAAkB,WAA5C;AACH;;AAED,UAAA,mBAAmB,CAAC,GAApB,CAAwB,kCAAkC,CAAC,eAAD,EAAkB,SAAlB,EAA6B,QAA7B,CAA1D;AACA,UAAA,gBAAgB,CAAC,mBAAjB,CAAqC,eAArC,EAAsD,SAAtD,EAAiE,QAAjE;AACH;;AAED,eAAO,UAAP;AACH;;AA5Kc,KAAnB;AA+KA,IAAA,eAAe,CAAC,GAAhB,CAAoB,UAApB,EAAgC,gBAAhC;AACA,IAAA,wBAAwB,CAAC,GAAzB,CAA6B,UAA7B,EAAyC,SAAzC;AAEA,IAAA,wBAAwB,CACpB,UADoB,EAEuE,kBAFvE,CAAxB;AAKA,WAAO,UAAP;AACH,GAjMD;AAkMH,CAjNM","sourceRoot":"","sourcesContent":["import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible) => {\n    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n        const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue() {\n                return nativeAudioParam.defaultValue;\n            },\n            get maxValue() {\n                return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue() {\n                return minValue === null ? nativeAudioParam.minValue : minValue;\n            },\n            get value() {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n                // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime) {\n                // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                }\n                else {\n                    const previousLastEvent = Array.from(automationEventList).pop();\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    const currentLastEvent = Array.from(automationEventList).pop();\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        }\n                        else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                        }\n                    }\n                }\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value, endTime) {\n                // Bug #45: Safari does not throw an error yet.\n                if (value === 0) {\n                    throw new RangeError();\n                }\n                // Bug #187: Safari does not throw an error yet.\n                if (!Number.isFinite(endTime) || endTime < 0) {\n                    throw new RangeError();\n                }\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            linearRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            setTargetAtTime(target, startTime, timeConstant) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n                return audioParam;\n            },\n            setValueAtTime(value, startTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n                return audioParam;\n            },\n            setValueCurveAtTime(values, startTime, duration) {\n                // Bug 183: Safari only accepts a Float32Array.\n                const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor(endTime * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((convertedValues.length - 1) / duration) * ((firstSample + i) / sampleRate - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        interpolatedValues[i] =\n                            lowerIndex === upperIndex\n                                ? convertedValues[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] +\n                                    (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n                    }\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n                    const timeOfLastSample = lastSample / sampleRate;\n                    if (timeOfLastSample < endTime) {\n                        setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n                    setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n                }\n                else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n                }\n                return audioParam;\n            }\n        };\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n        addAudioParamConnections(audioParam, audioParamRenderer);\n        return audioParam;\n    };\n};\n//# sourceMappingURL=audio-param-factory.js.map"]},"metadata":{},"sourceType":"module"}