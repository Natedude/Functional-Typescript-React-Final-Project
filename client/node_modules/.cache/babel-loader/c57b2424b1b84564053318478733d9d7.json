{"ast":null,"code":"import { AudioToGain } from \"../signal/AudioToGain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ModulationSynth } from \"./ModulationSynth\";\n/**\n * AMSynth uses the output of one Tone.Synth to modulate the\n * amplitude of another Tone.Synth. The harmonicity (the ratio between\n * the two signals) affects the timbre of the output signal greatly.\n * Read more about Amplitude Modulation Synthesis on\n * [SoundOnSound](https://web.archive.org/web/20160404103653/http://www.soundonsound.com:80/sos/mar00/articles/synthsecrets.htm).\n *\n * @example\n * const synth = new Tone.AMSynth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"4n\");\n *\n * @category Instrument\n */\n\nexport class AMSynth extends ModulationSynth {\n  constructor() {\n    super(optionsFromArguments(AMSynth.getDefaults(), arguments));\n    this.name = \"AMSynth\";\n    this._modulationScale = new AudioToGain({\n      context: this.context\n    }); // control the two voices frequency\n\n    this.frequency.connect(this._carrier.frequency);\n    this.frequency.chain(this.harmonicity, this._modulator.frequency);\n    this.detune.fan(this._carrier.detune, this._modulator.detune);\n\n    this._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\n    this._carrier.chain(this._modulationNode, this.output);\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._modulationScale.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/instrument/AMSynth.ts"],"names":[],"mappings":"AAAA,SAAS,WAAT,QAA4B,uBAA5B;AAEA,SAAS,oBAAT,QAAqC,uBAArC;AACA,SAAS,eAAT,QAAwD,mBAAxD;AAIA;;;;;;;;;;;;AAYG;;AACH,OAAM,MAAO,OAAP,SAAuB,eAAvB,CAAsD;AAU3D,EAAA,WAAA,GAAA;AACC,UAAM,oBAAoB,CAAC,OAAO,CAAC,WAAR,EAAD,EAAwB,SAAxB,CAA1B;AATQ,SAAA,IAAA,GAAe,SAAf;AAWR,SAAK,gBAAL,GAAwB,IAAI,WAAJ,CAAgB;AACvC,MAAA,OAAO,EAAE,KAAK;AADyB,KAAhB,CAAxB,CAHD,CAOC;;AACA,SAAK,SAAL,CAAe,OAAf,CAAuB,KAAK,QAAL,CAAc,SAArC;AACA,SAAK,SAAL,CAAe,KAAf,CAAqB,KAAK,WAA1B,EAAuC,KAAK,UAAL,CAAgB,SAAvD;AACA,SAAK,MAAL,CAAY,GAAZ,CAAgB,KAAK,QAAL,CAAc,MAA9B,EAAsC,KAAK,UAAL,CAAgB,MAAtD;;AACA,SAAK,UAAL,CAAgB,KAAhB,CAAsB,KAAK,gBAA3B,EAA6C,KAAK,eAAL,CAAqB,IAAlE;;AACA,SAAK,QAAL,CAAc,KAAd,CAAoB,KAAK,eAAzB,EAA0C,KAAK,MAA/C;AACA;;AAED,EAAA,OAAO,GAAA;AACN,UAAM,OAAN;;AACA,SAAK,gBAAL,CAAsB,OAAtB;;AACA,WAAO,IAAP;AACA;;AA7B0D","sourceRoot":"","sourcesContent":["import { AudioToGain } from \"../signal/AudioToGain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ModulationSynth } from \"./ModulationSynth\";\n/**\n * AMSynth uses the output of one Tone.Synth to modulate the\n * amplitude of another Tone.Synth. The harmonicity (the ratio between\n * the two signals) affects the timbre of the output signal greatly.\n * Read more about Amplitude Modulation Synthesis on\n * [SoundOnSound](https://web.archive.org/web/20160404103653/http://www.soundonsound.com:80/sos/mar00/articles/synthsecrets.htm).\n *\n * @example\n * const synth = new Tone.AMSynth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"4n\");\n *\n * @category Instrument\n */\nexport class AMSynth extends ModulationSynth {\n    constructor() {\n        super(optionsFromArguments(AMSynth.getDefaults(), arguments));\n        this.name = \"AMSynth\";\n        this._modulationScale = new AudioToGain({\n            context: this.context,\n        });\n        // control the two voices frequency\n        this.frequency.connect(this._carrier.frequency);\n        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n        this.detune.fan(this._carrier.detune, this._modulator.detune);\n        this._modulator.chain(this._modulationScale, this._modulationNode.gain);\n        this._carrier.chain(this._modulationNode, this.output);\n    }\n    dispose() {\n        super.dispose();\n        this._modulationScale.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=AMSynth.js.map"]},"metadata":{},"sourceType":"module"}