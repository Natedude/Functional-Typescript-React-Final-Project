{"ast":null,"code":"import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\n\nexport class IntervalTimeline extends Tone {\n  constructor() {\n    super(...arguments);\n    this.name = \"IntervalTimeline\";\n    /**\n     * The root node of the inteval tree\n     */\n\n    this._root = null;\n    /**\n     * Keep track of the length of the timeline.\n     */\n\n    this._length = 0;\n  }\n  /**\n   * The event to add to the timeline. All events must\n   * have a time and duration value\n   * @param  event  The event to add to the timeline\n   */\n\n\n  add(event) {\n    assert(isDefined(event.time), \"Events must have a time property\");\n    assert(isDefined(event.duration), \"Events must have a duration parameter\");\n    event.time = event.time.valueOf();\n    let node = new IntervalNode(event.time, event.time + event.duration, event);\n\n    if (this._root === null) {\n      this._root = node;\n    } else {\n      this._root.insert(node);\n    }\n\n    this._length++; // Restructure tree to be balanced\n\n    while (node !== null) {\n      node.updateHeight();\n      node.updateMax();\n\n      this._rebalance(node);\n\n      node = node.parent;\n    }\n\n    return this;\n  }\n  /**\n   * Remove an event from the timeline.\n   * @param  event  The event to remove from the timeline\n   */\n\n\n  remove(event) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.search(event.time, results);\n\n      for (const node of results) {\n        if (node.event === event) {\n          this._removeNode(node);\n\n          this._length--;\n          break;\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * The number of items in the timeline.\n   * @readOnly\n   */\n\n\n  get length() {\n    return this._length;\n  }\n  /**\n   * Remove events whose time time is after the given time\n   * @param  after  The time to query.\n   */\n\n\n  cancel(after) {\n    this.forEachFrom(after, event => this.remove(event));\n    return this;\n  }\n  /**\n   * Set the root node as the given node\n   */\n\n\n  _setRoot(node) {\n    this._root = node;\n\n    if (this._root !== null) {\n      this._root.parent = null;\n    }\n  }\n  /**\n   * Replace the references to the node in the node's parent\n   * with the replacement node.\n   */\n\n\n  _replaceNodeInParent(node, replacement) {\n    if (node.parent !== null) {\n      if (node.isLeftChild()) {\n        node.parent.left = replacement;\n      } else {\n        node.parent.right = replacement;\n      }\n\n      this._rebalance(node.parent);\n    } else {\n      this._setRoot(replacement);\n    }\n  }\n  /**\n   * Remove the node from the tree and replace it with\n   * a successor which follows the schema.\n   */\n\n\n  _removeNode(node) {\n    if (node.left === null && node.right === null) {\n      this._replaceNodeInParent(node, null);\n    } else if (node.right === null) {\n      this._replaceNodeInParent(node, node.left);\n    } else if (node.left === null) {\n      this._replaceNodeInParent(node, node.right);\n    } else {\n      const balance = node.getBalance();\n      let replacement;\n      let temp = null;\n\n      if (balance > 0) {\n        if (node.left.right === null) {\n          replacement = node.left;\n          replacement.right = node.right;\n          temp = replacement;\n        } else {\n          replacement = node.left.right;\n\n          while (replacement.right !== null) {\n            replacement = replacement.right;\n          }\n\n          if (replacement.parent) {\n            replacement.parent.right = replacement.left;\n            temp = replacement.parent;\n            replacement.left = node.left;\n            replacement.right = node.right;\n          }\n        }\n      } else if (node.right.left === null) {\n        replacement = node.right;\n        replacement.left = node.left;\n        temp = replacement;\n      } else {\n        replacement = node.right.left;\n\n        while (replacement.left !== null) {\n          replacement = replacement.left;\n        }\n\n        if (replacement.parent) {\n          replacement.parent.left = replacement.right;\n          temp = replacement.parent;\n          replacement.left = node.left;\n          replacement.right = node.right;\n        }\n      }\n\n      if (node.parent !== null) {\n        if (node.isLeftChild()) {\n          node.parent.left = replacement;\n        } else {\n          node.parent.right = replacement;\n        }\n      } else {\n        this._setRoot(replacement);\n      }\n\n      if (temp) {\n        this._rebalance(temp);\n      }\n    }\n\n    node.dispose();\n  }\n  /**\n   * Rotate the tree to the left\n   */\n\n\n  _rotateLeft(node) {\n    const parent = node.parent;\n    const isLeftChild = node.isLeftChild(); // Make node.right the new root of this sub tree (instead of node)\n\n    const pivotNode = node.right;\n\n    if (pivotNode) {\n      node.right = pivotNode.left;\n      pivotNode.left = node;\n    }\n\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  }\n  /**\n   * Rotate the tree to the right\n   */\n\n\n  _rotateRight(node) {\n    const parent = node.parent;\n    const isLeftChild = node.isLeftChild(); // Make node.left the new root of this sub tree (instead of node)\n\n    const pivotNode = node.left;\n\n    if (pivotNode) {\n      node.left = pivotNode.right;\n      pivotNode.right = node;\n    }\n\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  }\n  /**\n   * Balance the BST\n   */\n\n\n  _rebalance(node) {\n    const balance = node.getBalance();\n\n    if (balance > 1 && node.left) {\n      if (node.left.getBalance() < 0) {\n        this._rotateLeft(node.left);\n      } else {\n        this._rotateRight(node);\n      }\n    } else if (balance < -1 && node.right) {\n      if (node.right.getBalance() > 0) {\n        this._rotateRight(node.right);\n      } else {\n        this._rotateLeft(node);\n      }\n    }\n  }\n  /**\n   * Get an event whose time and duration span the give time. Will\n   * return the match whose \"time\" value is closest to the given time.\n   * @return  The event which spans the desired time\n   */\n\n\n  get(time) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.search(time, results);\n\n      if (results.length > 0) {\n        let max = results[0];\n\n        for (let i = 1; i < results.length; i++) {\n          if (results[i].low > max.low) {\n            max = results[i];\n          }\n        }\n\n        return max.event;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Iterate over everything in the timeline.\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEach(callback) {\n    if (this._root !== null) {\n      const allNodes = [];\n\n      this._root.traverse(node => allNodes.push(node));\n\n      allNodes.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array in which the given time\n   * overlaps with the time and duration time of the event.\n   * @param  time The time to check if items are overlapping\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachAtTime(time, callback) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.search(time, results);\n\n      results.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array in which the time is greater\n   * than or equal to the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachFrom(time, callback) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.searchAfter(time, results);\n\n      results.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (this._root !== null) {\n      this._root.traverse(node => node.dispose());\n    }\n\n    this._root = null;\n    return this;\n  }\n\n} //-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\n\nclass IntervalNode {\n  constructor(low, high, event) {\n    // the nodes to the left\n    this._left = null; // the nodes to the right\n\n    this._right = null; // the parent node\n\n    this.parent = null; // the number of child nodes\n\n    this.height = 0;\n    this.event = event; // the low value\n\n    this.low = low; // the high value\n\n    this.high = high; // the high value for this and all child nodes\n\n    this.max = this.high;\n  }\n  /**\n   * Insert a node into the correct spot in the tree\n   */\n\n\n  insert(node) {\n    if (node.low <= this.low) {\n      if (this.left === null) {\n        this.left = node;\n      } else {\n        this.left.insert(node);\n      }\n    } else if (this.right === null) {\n      this.right = node;\n    } else {\n      this.right.insert(node);\n    }\n  }\n  /**\n   * Search the tree for nodes which overlap\n   * with the given point\n   * @param  point  The point to query\n   * @param  results  The array to put the results\n   */\n\n\n  search(point, results) {\n    // If p is to the right of the rightmost point of any interval\n    // in this node and all children, there won't be any matches.\n    if (point > this.max) {\n      return;\n    } // Search left children\n\n\n    if (this.left !== null) {\n      this.left.search(point, results);\n    } // Check this node\n\n\n    if (this.low <= point && this.high > point) {\n      results.push(this);\n    } // If p is to the left of the time of this interval,\n    // then it can't be in any child to the right.\n\n\n    if (this.low > point) {\n      return;\n    } // Search right children\n\n\n    if (this.right !== null) {\n      this.right.search(point, results);\n    }\n  }\n  /**\n   * Search the tree for nodes which are less\n   * than the given point\n   * @param  point  The point to query\n   * @param  results  The array to put the results\n   */\n\n\n  searchAfter(point, results) {\n    // Check this node\n    if (this.low >= point) {\n      results.push(this);\n\n      if (this.left !== null) {\n        this.left.searchAfter(point, results);\n      }\n    } // search the right side\n\n\n    if (this.right !== null) {\n      this.right.searchAfter(point, results);\n    }\n  }\n  /**\n   * Invoke the callback on this element and both it's branches\n   * @param  {Function}  callback\n   */\n\n\n  traverse(callback) {\n    callback(this);\n\n    if (this.left !== null) {\n      this.left.traverse(callback);\n    }\n\n    if (this.right !== null) {\n      this.right.traverse(callback);\n    }\n  }\n  /**\n   * Update the height of the node\n   */\n\n\n  updateHeight() {\n    if (this.left !== null && this.right !== null) {\n      this.height = Math.max(this.left.height, this.right.height) + 1;\n    } else if (this.right !== null) {\n      this.height = this.right.height + 1;\n    } else if (this.left !== null) {\n      this.height = this.left.height + 1;\n    } else {\n      this.height = 0;\n    }\n  }\n  /**\n   * Update the height of the node\n   */\n\n\n  updateMax() {\n    this.max = this.high;\n\n    if (this.left !== null) {\n      this.max = Math.max(this.max, this.left.max);\n    }\n\n    if (this.right !== null) {\n      this.max = Math.max(this.max, this.right.max);\n    }\n  }\n  /**\n   * The balance is how the leafs are distributed on the node\n   * @return  Negative numbers are balanced to the right\n   */\n\n\n  getBalance() {\n    let balance = 0;\n\n    if (this.left !== null && this.right !== null) {\n      balance = this.left.height - this.right.height;\n    } else if (this.left !== null) {\n      balance = this.left.height + 1;\n    } else if (this.right !== null) {\n      balance = -(this.right.height + 1);\n    }\n\n    return balance;\n  }\n  /**\n   * @returns true if this node is the left child of its parent\n   */\n\n\n  isLeftChild() {\n    return this.parent !== null && this.parent.left === this;\n  }\n  /**\n   * get/set the left node\n   */\n\n\n  get left() {\n    return this._left;\n  }\n\n  set left(node) {\n    this._left = node;\n\n    if (node !== null) {\n      node.parent = this;\n    }\n\n    this.updateHeight();\n    this.updateMax();\n  }\n  /**\n   * get/set the right node\n   */\n\n\n  get right() {\n    return this._right;\n  }\n\n  set right(node) {\n    this._right = node;\n\n    if (node !== null) {\n      node.parent = this;\n    }\n\n    this.updateHeight();\n    this.updateMax();\n  }\n  /**\n   * null out references.\n   */\n\n\n  dispose() {\n    this.parent = null;\n    this._left = null;\n    this._right = null;\n    this.event = null;\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/core/util/IntervalTimeline.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n    constructor() {\n        super(...arguments);\n        this.name = \"IntervalTimeline\";\n        /**\n         * The root node of the inteval tree\n         */\n        this._root = null;\n        /**\n         * Keep track of the length of the timeline.\n         */\n        this._length = 0;\n    }\n    /**\n     * The event to add to the timeline. All events must\n     * have a time and duration value\n     * @param  event  The event to add to the timeline\n     */\n    add(event) {\n        assert(isDefined(event.time), \"Events must have a time property\");\n        assert(isDefined(event.duration), \"Events must have a duration parameter\");\n        event.time = event.time.valueOf();\n        let node = new IntervalNode(event.time, event.time + event.duration, event);\n        if (this._root === null) {\n            this._root = node;\n        }\n        else {\n            this._root.insert(node);\n        }\n        this._length++;\n        // Restructure tree to be balanced\n        while (node !== null) {\n            node.updateHeight();\n            node.updateMax();\n            this._rebalance(node);\n            node = node.parent;\n        }\n        return this;\n    }\n    /**\n     * Remove an event from the timeline.\n     * @param  event  The event to remove from the timeline\n     */\n    remove(event) {\n        if (this._root !== null) {\n            const results = [];\n            this._root.search(event.time, results);\n            for (const node of results) {\n                if (node.event === event) {\n                    this._removeNode(node);\n                    this._length--;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * The number of items in the timeline.\n     * @readOnly\n     */\n    get length() {\n        return this._length;\n    }\n    /**\n     * Remove events whose time time is after the given time\n     * @param  after  The time to query.\n     */\n    cancel(after) {\n        this.forEachFrom(after, event => this.remove(event));\n        return this;\n    }\n    /**\n     * Set the root node as the given node\n     */\n    _setRoot(node) {\n        this._root = node;\n        if (this._root !== null) {\n            this._root.parent = null;\n        }\n    }\n    /**\n     * Replace the references to the node in the node's parent\n     * with the replacement node.\n     */\n    _replaceNodeInParent(node, replacement) {\n        if (node.parent !== null) {\n            if (node.isLeftChild()) {\n                node.parent.left = replacement;\n            }\n            else {\n                node.parent.right = replacement;\n            }\n            this._rebalance(node.parent);\n        }\n        else {\n            this._setRoot(replacement);\n        }\n    }\n    /**\n     * Remove the node from the tree and replace it with\n     * a successor which follows the schema.\n     */\n    _removeNode(node) {\n        if (node.left === null && node.right === null) {\n            this._replaceNodeInParent(node, null);\n        }\n        else if (node.right === null) {\n            this._replaceNodeInParent(node, node.left);\n        }\n        else if (node.left === null) {\n            this._replaceNodeInParent(node, node.right);\n        }\n        else {\n            const balance = node.getBalance();\n            let replacement;\n            let temp = null;\n            if (balance > 0) {\n                if (node.left.right === null) {\n                    replacement = node.left;\n                    replacement.right = node.right;\n                    temp = replacement;\n                }\n                else {\n                    replacement = node.left.right;\n                    while (replacement.right !== null) {\n                        replacement = replacement.right;\n                    }\n                    if (replacement.parent) {\n                        replacement.parent.right = replacement.left;\n                        temp = replacement.parent;\n                        replacement.left = node.left;\n                        replacement.right = node.right;\n                    }\n                }\n            }\n            else if (node.right.left === null) {\n                replacement = node.right;\n                replacement.left = node.left;\n                temp = replacement;\n            }\n            else {\n                replacement = node.right.left;\n                while (replacement.left !== null) {\n                    replacement = replacement.left;\n                }\n                if (replacement.parent) {\n                    replacement.parent.left = replacement.right;\n                    temp = replacement.parent;\n                    replacement.left = node.left;\n                    replacement.right = node.right;\n                }\n            }\n            if (node.parent !== null) {\n                if (node.isLeftChild()) {\n                    node.parent.left = replacement;\n                }\n                else {\n                    node.parent.right = replacement;\n                }\n            }\n            else {\n                this._setRoot(replacement);\n            }\n            if (temp) {\n                this._rebalance(temp);\n            }\n        }\n        node.dispose();\n    }\n    /**\n     * Rotate the tree to the left\n     */\n    _rotateLeft(node) {\n        const parent = node.parent;\n        const isLeftChild = node.isLeftChild();\n        // Make node.right the new root of this sub tree (instead of node)\n        const pivotNode = node.right;\n        if (pivotNode) {\n            node.right = pivotNode.left;\n            pivotNode.left = node;\n        }\n        if (parent !== null) {\n            if (isLeftChild) {\n                parent.left = pivotNode;\n            }\n            else {\n                parent.right = pivotNode;\n            }\n        }\n        else {\n            this._setRoot(pivotNode);\n        }\n    }\n    /**\n     * Rotate the tree to the right\n     */\n    _rotateRight(node) {\n        const parent = node.parent;\n        const isLeftChild = node.isLeftChild();\n        // Make node.left the new root of this sub tree (instead of node)\n        const pivotNode = node.left;\n        if (pivotNode) {\n            node.left = pivotNode.right;\n            pivotNode.right = node;\n        }\n        if (parent !== null) {\n            if (isLeftChild) {\n                parent.left = pivotNode;\n            }\n            else {\n                parent.right = pivotNode;\n            }\n        }\n        else {\n            this._setRoot(pivotNode);\n        }\n    }\n    /**\n     * Balance the BST\n     */\n    _rebalance(node) {\n        const balance = node.getBalance();\n        if (balance > 1 && node.left) {\n            if (node.left.getBalance() < 0) {\n                this._rotateLeft(node.left);\n            }\n            else {\n                this._rotateRight(node);\n            }\n        }\n        else if (balance < -1 && node.right) {\n            if (node.right.getBalance() > 0) {\n                this._rotateRight(node.right);\n            }\n            else {\n                this._rotateLeft(node);\n            }\n        }\n    }\n    /**\n     * Get an event whose time and duration span the give time. Will\n     * return the match whose \"time\" value is closest to the given time.\n     * @return  The event which spans the desired time\n     */\n    get(time) {\n        if (this._root !== null) {\n            const results = [];\n            this._root.search(time, results);\n            if (results.length > 0) {\n                let max = results[0];\n                for (let i = 1; i < results.length; i++) {\n                    if (results[i].low > max.low) {\n                        max = results[i];\n                    }\n                }\n                return max.event;\n            }\n        }\n        return null;\n    }\n    /**\n     * Iterate over everything in the timeline.\n     * @param  callback The callback to invoke with every item\n     */\n    forEach(callback) {\n        if (this._root !== null) {\n            const allNodes = [];\n            this._root.traverse(node => allNodes.push(node));\n            allNodes.forEach(node => {\n                if (node.event) {\n                    callback(node.event);\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * Iterate over everything in the array in which the given time\n     * overlaps with the time and duration time of the event.\n     * @param  time The time to check if items are overlapping\n     * @param  callback The callback to invoke with every item\n     */\n    forEachAtTime(time, callback) {\n        if (this._root !== null) {\n            const results = [];\n            this._root.search(time, results);\n            results.forEach(node => {\n                if (node.event) {\n                    callback(node.event);\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * Iterate over everything in the array in which the time is greater\n     * than or equal to the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n    forEachFrom(time, callback) {\n        if (this._root !== null) {\n            const results = [];\n            this._root.searchAfter(time, results);\n            results.forEach(node => {\n                if (node.event) {\n                    callback(node.event);\n                }\n            });\n        }\n        return this;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        if (this._root !== null) {\n            this._root.traverse(node => node.dispose());\n        }\n        this._root = null;\n        return this;\n    }\n}\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nclass IntervalNode {\n    constructor(low, high, event) {\n        // the nodes to the left\n        this._left = null;\n        // the nodes to the right\n        this._right = null;\n        // the parent node\n        this.parent = null;\n        // the number of child nodes\n        this.height = 0;\n        this.event = event;\n        // the low value\n        this.low = low;\n        // the high value\n        this.high = high;\n        // the high value for this and all child nodes\n        this.max = this.high;\n    }\n    /**\n     * Insert a node into the correct spot in the tree\n     */\n    insert(node) {\n        if (node.low <= this.low) {\n            if (this.left === null) {\n                this.left = node;\n            }\n            else {\n                this.left.insert(node);\n            }\n        }\n        else if (this.right === null) {\n            this.right = node;\n        }\n        else {\n            this.right.insert(node);\n        }\n    }\n    /**\n     * Search the tree for nodes which overlap\n     * with the given point\n     * @param  point  The point to query\n     * @param  results  The array to put the results\n     */\n    search(point, results) {\n        // If p is to the right of the rightmost point of any interval\n        // in this node and all children, there won't be any matches.\n        if (point > this.max) {\n            return;\n        }\n        // Search left children\n        if (this.left !== null) {\n            this.left.search(point, results);\n        }\n        // Check this node\n        if (this.low <= point && this.high > point) {\n            results.push(this);\n        }\n        // If p is to the left of the time of this interval,\n        // then it can't be in any child to the right.\n        if (this.low > point) {\n            return;\n        }\n        // Search right children\n        if (this.right !== null) {\n            this.right.search(point, results);\n        }\n    }\n    /**\n     * Search the tree for nodes which are less\n     * than the given point\n     * @param  point  The point to query\n     * @param  results  The array to put the results\n     */\n    searchAfter(point, results) {\n        // Check this node\n        if (this.low >= point) {\n            results.push(this);\n            if (this.left !== null) {\n                this.left.searchAfter(point, results);\n            }\n        }\n        // search the right side\n        if (this.right !== null) {\n            this.right.searchAfter(point, results);\n        }\n    }\n    /**\n     * Invoke the callback on this element and both it's branches\n     * @param  {Function}  callback\n     */\n    traverse(callback) {\n        callback(this);\n        if (this.left !== null) {\n            this.left.traverse(callback);\n        }\n        if (this.right !== null) {\n            this.right.traverse(callback);\n        }\n    }\n    /**\n     * Update the height of the node\n     */\n    updateHeight() {\n        if (this.left !== null && this.right !== null) {\n            this.height = Math.max(this.left.height, this.right.height) + 1;\n        }\n        else if (this.right !== null) {\n            this.height = this.right.height + 1;\n        }\n        else if (this.left !== null) {\n            this.height = this.left.height + 1;\n        }\n        else {\n            this.height = 0;\n        }\n    }\n    /**\n     * Update the height of the node\n     */\n    updateMax() {\n        this.max = this.high;\n        if (this.left !== null) {\n            this.max = Math.max(this.max, this.left.max);\n        }\n        if (this.right !== null) {\n            this.max = Math.max(this.max, this.right.max);\n        }\n    }\n    /**\n     * The balance is how the leafs are distributed on the node\n     * @return  Negative numbers are balanced to the right\n     */\n    getBalance() {\n        let balance = 0;\n        if (this.left !== null && this.right !== null) {\n            balance = this.left.height - this.right.height;\n        }\n        else if (this.left !== null) {\n            balance = this.left.height + 1;\n        }\n        else if (this.right !== null) {\n            balance = -(this.right.height + 1);\n        }\n        return balance;\n    }\n    /**\n     * @returns true if this node is the left child of its parent\n     */\n    isLeftChild() {\n        return this.parent !== null && this.parent.left === this;\n    }\n    /**\n     * get/set the left node\n     */\n    get left() {\n        return this._left;\n    }\n    set left(node) {\n        this._left = node;\n        if (node !== null) {\n            node.parent = this;\n        }\n        this.updateHeight();\n        this.updateMax();\n    }\n    /**\n     * get/set the right node\n     */\n    get right() {\n        return this._right;\n    }\n    set right(node) {\n        this._right = node;\n        if (node !== null) {\n            node.parent = this;\n        }\n        this.updateHeight();\n        this.updateMax();\n    }\n    /**\n     * null out references.\n     */\n    dispose() {\n        this.parent = null;\n        this._left = null;\n        this._right = null;\n        this.event = null;\n    }\n}\n//# sourceMappingURL=IntervalTimeline.js.map"]},"metadata":{},"sourceType":"module"}