{"ast":null,"code":"import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\n\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioParamConnections(destination);\n  const {\n    outputs\n  } = getAudioNodeConnections(source);\n  const eventListeners = getEventListenersOfAudioNode(source);\n\n  const eventListener = isActive => {\n    const nativeAudioNode = getNativeAudioNode(source);\n    const nativeAudioParam = getNativeAudioParam(destination);\n\n    if (isActive) {\n      const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n      addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.connect(nativeAudioParam, output);\n      }\n    } else {\n      const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n      addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.disconnect(nativeAudioParam, output);\n      }\n    }\n  };\n\n  if (insertElementInSet(outputs, [destination, output], outputConnection => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n    eventListeners.add(eventListener);\n\n    if (isActiveAudioNode(source)) {\n      addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n    } else {\n      addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioNodeConnections(destination);\n  const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n  if (activeInputConnection === null) {\n    const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n    return [passiveInputConnection[2], false];\n  }\n\n  return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioParamConnections(destination);\n  const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n  if (activeInputConnection === null) {\n    const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n    return [passiveInputConnection[1], false];\n  }\n\n  return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = (source, isOffline, destination, output, input) => {\n  const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n    }\n  }\n\n  if (isActiveAudioNode(destination)) {\n    const {\n      activeInputs\n    } = getAudioNodeConnections(destination);\n    setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n  }\n};\n\nconst deleteInputsOfAudioParam = (source, isOffline, destination, output) => {\n  const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n    }\n  }\n};\n\nconst deleteAnyConnection = (source, isOffline) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  const destinations = [];\n\n  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n    } else {\n      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n    }\n\n    destinations.push(outputConnection[0]);\n  }\n\n  audioNodeConnectionsOfSource.outputs.clear();\n  return destinations;\n};\n\nconst deleteConnectionAtOutput = (source, isOffline, output) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  const destinations = [];\n\n  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n    if (outputConnection[1] === output) {\n      if (isAudioNodeOutputConnection(outputConnection)) {\n        deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n      } else {\n        deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n      }\n\n      destinations.push(outputConnection[0]);\n      audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    }\n  }\n\n  return destinations;\n};\n\nconst deleteConnectionToDestination = (source, isOffline, destination, output, input) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  return Array.from(audioNodeConnectionsOfSource.outputs).filter(outputConnection => outputConnection[0] === destination && (output === undefined || outputConnection[1] === output) && (input === undefined || outputConnection[2] === input)).map(outputConnection => {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n    } else {\n      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n    }\n\n    audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    return outputConnection[0];\n  });\n};\n\nexport const createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext) => {\n  return class AudioNode extends eventTargetConstructor {\n    constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n      super(nativeAudioNode);\n      this._context = context;\n      this._nativeAudioNode = nativeAudioNode;\n      const nativeContext = getNativeContext(context); // Bug #12: Safari does not support to disconnect a specific destination.\n\n      if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n        return testAudioNodeDisconnectMethodSupport(nativeContext);\n      })) {\n        wrapAudioNodeDisconnectMethod(nativeAudioNode);\n      }\n\n      AUDIO_NODE_STORE.set(this, nativeAudioNode);\n      EVENT_LISTENERS.set(this, new Set());\n\n      if (context.state !== 'closed' && isActive) {\n        setInternalStateToActive(this);\n      }\n\n      addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n    }\n\n    get channelCount() {\n      return this._nativeAudioNode.channelCount;\n    }\n\n    set channelCount(value) {\n      this._nativeAudioNode.channelCount = value;\n    }\n\n    get channelCountMode() {\n      return this._nativeAudioNode.channelCountMode;\n    }\n\n    set channelCountMode(value) {\n      this._nativeAudioNode.channelCountMode = value;\n    }\n\n    get channelInterpretation() {\n      return this._nativeAudioNode.channelInterpretation;\n    }\n\n    set channelInterpretation(value) {\n      this._nativeAudioNode.channelInterpretation = value;\n    }\n\n    get context() {\n      return this._context;\n    }\n\n    get numberOfInputs() {\n      return this._nativeAudioNode.numberOfInputs;\n    }\n\n    get numberOfOutputs() {\n      return this._nativeAudioNode.numberOfOutputs;\n    } // tslint:disable-next-line:invalid-void\n\n\n    connect(destination, output = 0, input = 0) {\n      // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n      if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n        throw createIndexSizeError();\n      }\n\n      const nativeContext = getNativeContext(this._context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n      if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n        throw createInvalidAccessError();\n      }\n\n      if (isAudioNode(destination)) {\n        const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n        try {\n          const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n          const isPassive = isPassiveAudioNode(this);\n\n          if (isOffline || isPassive) {\n            this._nativeAudioNode.disconnect(...connection);\n          }\n\n          if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n            setInternalStateToActive(destination);\n          }\n        } catch (err) {\n          // Bug #41: Safari does not throw the correct exception so far.\n          if (err.code === 12) {\n            throw createInvalidAccessError();\n          }\n\n          throw err;\n        }\n\n        const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline); // Bug #164: Only Firefox detects cycles so far.\n\n        if (isNewConnectionToAudioNode) {\n          const cycles = detectCycles([this], destination);\n          visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n        }\n\n        return destination;\n      }\n\n      const nativeAudioParam = getNativeAudioParam(destination);\n      /*\n       * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n       * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n       * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n       */\n\n      if (nativeAudioParam.name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n        throw createNotSupportedError();\n      }\n\n      try {\n        this._nativeAudioNode.connect(nativeAudioParam, output);\n\n        if (isOffline || isPassiveAudioNode(this)) {\n          this._nativeAudioNode.disconnect(nativeAudioParam, output);\n        }\n      } catch (err) {\n        // Bug #58: Only Firefox does throw an InvalidAccessError yet.\n        if (err.code === 12) {\n          throw createInvalidAccessError();\n        }\n\n        throw err;\n      }\n\n      const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline); // Bug #164: Only Firefox detects cycles so far.\n\n      if (isNewConnectionToAudioParam) {\n        const cycles = detectCycles([this], destination);\n        visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n      }\n    }\n\n    disconnect(destinationOrOutput, output, input) {\n      let destinations;\n      const nativeContext = getNativeContext(this._context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n      if (destinationOrOutput === undefined) {\n        destinations = deleteAnyConnection(this, isOffline);\n      } else if (typeof destinationOrOutput === 'number') {\n        if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n          throw createIndexSizeError();\n        }\n\n        destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n      } else {\n        if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n          throw createIndexSizeError();\n        }\n\n        if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n          throw createIndexSizeError();\n        }\n\n        destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n        if (destinations.length === 0) {\n          throw createInvalidAccessError();\n        }\n      } // Bug #164: Only Firefox detects cycles so far.\n\n\n      for (const destination of destinations) {\n        const cycles = detectCycles([this], destination);\n        visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n      }\n    }\n\n  };\n};","map":{"version":3,"sources":["../../../src/factories/audio-node-constructor.ts"],"names":[],"mappings":"AAAA,SAAS,gBAAT,EAA2B,eAA3B,QAAkD,YAAlD;AACA,SAAS,WAAT,QAA4B,sBAA5B;AACA,SAAS,2BAAT,QAA4C,wCAA5C;AACA,SAAS,oCAAT,QAAqD,uDAArD;AACA,SAAS,qCAAT,QAAsD,wDAAtD;AACA,SAAS,uCAAT,QAAwD,2DAAxD;AACA,SAAS,2BAAT,QAA4C,2CAA5C;AACA,SAAS,uCAAT,QAAwD,0DAAxD;AACA,SAAS,8BAAT,QAA+C,iDAA/C;AACA,SAAS,uCAAT,QAAwD,0DAAxD;AACA,SAAS,wCAAT,QAAyD,2DAAzD;AACA,SAAS,4CAAT,QAA6D,gEAA7D;AACA,SAAS,uBAAT,QAAwC,uCAAxC;AACA,SAAS,wBAAT,QAAyC,wCAAzC;AACA,SAAS,4BAAT,QAA6C,8CAA7C;AACA,SAAS,kBAAT,QAAmC,kCAAnC;AACA,SAAS,mBAAT,QAAoC,mCAApC;AACA,SAAS,kBAAT,QAAmC,kCAAnC;AACA,SAAS,iBAAT,QAAkC,iCAAlC;AACA,SAAS,cAAT,QAA+B,+BAA/B;AACA,SAAS,kBAAT,QAAmC,kCAAnC;AACA,SAAS,wBAAT,QAAyC,yCAAzC;AACA,SAAS,sCAAT,QAAuD,yDAAvD;AACA,SAAS,oCAAT,QAAqD,sDAArD;AACA,SAAS,sBAAT,QAAuC,uCAAvC;AACA,SAAS,6BAAT,QAA8C,8CAA9C;;AAmBA,MAAM,uCAAuC,GAAG,CAC5C,MAD4C,EAE5C,WAF4C,EAG5C,MAH4C,EAI5C,SAJ4C,KAKnC;AACT,QAAM;AAAE,IAAA,YAAF;AAAgB,IAAA;AAAhB,MAAkC,wBAAwB,CAAI,WAAJ,CAAhE;AACA,QAAM;AAAE,IAAA;AAAF,MAAc,uBAAuB,CAAC,MAAD,CAA3C;AACA,QAAM,cAAc,GAAG,4BAA4B,CAAC,MAAD,CAAnD;;AAEA,QAAM,aAAa,GAAiC,QAAD,IAAa;AAC5D,UAAM,eAAe,GAAG,kBAAkB,CAAC,MAAD,CAA1C;AACA,UAAM,gBAAgB,GAAG,mBAAmB,CAAC,WAAD,CAA5C;;AAEA,QAAI,QAAJ,EAAc;AACV,YAAM,iBAAiB,GAAG,wCAAwC,CAAC,aAAD,EAAgB,MAAhB,EAAwB,MAAxB,CAAlE;AAEA,MAAA,oCAAoC,CAAC,YAAD,EAAe,MAAf,EAAuB,iBAAvB,EAA0C,KAA1C,CAApC;;AAEA,UAAI,CAAC,SAAD,IAAc,CAAC,cAAc,CAAC,MAAD,CAAjC,EAA2C;AACvC,QAAA,eAAe,CAAC,OAAhB,CAAwB,gBAAxB,EAA0C,MAA1C;AACH;AACJ,KARD,MAQO;AACH,YAAM,iBAAiB,GAAG,uCAAuC,CAAC,YAAD,EAAe,MAAf,EAAuB,MAAvB,CAAjE;AAEA,MAAA,qCAAqC,CAAC,aAAD,EAAgB,iBAAhB,EAAmC,KAAnC,CAArC;;AAEA,UAAI,CAAC,SAAD,IAAc,CAAC,cAAc,CAAC,MAAD,CAAjC,EAA2C;AACvC,QAAA,eAAe,CAAC,UAAhB,CAA2B,gBAA3B,EAA6C,MAA7C;AACH;AACJ;AACJ,GArBD;;AAuBA,MACI,kBAAkB,CACd,OADc,EAEd,CAAC,WAAD,EAAc,MAAd,CAFc,EAGb,gBAAD,IAAsB,gBAAgB,CAAC,CAAD,CAAhB,KAAwB,WAAxB,IAAuC,gBAAgB,CAAC,CAAD,CAAhB,KAAwB,MAHvE,EAId,IAJc,CADtB,EAOE;AACE,IAAA,cAAc,CAAC,GAAf,CAAmB,aAAnB;;AAEA,QAAI,iBAAiB,CAAC,MAAD,CAArB,EAA+B;AAC3B,MAAA,oCAAoC,CAAC,YAAD,EAAe,MAAf,EAAuB,CAAC,MAAD,EAAS,aAAT,CAAvB,EAAgD,IAAhD,CAApC;AACH,KAFD,MAEO;AACH,MAAA,qCAAqC,CAAC,aAAD,EAAgB,CAAC,MAAD,EAAS,MAAT,EAAiB,aAAjB,CAAhB,EAAiD,IAAjD,CAArC;AACH;;AAED,WAAO,IAAP;AACH;;AAED,SAAO,KAAP;AACH,CArDD;;AAuDA,MAAM,gCAAgC,GAAG,CACrC,MADqC,EAErC,WAFqC,EAGrC,MAHqC,EAIrC,KAJqC,KAKU;AAC/C,QAAM;AAAE,IAAA,YAAF;AAAgB,IAAA;AAAhB,MAAkC,uBAAuB,CAAC,WAAD,CAA/D;AAEA,QAAM,qBAAqB,GAAG,2BAA2B,CAAC,YAAY,CAAC,KAAD,CAAb,EAAsB,MAAtB,EAA8B,MAA9B,CAAzD;;AAEA,MAAI,qBAAqB,KAAK,IAA9B,EAAoC;AAChC,UAAM,sBAAsB,GAAG,uCAAuC,CAAC,aAAD,EAAgB,MAAhB,EAAwB,MAAxB,EAAgC,KAAhC,CAAtE;AAEA,WAAO,CAAC,sBAAsB,CAAC,CAAD,CAAvB,EAA4B,KAA5B,CAAP;AACH;;AAED,SAAO,CAAC,qBAAqB,CAAC,CAAD,CAAtB,EAA2B,IAA3B,CAAP;AACH,CAjBD;;AAmBA,MAAM,iCAAiC,GAAG,CACtC,MADsC,EAEtC,WAFsC,EAGtC,MAHsC,KAIS;AAC/C,QAAM;AAAE,IAAA,YAAF;AAAgB,IAAA;AAAhB,MAAkC,wBAAwB,CAAI,WAAJ,CAAhE;AAEA,QAAM,qBAAqB,GAAG,2BAA2B,CAAC,YAAD,EAAe,MAAf,EAAuB,MAAvB,CAAzD;;AAEA,MAAI,qBAAqB,KAAK,IAA9B,EAAoC;AAChC,UAAM,sBAAsB,GAAG,wCAAwC,CAAC,aAAD,EAAgB,MAAhB,EAAwB,MAAxB,CAAvE;AAEA,WAAO,CAAC,sBAAsB,CAAC,CAAD,CAAvB,EAA4B,KAA5B,CAAP;AACH;;AAED,SAAO,CAAC,qBAAqB,CAAC,CAAD,CAAtB,EAA2B,IAA3B,CAAP;AACH,CAhBD;;AAkBA,MAAM,uBAAuB,GAAG,CAC5B,MAD4B,EAE5B,SAF4B,EAG5B,WAH4B,EAI5B,MAJ4B,EAK5B,KAL4B,KAM5B;AACA,QAAM,CAAC,QAAD,EAAW,QAAX,IAAuB,gCAAgC,CAAC,MAAD,EAAS,WAAT,EAAsB,MAAtB,EAA8B,KAA9B,CAA7D;;AAEA,MAAI,QAAQ,KAAK,IAAjB,EAAuB;AACnB,IAAA,8BAA8B,CAAC,MAAD,EAAS,QAAT,CAA9B;;AAEA,QAAI,QAAQ,IAAI,CAAC,SAAb,IAA0B,CAAC,cAAc,CAAC,MAAD,CAA7C,EAAuD;AACnD,MAAA,4CAA4C,CAAC,kBAAkB,CAAC,MAAD,CAAnB,EAA6B,kBAAkB,CAAC,WAAD,CAA/C,EAA8D,MAA9D,EAAsE,KAAtE,CAA5C;AACH;AACJ;;AAED,MAAI,iBAAiB,CAAC,WAAD,CAArB,EAAoC;AAChC,UAAM;AAAE,MAAA;AAAF,QAAmB,uBAAuB,CAAC,WAAD,CAAhD;AAEA,IAAA,sCAAsC,CAAC,WAAD,EAAc,YAAd,CAAtC;AACH;AACJ,CAtBD;;AAwBA,MAAM,wBAAwB,GAAG,CAC7B,MAD6B,EAE7B,SAF6B,EAG7B,WAH6B,EAI7B,MAJ6B,KAK7B;AACA,QAAM,CAAC,QAAD,EAAW,QAAX,IAAuB,iCAAiC,CAAC,MAAD,EAAS,WAAT,EAAsB,MAAtB,CAA9D;;AAEA,MAAI,QAAQ,KAAK,IAAjB,EAAuB;AACnB,IAAA,8BAA8B,CAAC,MAAD,EAAS,QAAT,CAA9B;;AAEA,QAAI,QAAQ,IAAI,CAAC,SAAb,IAA0B,CAAC,cAAc,CAAC,MAAD,CAA7C,EAAuD;AACnD,MAAA,kBAAkB,CAAC,MAAD,CAAlB,CAA2B,UAA3B,CAAsC,mBAAmB,CAAC,WAAD,CAAzD,EAAwE,MAAxE;AACH;AACJ;AACJ,CAfD;;AAiBA,MAAM,mBAAmB,GAAG,CAAqB,MAArB,EAA4C,SAA5C,KAAmG;AAC3H,QAAM,4BAA4B,GAAG,uBAAuB,CAAC,MAAD,CAA5D;AACA,QAAM,YAAY,GAAG,EAArB;;AAEA,OAAK,MAAM,gBAAX,IAA+B,4BAA4B,CAAC,OAA5D,EAAqE;AACjE,QAAI,2BAA2B,CAAC,gBAAD,CAA/B,EAAmD;AAC/C,MAAA,uBAAuB,CAAC,MAAD,EAAS,SAAT,EAAoB,GAAG,gBAAvB,CAAvB;AACH,KAFD,MAEO;AACH,MAAA,wBAAwB,CAAC,MAAD,EAAS,SAAT,EAAoB,GAAG,gBAAvB,CAAxB;AACH;;AAED,IAAA,YAAY,CAAC,IAAb,CAAkB,gBAAgB,CAAC,CAAD,CAAlC;AACH;;AAED,EAAA,4BAA4B,CAAC,OAA7B,CAAqC,KAArC;AAEA,SAAO,YAAP;AACH,CAjBD;;AAmBA,MAAM,wBAAwB,GAAG,CAC7B,MAD6B,EAE7B,SAF6B,EAG7B,MAH6B,KAII;AACjC,QAAM,4BAA4B,GAAG,uBAAuB,CAAC,MAAD,CAA5D;AACA,QAAM,YAAY,GAAG,EAArB;;AAEA,OAAK,MAAM,gBAAX,IAA+B,4BAA4B,CAAC,OAA5D,EAAqE;AACjE,QAAI,gBAAgB,CAAC,CAAD,CAAhB,KAAwB,MAA5B,EAAoC;AAChC,UAAI,2BAA2B,CAAC,gBAAD,CAA/B,EAAmD;AAC/C,QAAA,uBAAuB,CAAC,MAAD,EAAS,SAAT,EAAoB,GAAG,gBAAvB,CAAvB;AACH,OAFD,MAEO;AACH,QAAA,wBAAwB,CAAC,MAAD,EAAS,SAAT,EAAoB,GAAG,gBAAvB,CAAxB;AACH;;AAED,MAAA,YAAY,CAAC,IAAb,CAAkB,gBAAgB,CAAC,CAAD,CAAlC;AACA,MAAA,4BAA4B,CAAC,OAA7B,CAAqC,MAArC,CAA4C,gBAA5C;AACH;AACJ;;AAED,SAAO,YAAP;AACH,CAtBD;;AAwBA,MAAM,6BAA6B,GAAG,CAClC,MADkC,EAElC,SAFkC,EAGlC,WAHkC,EAIlC,MAJkC,EAKlC,KALkC,KAMD;AACjC,QAAM,4BAA4B,GAAG,uBAAuB,CAAC,MAAD,CAA5D;AAEA,SAAO,KAAK,CAAC,IAAN,CAAW,4BAA4B,CAAC,OAAxC,EACF,MADE,CAEE,gBAAD,IACI,gBAAgB,CAAC,CAAD,CAAhB,KAAwB,WAAxB,KACC,MAAM,KAAK,SAAX,IAAwB,gBAAgB,CAAC,CAAD,CAAhB,KAAwB,MADjD,MAEC,KAAK,KAAK,SAAV,IAAuB,gBAAgB,CAAC,CAAD,CAAhB,KAAwB,KAFhD,CAHL,EAOF,GAPE,CAOG,gBAAD,IAAqB;AACtB,QAAI,2BAA2B,CAAC,gBAAD,CAA/B,EAAmD;AAC/C,MAAA,uBAAuB,CAAC,MAAD,EAAS,SAAT,EAAoB,GAAG,gBAAvB,CAAvB;AACH,KAFD,MAEO;AACH,MAAA,wBAAwB,CAAC,MAAD,EAAS,SAAT,EAAoB,GAAG,gBAAvB,CAAxB;AACH;;AAED,IAAA,4BAA4B,CAAC,OAA7B,CAAqC,MAArC,CAA4C,gBAA5C;AAEA,WAAO,gBAAgB,CAAC,CAAD,CAAvB;AACH,GAjBE,CAAP;AAkBH,CA3BD;;AA6BA,OAAO,MAAM,0BAA0B,GAAiC,CACpE,uBADoE,EAEpE,wBAFoE,EAGpE,eAHoE,EAIpE,2BAJoE,EAKpE,oBALoE,EAMpE,wBANoE,EAOpE,uBAPoE,EAQpE,qBARoE,EASpE,YAToE,EAUpE,sBAVoE,EAWpE,gBAXoE,EAYpE,oBAZoE,EAapE,iBAboE,EAcpE,kBAdoE,EAepE,2BAfoE,KAgBpE;AACA,SAAO,MAAM,SAAN,SACK,sBADL,CACqC;AAOxC,IAAA,WAAA,CACI,OADJ,EAEI,QAFJ,EAGI,eAHJ,EAII,iBAJJ,EAIiI;AAE7H,YAAM,eAAN;AAEA,WAAK,QAAL,GAAgB,OAAhB;AACA,WAAK,gBAAL,GAAwB,eAAxB;AAEA,YAAM,aAAa,GAAG,gBAAgB,CAAC,OAAD,CAAtC,CAP6H,CAS7H;;AACA,UACI,oBAAoB,CAAC,aAAD,CAApB,IACA,SACI,eAAe,CAAC,oCAAD,EAAuC,MAAK;AACvD,eAAO,oCAAoC,CAAC,aAAD,CAA3C;AACH,OAFc,CAHvB,EAME;AACE,QAAA,6BAA6B,CAAC,eAAD,CAA7B;AACH;;AAED,MAAA,gBAAgB,CAAC,GAAjB,CAAqB,IAArB,EAA2B,eAA3B;AACA,MAAA,eAAe,CAAC,GAAhB,CAAoB,IAApB,EAA0B,IAAI,GAAJ,EAA1B;;AAEA,UAAI,OAAO,CAAC,KAAR,KAAkB,QAAlB,IAA8B,QAAlC,EAA4C;AACxC,QAAA,wBAAwB,CAAC,IAAD,CAAxB;AACH;;AAED,MAAA,uBAAuB,CAAC,IAAD,EAAO,iBAAP,EAA0B,eAA1B,CAAvB;AACH;;AAEe,QAAZ,YAAY,GAAA;AACZ,aAAO,KAAK,gBAAL,CAAsB,YAA7B;AACH;;AAEe,QAAZ,YAAY,CAAC,KAAD,EAAM;AAClB,WAAK,gBAAL,CAAsB,YAAtB,GAAqC,KAArC;AACH;;AAEmB,QAAhB,gBAAgB,GAAA;AAChB,aAAO,KAAK,gBAAL,CAAsB,gBAA7B;AACH;;AAEmB,QAAhB,gBAAgB,CAAC,KAAD,EAAM;AACtB,WAAK,gBAAL,CAAsB,gBAAtB,GAAyC,KAAzC;AACH;;AAEwB,QAArB,qBAAqB,GAAA;AACrB,aAAO,KAAK,gBAAL,CAAsB,qBAA7B;AACH;;AAEwB,QAArB,qBAAqB,CAAC,KAAD,EAAM;AAC3B,WAAK,gBAAL,CAAsB,qBAAtB,GAA8C,KAA9C;AACH;;AAEU,QAAP,OAAO,GAAA;AACP,aAAO,KAAK,QAAZ;AACH;;AAEiB,QAAd,cAAc,GAAA;AACd,aAAO,KAAK,gBAAL,CAAsB,cAA7B;AACH;;AAEkB,QAAf,eAAe,GAAA;AACf,aAAO,KAAK,gBAAL,CAAsB,eAA7B;AACH,KA3EuC,CA+ExC;;;AACO,IAAA,OAAO,CAA8C,WAA9C,EAA4E,MAAM,GAAG,CAArF,EAAwF,KAAK,GAAG,CAAhG,EAAiG;AAC3G;AACA,UAAI,MAAM,GAAG,CAAT,IAAc,MAAM,IAAI,KAAK,gBAAL,CAAsB,eAAlD,EAAmE;AAC/D,cAAM,oBAAoB,EAA1B;AACH;;AAED,YAAM,aAAa,GAAG,gBAAgB,CAAC,KAAK,QAAN,CAAtC;AACA,YAAM,SAAS,GAAG,2BAA2B,CAAC,aAAD,CAA7C;;AAEA,UAAI,iBAAiB,CAAC,WAAD,CAAjB,IAAkC,kBAAkB,CAAC,WAAD,CAAxD,EAAuE;AACnE,cAAM,wBAAwB,EAA9B;AACH;;AAED,UAAI,WAAW,CAAC,WAAD,CAAf,EAA8B;AAC1B,cAAM,0BAA0B,GAAG,kBAAkB,CAAC,WAAD,CAArD;;AAEA,YAAI;AACA,gBAAM,UAAU,GAAG,uCAAuC,CACtD,KAAK,gBADiD,EAEtD,0BAFsD,EAGtD,MAHsD,EAItD,KAJsD,CAA1D;AAOA,gBAAM,SAAS,GAAG,kBAAkB,CAAC,IAAD,CAApC;;AAEA,cAAI,SAAS,IAAI,SAAjB,EAA4B;AACxB,iBAAK,gBAAL,CAAsB,UAAtB,CAAiC,GAAG,UAApC;AACH;;AAED,cAAI,KAAK,OAAL,CAAa,KAAb,KAAuB,QAAvB,IAAmC,CAAC,SAApC,IAAiD,kBAAkB,CAAC,WAAD,CAAvE,EAAsF;AAClF,YAAA,wBAAwB,CAAC,WAAD,CAAxB;AACH;AACJ,SAjBD,CAiBE,OAAO,GAAP,EAAY;AACV;AACA,cAAI,GAAG,CAAC,IAAJ,KAAa,EAAjB,EAAqB;AACjB,kBAAM,wBAAwB,EAA9B;AACH;;AAED,gBAAM,GAAN;AACH;;AAED,cAAM,0BAA0B,GAAG,wBAAwB,CACvD,IADuD,EAEjC,WAFiC,EAGvD,MAHuD,EAIvD,KAJuD,EAKvD,SALuD,CAA3D,CA7B0B,CAqC1B;;AACA,YAAI,0BAAJ,EAAgC;AAC5B,gBAAM,MAAM,GAAG,YAAY,CAAC,CAAC,IAAD,CAAD,EAAkC,WAAlC,CAA3B;AAEA,UAAA,sBAAsB,CAAC,MAAD,EAAS,2BAA2B,CAAC,SAAD,CAApC,CAAtB;AACH;;AAED,eAAO,WAAP;AACH;;AAED,YAAM,gBAAgB,GAAG,mBAAmB,CAAC,WAAD,CAA5C;AAEA;;;;AAIG;;AACH,UAA2C,gBAAiB,CAAC,IAAlB,KAA2B,cAA3B,IAA6C,gBAAgB,CAAC,QAAjB,KAA8B,IAAtH,EAA4H;AACxH,cAAM,uBAAuB,EAA7B;AACH;;AAED,UAAI;AACA,aAAK,gBAAL,CAAsB,OAAtB,CAA8B,gBAA9B,EAAgD,MAAhD;;AAEA,YAAI,SAAS,IAAI,kBAAkB,CAAC,IAAD,CAAnC,EAA2C;AACvC,eAAK,gBAAL,CAAsB,UAAtB,CAAiC,gBAAjC,EAAmD,MAAnD;AACH;AACJ,OAND,CAME,OAAO,GAAP,EAAY;AACV;AACA,YAAI,GAAG,CAAC,IAAJ,KAAa,EAAjB,EAAqB;AACjB,gBAAM,wBAAwB,EAA9B;AACH;;AAED,cAAM,GAAN;AACH;;AAED,YAAM,2BAA2B,GAAG,uCAAuC,CAAC,IAAD,EAAO,WAAP,EAAoB,MAApB,EAA4B,SAA5B,CAA3E,CAtF2G,CAwF3G;;AACA,UAAI,2BAAJ,EAAiC;AAC7B,cAAM,MAAM,GAAG,YAAY,CAAC,CAAC,IAAD,CAAD,EAAS,WAAT,CAA3B;AAEA,QAAA,sBAAsB,CAAC,MAAD,EAAS,2BAA2B,CAAC,SAAD,CAApC,CAAtB;AACH;AACJ;;AAKM,IAAA,UAAU,CACb,mBADa,EAEb,MAFa,EAGb,KAHa,EAGC;AAEd,UAAI,YAAJ;AAEA,YAAM,aAAa,GAAG,gBAAgB,CAAC,KAAK,QAAN,CAAtC;AACA,YAAM,SAAS,GAAG,2BAA2B,CAAC,aAAD,CAA7C;;AAEA,UAAI,mBAAmB,KAAK,SAA5B,EAAuC;AACnC,QAAA,YAAY,GAAG,mBAAmB,CAAC,IAAD,EAAO,SAAP,CAAlC;AACH,OAFD,MAEO,IAAI,OAAO,mBAAP,KAA+B,QAAnC,EAA6C;AAChD,YAAI,mBAAmB,GAAG,CAAtB,IAA2B,mBAAmB,IAAI,KAAK,eAA3D,EAA4E;AACxE,gBAAM,oBAAoB,EAA1B;AACH;;AAED,QAAA,YAAY,GAAG,wBAAwB,CAAC,IAAD,EAAO,SAAP,EAAkB,mBAAlB,CAAvC;AACH,OANM,MAMA;AACH,YAAI,MAAM,KAAK,SAAX,KAAyB,MAAM,GAAG,CAAT,IAAc,MAAM,IAAI,KAAK,eAAtD,CAAJ,EAA4E;AACxE,gBAAM,oBAAoB,EAA1B;AACH;;AAED,YAAI,WAAW,CAAC,mBAAD,CAAX,IAAoC,KAAK,KAAK,SAA9C,KAA4D,KAAK,GAAG,CAAR,IAAa,KAAK,IAAI,mBAAmB,CAAC,cAAtG,CAAJ,EAA2H;AACvH,gBAAM,oBAAoB,EAA1B;AACH;;AAED,QAAA,YAAY,GAAG,6BAA6B,CAAC,IAAD,EAAO,SAAP,EAAkB,mBAAlB,EAAuC,MAAvC,EAA+C,KAA/C,CAA5C;;AAEA,YAAI,YAAY,CAAC,MAAb,KAAwB,CAA5B,EAA+B;AAC3B,gBAAM,wBAAwB,EAA9B;AACH;AACJ,OA7Ba,CA+Bd;;;AACA,WAAK,MAAM,WAAX,IAA0B,YAA1B,EAAwC;AACpC,cAAM,MAAM,GAAG,YAAY,CAAC,CAAC,IAAD,CAAD,EAAS,WAAT,CAA3B;AAEA,QAAA,sBAAsB,CAAC,MAAD,EAAS,qBAAT,CAAtB;AACH;AACJ;;AA3NuC,GAD5C;AA8NH,CA/OM","sourceRoot":"","sourcesContent":["import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }\n        else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n        return true;\n    }\n    return false;\n};\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        return [passiveInputConnection[2], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n        return [passiveInputConnection[1], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputsOfAudioNode = (source, isOffline, destination, output, input) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\nconst deleteInputsOfAudioParam = (source, isOffline, destination, output) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\nconst deleteAnyConnection = (source, isOffline) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n        destinations.push(outputConnection[0]);\n    }\n    audioNodeConnectionsOfSource.outputs.clear();\n    return destinations;\n};\nconst deleteConnectionAtOutput = (source, isOffline, output) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            }\n            else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n    return destinations;\n};\nconst deleteConnectionToDestination = (source, isOffline, destination, output, input) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter((outputConnection) => outputConnection[0] === destination &&\n        (output === undefined || outputConnection[1] === output) &&\n        (input === undefined || outputConnection[2] === input))\n        .map((outputConnection) => {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n        audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        return outputConnection[0];\n    });\n};\nexport const createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext) => {\n    return class AudioNode extends eventTargetConstructor {\n        constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n            super(nativeAudioNode);\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n            const nativeContext = getNativeContext(context);\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext);\n                    })) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n        get channelCount() {\n            return this._nativeAudioNode.channelCount;\n        }\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n        get channelInterpretation() {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n        get context() {\n            return this._context;\n        }\n        get numberOfInputs() {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n        get numberOfOutputs() {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n        // tslint:disable-next-line:invalid-void\n        connect(destination, output = 0, input = 0) {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n                    const isPassive = isPassiveAudioNode(this);\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                }\n                catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n                    throw err;\n                }\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline);\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], destination);\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n                return destination;\n            }\n            const nativeAudioParam = getNativeAudioParam(destination);\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if (nativeAudioParam.name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n                throw createNotSupportedError();\n            }\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            }\n            catch (err) {\n                // Bug #58: Only Firefox does throw an InvalidAccessError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n                throw err;\n            }\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n        disconnect(destinationOrOutput, output, input) {\n            let destinations;\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            }\n            else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n//# sourceMappingURL=audio-node-constructor.js.map"]},"metadata":{},"sourceType":"module"}