{"ast":null,"code":"import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) => {\n  // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n  const CURVE_SIZE = 16385;\n  const DC_CURVE = new Float32Array([1, 1]);\n  const HALF_PI = Math.PI / 2;\n  const SINGLE_CHANNEL_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete'\n  };\n  const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS,\n    oversample: 'none'\n  };\n\n  const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n    const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n    for (let i = 0; i < CURVE_SIZE; i += 1) {\n      const x = i / (CURVE_SIZE - 1) * HALF_PI;\n      leftWaveShaperCurve[i] = Math.cos(x);\n      rightWaveShaperCurve[i] = Math.sin(x);\n    }\n\n    const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const leftWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: leftWaveShaperCurve\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: DC_CURVE\n    });\n    const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const rightWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: rightWaveShaperCurve\n    });\n    return {\n      connectGraph() {\n        inputGainNode.connect(leftGainNode);\n        inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n        inputGainNode.connect(rightGainNode);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.connect(leftGainNode.gain);\n        rightWaveShaperNode.connect(rightGainNode.gain);\n        leftGainNode.connect(channelMergerNode, 0, 0);\n        rightGainNode.connect(channelMergerNode, 0, 1);\n      },\n\n      disconnectGraph() {\n        inputGainNode.disconnect(leftGainNode);\n        inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n        inputGainNode.disconnect(rightGainNode);\n        panWaveShaperNode.disconnect(panGainNode);\n        panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.disconnect(leftGainNode.gain);\n        rightWaveShaperNode.disconnect(rightGainNode.gain);\n        leftGainNode.disconnect(channelMergerNode, 0, 0);\n        rightGainNode.disconnect(channelMergerNode, 0, 1);\n      }\n\n    };\n  };\n\n  const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n    const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const centerIndex = Math.floor(CURVE_SIZE / 2);\n\n    for (let i = 0; i < CURVE_SIZE; i += 1) {\n      if (i > centerIndex) {\n        const x = (i - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n        leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n        leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n        rightInputForLeftOutputWaveShaperCurve[i] = 0;\n        rightInputForRightOutputWaveShaperCurve[i] = 1;\n      } else {\n        const x = i / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n        leftInputForLeftOutputWaveShaperCurve[i] = 1;\n        leftInputForRightOutputWaveShaperCurve[i] = 0;\n        rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n        rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n      }\n    }\n\n    const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: 2,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: 2\n    });\n    const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: leftInputForLeftOutputWaveShaperCurve\n    });\n    const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: leftInputForRightOutputWaveShaperCurve\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: DC_CURVE\n    });\n    const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: rightInputForLeftOutputWaveShaperCurve\n    });\n    const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: rightInputForRightOutputWaveShaperCurve\n    });\n    return {\n      connectGraph() {\n        inputGainNode.connect(channelSplitterNode);\n        inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n        channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n        channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n        channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === undefined ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === undefined ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === undefined ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === undefined ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n      },\n\n      disconnectGraph() {\n        inputGainNode.disconnect(channelSplitterNode);\n        inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n        channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n        channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n        channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.disconnect(panGainNode);\n        panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === undefined ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === undefined ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === undefined ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === undefined ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n      }\n\n    };\n  };\n\n  const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {\n    if (channelCount === 1) {\n      return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n    }\n\n    if (channelCount === 2) {\n      return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n    }\n\n    throw createNotSupportedError();\n  };\n\n  return (nativeContext, {\n    channelCount,\n    channelCountMode,\n    pan,\n    ...audioNodeOptions\n  }) => {\n    if (channelCountMode === 'max') {\n      throw createNotSupportedError();\n    }\n\n    const channelMergerNode = createNativeChannelMergerNode(nativeContext, { ...audioNodeOptions,\n      channelCount: 1,\n      channelCountMode,\n      numberOfInputs: 2\n    });\n    const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      channelCount,\n      channelCountMode,\n      gain: 1\n    });\n    const panGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: pan\n    });\n    let {\n      connectGraph,\n      disconnectGraph\n    } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);\n    Object.defineProperty(panGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(panGainNode.gain, 'maxValue', {\n      get: () => 1\n    });\n    Object.defineProperty(panGainNode.gain, 'minValue', {\n      get: () => -1\n    });\n    const nativeStereoPannerNodeFakerFactory = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return inputGainNode.channelCount;\n      },\n\n      set channelCount(value) {\n        if (inputGainNode.channelCount !== value) {\n          if (isConnected) {\n            disconnectGraph();\n          }\n\n          ({\n            connectGraph,\n            disconnectGraph\n          } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));\n\n          if (isConnected) {\n            connectGraph();\n          }\n        }\n\n        inputGainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return inputGainNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        if (value === 'clamped-max' || value === 'max') {\n          throw createNotSupportedError();\n        }\n\n        inputGainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return inputGainNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return inputGainNode.context;\n      },\n\n      get inputs() {\n        return [inputGainNode];\n      },\n\n      get numberOfInputs() {\n        return inputGainNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return inputGainNode.numberOfOutputs;\n      },\n\n      get pan() {\n        return panGainNode.gain;\n      },\n\n      addEventListener(...args) {\n        return inputGainNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return inputGainNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n    let isConnected = false;\n\n    const whenConnected = () => {\n      connectGraph();\n      isConnected = true;\n    };\n\n    const whenDisconnected = () => {\n      disconnectGraph();\n      isConnected = false;\n    };\n\n    return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"sources":["../../../src/factories/native-stereo-panner-node-faker-factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' };\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' };\n    const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve }));\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE }));\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve }));\n        return {\n            connectGraph() {\n                inputGainNode.connect(leftGainNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.connect(rightGainNode);\n                panWaveShaperNode.connect(panGainNode);\n                panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n                leftWaveShaperNode.connect(leftGainNode.gain);\n                rightWaveShaperNode.connect(rightGainNode.gain);\n                leftGainNode.connect(channelMergerNode, 0, 0);\n                rightGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph() {\n                inputGainNode.disconnect(leftGainNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.disconnect(rightGainNode);\n                panWaveShaperNode.disconnect(panGainNode);\n                panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n                leftWaveShaperNode.disconnect(leftGainNode.gain);\n                rightWaveShaperNode.disconnect(rightGainNode.gain);\n                leftGainNode.disconnect(channelMergerNode, 0, 0);\n                rightGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n    const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            }\n            else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForLeftOutputWaveShaperCurve\n        });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForRightOutputWaveShaperCurve\n        });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = (createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE }));\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForLeftOutputWaveShaperCurve\n        });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForRightOutputWaveShaperCurve\n        });\n        return {\n            connectGraph() {\n                inputGainNode.connect(channelSplitterNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n                panWaveShaperNode.connect(panGainNode);\n                panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                    ? leftInputForLeftOutputWaveShaperNode\n                    : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === undefined\n                    ? leftInputForRightOutputWaveShaperNode\n                    : leftInputForRightOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                    ? rightInputForLeftOutputWaveShaperNode\n                    : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === undefined\n                    ? rightInputForRightOutputWaveShaperNode\n                    : rightInputForRightOutputWaveShaperNode.inputs[0]);\n                leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n                leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph() {\n                inputGainNode.disconnect(channelSplitterNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n                panWaveShaperNode.disconnect(panGainNode);\n                panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                    ? leftInputForLeftOutputWaveShaperNode\n                    : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === undefined\n                    ? leftInputForRightOutputWaveShaperNode\n                    : leftInputForRightOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                    ? rightInputForLeftOutputWaveShaperNode\n                    : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === undefined\n                    ? rightInputForRightOutputWaveShaperNode\n                    : rightInputForRightOutputWaveShaperNode.inputs[0]);\n                leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n                leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n    const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        throw createNotSupportedError();\n    };\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n        let { connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(panGainNode.gain, 'maxValue', { get: () => 1 });\n        Object.defineProperty(panGainNode.gain, 'minValue', { get: () => -1 });\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    if (isConnected) {\n                        disconnectGraph();\n                    }\n                    ({ connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));\n                    if (isConnected) {\n                        connectGraph();\n                    }\n                }\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return inputGainNode.context;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan() {\n                return panGainNode.gain;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        let isConnected = false;\n        const whenConnected = () => {\n            connectGraph();\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            disconnectGraph();\n            isConnected = false;\n        };\n        return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-stereo-panner-node-faker-factory.js.map"]},"metadata":{},"sourceType":"module"}