{"ast":null,"code":"import { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\n\nexport class ToneAudioNode extends ToneWithContext {\n  constructor() {\n    super(...arguments);\n    /**\n     * The name of the class\n     */\n\n    this.name = \"ToneAudioNode\";\n    /**\n     * List all of the node that must be set to match the ChannelProperties\n     */\n\n    this._internalChannels = [];\n  }\n  /**\n   * The number of inputs feeding into the AudioNode.\n   * For source nodes, this will be 0.\n   * @example\n   * const node = new Tone.Gain();\n   * console.log(node.numberOfInputs);\n   */\n\n\n  get numberOfInputs() {\n    if (isDefined(this.input)) {\n      if (isAudioParam(this.input) || this.input instanceof Param) {\n        return 1;\n      } else {\n        return this.input.numberOfInputs;\n      }\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The number of outputs of the AudioNode.\n   * @example\n   * const node = new Tone.Gain();\n   * console.log(node.numberOfOutputs);\n   */\n\n\n  get numberOfOutputs() {\n    if (isDefined(this.output)) {\n      return this.output.numberOfOutputs;\n    } else {\n      return 0;\n    }\n  } //-------------------------------------\n  // AUDIO PROPERTIES\n  //-------------------------------------\n\n  /**\n   * Used to decide which nodes to get/set properties on\n   */\n\n\n  _isAudioNode(node) {\n    return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n  }\n  /**\n   * Get all of the audio nodes (either internal or input/output) which together\n   * make up how the class node responds to channel input/output\n   */\n\n\n  _getInternalNodes() {\n    const nodeList = this._internalChannels.slice(0);\n\n    if (this._isAudioNode(this.input)) {\n      nodeList.push(this.input);\n    }\n\n    if (this._isAudioNode(this.output)) {\n      if (this.input !== this.output) {\n        nodeList.push(this.output);\n      }\n    }\n\n    return nodeList;\n  }\n  /**\n   * Set the audio options for this node such as channelInterpretation\n   * channelCount, etc.\n   * @param options\n   */\n\n\n  _setChannelProperties(options) {\n    const nodeList = this._getInternalNodes();\n\n    nodeList.forEach(node => {\n      node.channelCount = options.channelCount;\n      node.channelCountMode = options.channelCountMode;\n      node.channelInterpretation = options.channelInterpretation;\n    });\n  }\n  /**\n   * Get the current audio options for this node such as channelInterpretation\n   * channelCount, etc.\n   */\n\n\n  _getChannelProperties() {\n    const nodeList = this._getInternalNodes();\n\n    assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\"); // use the first node to get properties\n    // they should all be the same\n\n    const node = nodeList[0];\n    return {\n      channelCount: node.channelCount,\n      channelCountMode: node.channelCountMode,\n      channelInterpretation: node.channelInterpretation\n    };\n  }\n  /**\n   * channelCount is the number of channels used when up-mixing and down-mixing\n   * connections to any inputs to the node. The default value is 2 except for\n   * specific nodes where its value is specially determined.\n   */\n\n\n  get channelCount() {\n    return this._getChannelProperties().channelCount;\n  }\n\n  set channelCount(channelCount) {\n    const props = this._getChannelProperties(); // merge it with the other properties\n\n\n    this._setChannelProperties(Object.assign(props, {\n      channelCount\n    }));\n  }\n  /**\n   * channelCountMode determines how channels will be counted when up-mixing and\n   * down-mixing connections to any inputs to the node.\n   * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n   * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n   * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n   * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n   */\n\n\n  get channelCountMode() {\n    return this._getChannelProperties().channelCountMode;\n  }\n\n  set channelCountMode(channelCountMode) {\n    const props = this._getChannelProperties(); // merge it with the other properties\n\n\n    this._setChannelProperties(Object.assign(props, {\n      channelCountMode\n    }));\n  }\n  /**\n   * channelInterpretation determines how individual channels will be treated\n   * when up-mixing and down-mixing connections to any inputs to the node.\n   * The default value is \"speakers\".\n   */\n\n\n  get channelInterpretation() {\n    return this._getChannelProperties().channelInterpretation;\n  }\n\n  set channelInterpretation(channelInterpretation) {\n    const props = this._getChannelProperties(); // merge it with the other properties\n\n\n    this._setChannelProperties(Object.assign(props, {\n      channelInterpretation\n    }));\n  } //-------------------------------------\n  // CONNECTIONS\n  //-------------------------------------\n\n  /**\n   * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n   * @param destination The output to connect to\n   * @param outputNum The output to connect from\n   * @param inputNum The input to connect to\n   */\n\n\n  connect(destination, outputNum = 0, inputNum = 0) {\n    connect(this, destination, outputNum, inputNum);\n    return this;\n  }\n  /**\n   * Connect the output to the context's destination node.\n   * @example\n   * const osc = new Tone.Oscillator(\"C2\").start();\n   * osc.toDestination();\n   */\n\n\n  toDestination() {\n    this.connect(this.context.destination);\n    return this;\n  }\n  /**\n   * Connect the output to the context's destination node.\n   * See [[toDestination]]\n   * @deprecated\n   */\n\n\n  toMaster() {\n    warn(\"toMaster() has been renamed toDestination()\");\n    return this.toDestination();\n  }\n  /**\n   * disconnect the output\n   */\n\n\n  disconnect(destination, outputNum = 0, inputNum = 0) {\n    disconnect(this, destination, outputNum, inputNum);\n    return this;\n  }\n  /**\n   * Connect the output of this node to the rest of the nodes in series.\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3\");\n   * player.autostart = true;\n   * const filter = new Tone.AutoFilter(4).start();\n   * const distortion = new Tone.Distortion(0.5);\n   * // connect the player to the filter, distortion and then to the master output\n   * player.chain(filter, distortion, Tone.Destination);\n   */\n\n\n  chain(...nodes) {\n    connectSeries(this, ...nodes);\n    return this;\n  }\n  /**\n   * connect the output of this node to the rest of the nodes in parallel.\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n   * player.autostart = true;\n   * const pitchShift = new Tone.PitchShift(4).toDestination();\n   * const filter = new Tone.Filter(\"G5\").toDestination();\n   * // connect a node to the pitch shift and filter in parallel\n   * player.fan(pitchShift, filter);\n   */\n\n\n  fan(...nodes) {\n    nodes.forEach(node => this.connect(node));\n    return this;\n  }\n  /**\n   * Dispose and disconnect\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (isDefined(this.input)) {\n      if (this.input instanceof ToneAudioNode) {\n        this.input.dispose();\n      } else if (isAudioNode(this.input)) {\n        this.input.disconnect();\n      }\n    }\n\n    if (isDefined(this.output)) {\n      if (this.output instanceof ToneAudioNode) {\n        this.output.dispose();\n      } else if (isAudioNode(this.output)) {\n        this.output.disconnect();\n      }\n    }\n\n    this._internalChannels = [];\n    return this;\n  }\n\n} //-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\n\nexport function connectSeries(...nodes) {\n  const first = nodes.shift();\n  nodes.reduce((prev, current) => {\n    if (prev instanceof ToneAudioNode) {\n      prev.connect(current);\n    } else if (isAudioNode(prev)) {\n      connect(prev, current);\n    }\n\n    return current;\n  }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nexport function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n  assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n  assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n  if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n    assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n  }\n\n  assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\"); // resolve the input of the dstNode\n\n  while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n    if (isDefined(dstNode.input)) {\n      dstNode = dstNode.input;\n    }\n  }\n\n  while (srcNode instanceof ToneAudioNode) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  } // make the connection\n\n\n  if (isAudioParam(dstNode)) {\n    srcNode.connect(dstNode, outputNumber);\n  } else {\n    srcNode.connect(dstNode, outputNumber, inputNumber);\n  }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nexport function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n  // resolve the destination node\n  if (isDefined(dstNode)) {\n    while (dstNode instanceof ToneAudioNode) {\n      dstNode = dstNode.input;\n    }\n  } // resolve the src node\n\n\n  while (!isAudioNode(srcNode)) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  }\n\n  if (isAudioParam(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber);\n  } else if (isAudioNode(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber, inputNumber);\n  } else {\n    srcNode.disconnect();\n  }\n}","map":{"version":3,"sources":["../../../../Tone/core/context/ToneAudioNode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\nexport class ToneAudioNode extends ToneWithContext {\n    constructor() {\n        super(...arguments);\n        /**\n         * The name of the class\n         */\n        this.name = \"ToneAudioNode\";\n        /**\n         * List all of the node that must be set to match the ChannelProperties\n         */\n        this._internalChannels = [];\n    }\n    /**\n     * The number of inputs feeding into the AudioNode.\n     * For source nodes, this will be 0.\n     * @example\n     * const node = new Tone.Gain();\n     * console.log(node.numberOfInputs);\n     */\n    get numberOfInputs() {\n        if (isDefined(this.input)) {\n            if (isAudioParam(this.input) || this.input instanceof Param) {\n                return 1;\n            }\n            else {\n                return this.input.numberOfInputs;\n            }\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The number of outputs of the AudioNode.\n     * @example\n     * const node = new Tone.Gain();\n     * console.log(node.numberOfOutputs);\n     */\n    get numberOfOutputs() {\n        if (isDefined(this.output)) {\n            return this.output.numberOfOutputs;\n        }\n        else {\n            return 0;\n        }\n    }\n    //-------------------------------------\n    // AUDIO PROPERTIES\n    //-------------------------------------\n    /**\n     * Used to decide which nodes to get/set properties on\n     */\n    _isAudioNode(node) {\n        return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n    }\n    /**\n     * Get all of the audio nodes (either internal or input/output) which together\n     * make up how the class node responds to channel input/output\n     */\n    _getInternalNodes() {\n        const nodeList = this._internalChannels.slice(0);\n        if (this._isAudioNode(this.input)) {\n            nodeList.push(this.input);\n        }\n        if (this._isAudioNode(this.output)) {\n            if (this.input !== this.output) {\n                nodeList.push(this.output);\n            }\n        }\n        return nodeList;\n    }\n    /**\n     * Set the audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     * @param options\n     */\n    _setChannelProperties(options) {\n        const nodeList = this._getInternalNodes();\n        nodeList.forEach(node => {\n            node.channelCount = options.channelCount;\n            node.channelCountMode = options.channelCountMode;\n            node.channelInterpretation = options.channelInterpretation;\n        });\n    }\n    /**\n     * Get the current audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     */\n    _getChannelProperties() {\n        const nodeList = this._getInternalNodes();\n        assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\");\n        // use the first node to get properties\n        // they should all be the same\n        const node = nodeList[0];\n        return {\n            channelCount: node.channelCount,\n            channelCountMode: node.channelCountMode,\n            channelInterpretation: node.channelInterpretation,\n        };\n    }\n    /**\n     * channelCount is the number of channels used when up-mixing and down-mixing\n     * connections to any inputs to the node. The default value is 2 except for\n     * specific nodes where its value is specially determined.\n     */\n    get channelCount() {\n        return this._getChannelProperties().channelCount;\n    }\n    set channelCount(channelCount) {\n        const props = this._getChannelProperties();\n        // merge it with the other properties\n        this._setChannelProperties(Object.assign(props, { channelCount }));\n    }\n    /**\n     * channelCountMode determines how channels will be counted when up-mixing and\n     * down-mixing connections to any inputs to the node.\n     * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n     * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n     * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n     * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n     */\n    get channelCountMode() {\n        return this._getChannelProperties().channelCountMode;\n    }\n    set channelCountMode(channelCountMode) {\n        const props = this._getChannelProperties();\n        // merge it with the other properties\n        this._setChannelProperties(Object.assign(props, { channelCountMode }));\n    }\n    /**\n     * channelInterpretation determines how individual channels will be treated\n     * when up-mixing and down-mixing connections to any inputs to the node.\n     * The default value is \"speakers\".\n     */\n    get channelInterpretation() {\n        return this._getChannelProperties().channelInterpretation;\n    }\n    set channelInterpretation(channelInterpretation) {\n        const props = this._getChannelProperties();\n        // merge it with the other properties\n        this._setChannelProperties(Object.assign(props, { channelInterpretation }));\n    }\n    //-------------------------------------\n    // CONNECTIONS\n    //-------------------------------------\n    /**\n     * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n     * @param destination The output to connect to\n     * @param outputNum The output to connect from\n     * @param inputNum The input to connect to\n     */\n    connect(destination, outputNum = 0, inputNum = 0) {\n        connect(this, destination, outputNum, inputNum);\n        return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * @example\n     * const osc = new Tone.Oscillator(\"C2\").start();\n     * osc.toDestination();\n     */\n    toDestination() {\n        this.connect(this.context.destination);\n        return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * See [[toDestination]]\n     * @deprecated\n     */\n    toMaster() {\n        warn(\"toMaster() has been renamed toDestination()\");\n        return this.toDestination();\n    }\n    /**\n     * disconnect the output\n     */\n    disconnect(destination, outputNum = 0, inputNum = 0) {\n        disconnect(this, destination, outputNum, inputNum);\n        return this;\n    }\n    /**\n     * Connect the output of this node to the rest of the nodes in series.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3\");\n     * player.autostart = true;\n     * const filter = new Tone.AutoFilter(4).start();\n     * const distortion = new Tone.Distortion(0.5);\n     * // connect the player to the filter, distortion and then to the master output\n     * player.chain(filter, distortion, Tone.Destination);\n     */\n    chain(...nodes) {\n        connectSeries(this, ...nodes);\n        return this;\n    }\n    /**\n     * connect the output of this node to the rest of the nodes in parallel.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n     * player.autostart = true;\n     * const pitchShift = new Tone.PitchShift(4).toDestination();\n     * const filter = new Tone.Filter(\"G5\").toDestination();\n     * // connect a node to the pitch shift and filter in parallel\n     * player.fan(pitchShift, filter);\n     */\n    fan(...nodes) {\n        nodes.forEach(node => this.connect(node));\n        return this;\n    }\n    /**\n     * Dispose and disconnect\n     */\n    dispose() {\n        super.dispose();\n        if (isDefined(this.input)) {\n            if (this.input instanceof ToneAudioNode) {\n                this.input.dispose();\n            }\n            else if (isAudioNode(this.input)) {\n                this.input.disconnect();\n            }\n        }\n        if (isDefined(this.output)) {\n            if (this.output instanceof ToneAudioNode) {\n                this.output.dispose();\n            }\n            else if (isAudioNode(this.output)) {\n                this.output.disconnect();\n            }\n        }\n        this._internalChannels = [];\n        return this;\n    }\n}\n//-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\nexport function connectSeries(...nodes) {\n    const first = nodes.shift();\n    nodes.reduce((prev, current) => {\n        if (prev instanceof ToneAudioNode) {\n            prev.connect(current);\n        }\n        else if (isAudioNode(prev)) {\n            connect(prev, current);\n        }\n        return current;\n    }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n    assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n    assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n    if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n        assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n    }\n    assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\");\n    // resolve the input of the dstNode\n    while ((dstNode instanceof ToneAudioNode || dstNode instanceof Param)) {\n        if (isDefined(dstNode.input)) {\n            dstNode = dstNode.input;\n        }\n    }\n    while (srcNode instanceof ToneAudioNode) {\n        if (isDefined(srcNode.output)) {\n            srcNode = srcNode.output;\n        }\n    }\n    // make the connection\n    if (isAudioParam(dstNode)) {\n        srcNode.connect(dstNode, outputNumber);\n    }\n    else {\n        srcNode.connect(dstNode, outputNumber, inputNumber);\n    }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n    // resolve the destination node\n    if (isDefined(dstNode)) {\n        while (dstNode instanceof ToneAudioNode) {\n            dstNode = dstNode.input;\n        }\n    }\n    // resolve the src node\n    while (!(isAudioNode(srcNode))) {\n        if (isDefined(srcNode.output)) {\n            srcNode = srcNode.output;\n        }\n    }\n    if (isAudioParam(dstNode)) {\n        srcNode.disconnect(dstNode, outputNumber);\n    }\n    else if (isAudioNode(dstNode)) {\n        srcNode.disconnect(dstNode, outputNumber, inputNumber);\n    }\n    else {\n        srcNode.disconnect();\n    }\n}\n//# sourceMappingURL=ToneAudioNode.js.map"]},"metadata":{},"sourceType":"module"}