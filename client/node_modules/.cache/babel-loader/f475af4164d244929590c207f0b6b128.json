{"ast":null,"code":"import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections) => {\n  return (nativeContext, {\n    curve,\n    oversample,\n    ...audioNodeOptions\n  }) => {\n    const negativeWaveShaperNode = nativeContext.createWaveShaper();\n    const positiveWaveShaperNode = nativeContext.createWaveShaper();\n    assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n    assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n    const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: 1\n    });\n    const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: -1\n    });\n    const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: 1\n    });\n    const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: -1\n    });\n    let disconnectNativeAudioBufferSourceNode = null;\n    let isConnected = false;\n    let unmodifiedCurve = null;\n    const nativeWaveShaperNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return negativeWaveShaperNode.channelCount;\n      },\n\n      set channelCount(value) {\n        inputGainNode.channelCount = value;\n        invertGainNode.channelCount = value;\n        negativeWaveShaperNode.channelCount = value;\n        outputGainNode.channelCount = value;\n        positiveWaveShaperNode.channelCount = value;\n        revertGainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return negativeWaveShaperNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        inputGainNode.channelCountMode = value;\n        invertGainNode.channelCountMode = value;\n        negativeWaveShaperNode.channelCountMode = value;\n        outputGainNode.channelCountMode = value;\n        positiveWaveShaperNode.channelCountMode = value;\n        revertGainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return negativeWaveShaperNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n        invertGainNode.channelInterpretation = value;\n        negativeWaveShaperNode.channelInterpretation = value;\n        outputGainNode.channelInterpretation = value;\n        positiveWaveShaperNode.channelInterpretation = value;\n        revertGainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return negativeWaveShaperNode.context;\n      },\n\n      get curve() {\n        return unmodifiedCurve;\n      },\n\n      set curve(value) {\n        // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n        if (value !== null && value.length < 2) {\n          throw createInvalidStateError();\n        }\n\n        if (value === null) {\n          negativeWaveShaperNode.curve = value;\n          positiveWaveShaperNode.curve = value;\n        } else {\n          const curveLength = value.length;\n          const negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n          const positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n          negativeCurve[0] = value[0];\n          positiveCurve[0] = -value[curveLength - 1];\n          const length = Math.ceil((curveLength + 1) / 2);\n          const centerIndex = (curveLength + 1) / 2 - 1;\n\n          for (let i = 1; i < length; i += 1) {\n            const theoreticIndex = i / length * centerIndex;\n            const lowerIndex = Math.floor(theoreticIndex);\n            const upperIndex = Math.ceil(theoreticIndex);\n            negativeCurve[i] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n            positiveCurve[i] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n          }\n\n          negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n          negativeWaveShaperNode.curve = negativeCurve;\n          positiveWaveShaperNode.curve = positiveCurve;\n        }\n\n        unmodifiedCurve = value;\n\n        if (isConnected) {\n          if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n          } else if (disconnectNativeAudioBufferSourceNode !== null) {\n            disconnectNativeAudioBufferSourceNode();\n            disconnectNativeAudioBufferSourceNode = null;\n          }\n        }\n      },\n\n      get inputs() {\n        return [inputGainNode];\n      },\n\n      get numberOfInputs() {\n        return negativeWaveShaperNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return negativeWaveShaperNode.numberOfOutputs;\n      },\n\n      get oversample() {\n        return negativeWaveShaperNode.oversample;\n      },\n\n      set oversample(value) {\n        negativeWaveShaperNode.oversample = value;\n        positiveWaveShaperNode.oversample = value;\n      },\n\n      addEventListener(...args) {\n        return inputGainNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return inputGainNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n\n    if (curve !== null) {\n      // Only values of type Float32Array can be assigned to the curve property.\n      nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n    }\n\n    if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n      nativeWaveShaperNodeFaker.oversample = oversample;\n    }\n\n    const whenConnected = () => {\n      inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n      inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n      isConnected = true;\n\n      if (isDCCurve(unmodifiedCurve)) {\n        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n      }\n    };\n\n    const whenDisconnected = () => {\n      inputGainNode.disconnect(negativeWaveShaperNode);\n      negativeWaveShaperNode.disconnect(outputGainNode);\n      inputGainNode.disconnect(invertGainNode);\n      invertGainNode.disconnect(positiveWaveShaperNode);\n      positiveWaveShaperNode.disconnect(revertGainNode);\n      revertGainNode.disconnect(outputGainNode);\n      isConnected = false;\n\n      if (disconnectNativeAudioBufferSourceNode !== null) {\n        disconnectNativeAudioBufferSourceNode();\n        disconnectNativeAudioBufferSourceNode = null;\n      }\n    };\n\n    return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"sources":["../../../src/factories/native-wave-shaper-node-faker-factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = nativeContext.createWaveShaper();\n        const positiveWaveShaperNode = nativeContext.createWaveShaper();\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        let disconnectNativeAudioBufferSourceNode = null;\n        let isConnected = false;\n        let unmodifiedCurve = null;\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return negativeWaveShaperNode.context;\n            },\n            get curve() {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (value !== null && value.length < 2) {\n                    throw createInvalidStateError();\n                }\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                }\n                else {\n                    const curveLength = value.length;\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = (curveLength + 1) / 2 - 1;\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        negativeCurve[i] =\n                            lowerIndex === upperIndex\n                                ? value[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] +\n                                    (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                        positiveCurve[i] =\n                            lowerIndex === upperIndex\n                                ? -value[curveLength - 1 - lowerIndex]\n                                : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) -\n                                    (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n                    }\n                    negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n                unmodifiedCurve = value;\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    }\n                    else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample() {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (curve !== null) {\n            // Only values of type Float32Array can be assigned to the curve property.\n            nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n        }\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n        const whenConnected = () => {\n            inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n            inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n            isConnected = true;\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n            isConnected = false;\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-wave-shaper-node-faker-factory.js.map"]},"metadata":{},"sourceType":"module"}