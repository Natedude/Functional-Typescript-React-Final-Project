{"ast":null,"code":"import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { dbToGain } from \"../../core/type/Conversions\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase } from \"./MeterBase\";\nimport { assert } from \"../../core/util/Debug\";\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * @category Component\n */\n\nexport class FFT extends MeterBase {\n  constructor() {\n    super(optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]));\n    this.name = \"FFT\";\n    const options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n    this.normalRange = options.normalRange;\n    this._analyser.type = \"fft\";\n    this.size = options.size;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      normalRange: false,\n      size: 1024,\n      smoothing: 0.8\n    });\n  }\n  /**\n   * Gets the current frequency data from the connected audio source.\n   * Returns the frequency data of length [[size]] as a Float32Array of decibel values.\n   */\n\n\n  getValue() {\n    const values = this._analyser.getValue();\n\n    return values.map(v => this.normalRange ? dbToGain(v) : v);\n  }\n  /**\n   * The size of analysis. This must be a power of two in the range 16 to 16384.\n   * Determines the size of the array returned by [[getValue]] (i.e. the number of\n   * frequency bins). Large FFT sizes may be costly to compute.\n   */\n\n\n  get size() {\n    return this._analyser.size;\n  }\n\n  set size(size) {\n    this._analyser.size = size;\n  }\n  /**\n   * 0 represents no time averaging with the last analysis frame.\n   */\n\n\n  get smoothing() {\n    return this._analyser.smoothing;\n  }\n\n  set smoothing(val) {\n    this._analyser.smoothing = val;\n  }\n  /**\n   * Returns the frequency value in hertz of each of the indices of the FFT's [[getValue]] response.\n   * @example\n   * const fft = new Tone.FFT(32);\n   * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));\n   */\n\n\n  getFrequencyOfIndex(index) {\n    assert(0 <= index && index < this.size, `index must be greater than or equal to 0 and less than ${this.size}`);\n    return index * this.context.sampleRate / (this.size * 2);\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/component/analysis/FFT.ts"],"names":[],"mappings":"AAAA,SAAS,aAAT,QAA8B,kCAA9B;AACA,SAAS,QAAT,QAAyB,6BAAzB;AAEA,SAAS,oBAAT,QAAqC,0BAArC;AACA,SAAS,SAAT,QAA4C,aAA5C;AACA,SAAS,MAAT,QAAuB,uBAAvB;AAQA;;;AAGG;;AACH,OAAM,MAAO,GAAP,SAAmB,SAAnB,CAAwC;AAgB7C,EAAA,WAAA,GAAA;AACC,UAAM,oBAAoB,CAAC,GAAG,CAAC,WAAJ,EAAD,EAAoB,SAApB,EAA+B,CAAC,MAAD,CAA/B,CAA1B;AAfQ,SAAA,IAAA,GAAe,KAAf;AAgBR,UAAM,OAAO,GAAG,oBAAoB,CAAC,GAAG,CAAC,WAAJ,EAAD,EAAoB,SAApB,EAA+B,CAAC,MAAD,CAA/B,CAApC;AAEA,SAAK,WAAL,GAAmB,OAAO,CAAC,WAA3B;AACA,SAAK,SAAL,CAAe,IAAf,GAAsB,KAAtB;AACA,SAAK,IAAL,GAAY,OAAO,CAAC,IAApB;AACA;;AAEiB,SAAX,WAAW,GAAA;AACjB,WAAO,MAAM,CAAC,MAAP,CAAc,aAAa,CAAC,WAAd,EAAd,EAA2C;AACjD,MAAA,WAAW,EAAE,KADoC;AAEjD,MAAA,IAAI,EAAE,IAF2C;AAGjD,MAAA,SAAS,EAAE;AAHsC,KAA3C,CAAP;AAKA;AAED;;;AAGG;;;AACH,EAAA,QAAQ,GAAA;AACP,UAAM,MAAM,GAAG,KAAK,SAAL,CAAe,QAAf,EAAf;;AACA,WAAO,MAAM,CAAC,GAAP,CAAW,CAAC,IAAI,KAAK,WAAL,GAAmB,QAAQ,CAAC,CAAD,CAA3B,GAAiC,CAAjD,CAAP;AACA;AAED;;;;AAIG;;;AACK,MAAJ,IAAI,GAAA;AACP,WAAO,KAAK,SAAL,CAAe,IAAtB;AACA;;AACO,MAAJ,IAAI,CAAC,IAAD,EAAK;AACZ,SAAK,SAAL,CAAe,IAAf,GAAsB,IAAtB;AACA;AAED;;AAEG;;;AACU,MAAT,SAAS,GAAA;AACZ,WAAO,KAAK,SAAL,CAAe,SAAtB;AACA;;AACY,MAAT,SAAS,CAAC,GAAD,EAAI;AAChB,SAAK,SAAL,CAAe,SAAf,GAA2B,GAA3B;AACA;AAED;;;;;AAKG;;;AACH,EAAA,mBAAmB,CAAC,KAAD,EAAc;AAChC,IAAA,MAAM,CAAC,KAAK,KAAL,IAAc,KAAK,GAAG,KAAK,IAA5B,EAAkC,0DAA0D,KAAK,IAAI,EAArG,CAAN;AACA,WAAO,KAAK,GAAG,KAAK,OAAL,CAAa,UAArB,IAAmC,KAAK,IAAL,GAAY,CAA/C,CAAP;AACA;;AAzE4C","sourceRoot":"","sourcesContent":["import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { dbToGain } from \"../../core/type/Conversions\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase } from \"./MeterBase\";\nimport { assert } from \"../../core/util/Debug\";\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * @category Component\n */\nexport class FFT extends MeterBase {\n    constructor() {\n        super(optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]));\n        this.name = \"FFT\";\n        const options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n        this.normalRange = options.normalRange;\n        this._analyser.type = \"fft\";\n        this.size = options.size;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            normalRange: false,\n            size: 1024,\n            smoothing: 0.8,\n        });\n    }\n    /**\n     * Gets the current frequency data from the connected audio source.\n     * Returns the frequency data of length [[size]] as a Float32Array of decibel values.\n     */\n    getValue() {\n        const values = this._analyser.getValue();\n        return values.map(v => this.normalRange ? dbToGain(v) : v);\n    }\n    /**\n     * The size of analysis. This must be a power of two in the range 16 to 16384.\n     * Determines the size of the array returned by [[getValue]] (i.e. the number of\n     * frequency bins). Large FFT sizes may be costly to compute.\n     */\n    get size() {\n        return this._analyser.size;\n    }\n    set size(size) {\n        this._analyser.size = size;\n    }\n    /**\n     * 0 represents no time averaging with the last analysis frame.\n     */\n    get smoothing() {\n        return this._analyser.smoothing;\n    }\n    set smoothing(val) {\n        this._analyser.smoothing = val;\n    }\n    /**\n     * Returns the frequency value in hertz of each of the indices of the FFT's [[getValue]] response.\n     * @example\n     * const fft = new Tone.FFT(32);\n     * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));\n     */\n    getFrequencyOfIndex(index) {\n        assert(0 <= index && index < this.size, `index must be greater than or equal to 0 and less than ${this.size}`);\n        return index * this.context.sampleRate / (this.size * 2);\n    }\n}\n//# sourceMappingURL=FFT.js.map"]},"metadata":{},"sourceType":"module"}