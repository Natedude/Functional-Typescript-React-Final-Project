{"ast":null,"code":"import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAnalyserNodeRendererFactory = (createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeAnalyserNodes = new WeakMap();\n\n    const createAnalyserNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAnalyserNode = getNativeAudioNode(proxy); // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n\n      if (!nativeAnalyserNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeAnalyserNode.channelCount,\n          channelCountMode: nativeAnalyserNode.channelCountMode,\n          channelInterpretation: nativeAnalyserNode.channelInterpretation,\n          fftSize: nativeAnalyserNode.fftSize,\n          maxDecibels: nativeAnalyserNode.maxDecibels,\n          minDecibels: nativeAnalyserNode.minDecibels,\n          smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n        };\n        nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode, trace);\n      return nativeAnalyserNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAnalyserNode !== undefined) {\n          return Promise.resolve(renderedNativeAnalyserNode);\n        }\n\n        return createAnalyserNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","map":{"version":3,"sources":["../../../src/factories/analyser-node-renderer-factory.ts"],"names":[],"mappings":"AAAA,SAAS,gBAAT,QAAiC,gCAAjC;AAIA,OAAO,MAAM,iCAAiC,GAAwC,CAClF,wBADkF,EAElF,kBAFkF,EAGlF,uBAHkF,KAIlF;AACA,SAAO,MAAmE;AACtE,UAAM,2BAA2B,GAAG,IAAI,OAAJ,EAApC;;AAEA,UAAM,kBAAkB,GAAG,OACvB,KADuB,EAEvB,yBAFuB,EAGvB,KAHuB,KAIvB;AACA,UAAI,kBAAkB,GAAG,kBAAkB,CAAyB,KAAzB,CAA3C,CADA,CAGA;;AACA,YAAM,kCAAkC,GAAG,gBAAgB,CAAC,kBAAD,EAAqB,yBAArB,CAA3D;;AAEA,UAAI,CAAC,kCAAL,EAAyC;AACrC,cAAM,OAAO,GAAG;AACZ,UAAA,YAAY,EAAE,kBAAkB,CAAC,YADrB;AAEZ,UAAA,gBAAgB,EAAE,kBAAkB,CAAC,gBAFzB;AAGZ,UAAA,qBAAqB,EAAE,kBAAkB,CAAC,qBAH9B;AAIZ,UAAA,OAAO,EAAE,kBAAkB,CAAC,OAJhB;AAKZ,UAAA,WAAW,EAAE,kBAAkB,CAAC,WALpB;AAMZ,UAAA,WAAW,EAAE,kBAAkB,CAAC,WANpB;AAOZ,UAAA,qBAAqB,EAAE,kBAAkB,CAAC;AAP9B,SAAhB;AAUA,QAAA,kBAAkB,GAAG,wBAAwB,CAAC,yBAAD,EAA4B,OAA5B,CAA7C;AACH;;AAED,MAAA,2BAA2B,CAAC,GAA5B,CAAgC,yBAAhC,EAA2D,kBAA3D;AAEA,YAAM,uBAAuB,CAAC,KAAD,EAAQ,yBAAR,EAAmC,kBAAnC,EAAuD,KAAvD,CAA7B;AAEA,aAAO,kBAAP;AACH,KA7BD;;AA+BA,WAAO;AACH,MAAA,MAAM,CACF,KADE,EAEF,yBAFE,EAGF,KAHE,EAG6B;AAE/B,cAAM,0BAA0B,GAAG,2BAA2B,CAAC,GAA5B,CAAgC,yBAAhC,CAAnC;;AAEA,YAAI,0BAA0B,KAAK,SAAnC,EAA8C;AAC1C,iBAAO,OAAO,CAAC,OAAR,CAAgB,0BAAhB,CAAP;AACH;;AAED,eAAO,kBAAkB,CAAC,KAAD,EAAQ,yBAAR,EAAmC,KAAnC,CAAzB;AACH;;AAbE,KAAP;AAeH,GAjDD;AAkDH,CAvDM","sourceRoot":"","sourcesContent":["import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAnalyserNodeRendererFactory = (createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAnalyserNodes = new WeakMap();\n        const createAnalyserNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAnalyserNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode, trace);\n            return nativeAnalyserNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n                return createAnalyserNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=analyser-node-renderer-factory.js.map"]},"metadata":{},"sourceType":"module"}